<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fuel Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Fuel Specifications</a></li><li class="chapter-item expanded "><a href="tx-format/index.html"><strong aria-hidden="true">1.</strong> Transaction Format</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tx-format/consensus_parameters.html"><strong aria-hidden="true">1.1.</strong> Consensus Parameters</a></li><li class="chapter-item expanded "><a href="tx-format/transaction.html"><strong aria-hidden="true">1.2.</strong> Transaction</a></li><li class="chapter-item expanded "><a href="tx-format/upgrade_purpose.html"><strong aria-hidden="true">1.3.</strong> UpgradePurpose</a></li><li class="chapter-item expanded "><a href="tx-format/policy.html"><strong aria-hidden="true">1.4.</strong> Policy</a></li><li class="chapter-item expanded "><a href="tx-format/input.html"><strong aria-hidden="true">1.5.</strong> Input</a></li><li class="chapter-item expanded "><a href="tx-format/output.html"><strong aria-hidden="true">1.6.</strong> Output</a></li><li class="chapter-item expanded "><a href="tx-format/witness.html"><strong aria-hidden="true">1.7.</strong> Witness</a></li><li class="chapter-item expanded "><a href="tx-format/tx-pointer.html"><strong aria-hidden="true">1.8.</strong> Transaction Pointer</a></li></ol></li><li class="chapter-item expanded "><a href="identifiers/index.html"><strong aria-hidden="true">2.</strong> Computing Identifiers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="identifiers/asset.html"><strong aria-hidden="true">2.1.</strong> Asset ID</a></li><li class="chapter-item expanded "><a href="identifiers/blob-id.html"><strong aria-hidden="true">2.2.</strong> Blob ID</a></li><li class="chapter-item expanded "><a href="identifiers/contract-id.html"><strong aria-hidden="true">2.3.</strong> Contract ID</a></li><li class="chapter-item expanded "><a href="identifiers/predicate-id.html"><strong aria-hidden="true">2.4.</strong> Predicate ID</a></li><li class="chapter-item expanded "><a href="identifiers/transaction-id.html"><strong aria-hidden="true">2.5.</strong> Transaction ID</a></li><li class="chapter-item expanded "><a href="identifiers/utxo-id.html"><strong aria-hidden="true">2.6.</strong> UTXO ID</a></li></ol></li><li class="chapter-item expanded "><a href="protocol/index.html"><strong aria-hidden="true">3.</strong> Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/tx-validity.html"><strong aria-hidden="true">3.1.</strong> Transaction Validity Rules</a></li><li class="chapter-item expanded "><a href="protocol/cryptographic-primitives.html"><strong aria-hidden="true">3.2.</strong> Cryptographic Primitives</a></li><li class="chapter-item expanded "><a href="protocol/storage-initialization.html"><strong aria-hidden="true">3.3.</strong> Storage Slot Initialization</a></li><li class="chapter-item expanded "><a href="protocol/block-header.html"><strong aria-hidden="true">3.4.</strong> Block Header Format</a></li><li class="chapter-item expanded "><a href="protocol/relayer.html"><strong aria-hidden="true">3.5.</strong> Layer 1 Relayer/Bridge Protocol</a></li></ol></li><li class="chapter-item expanded "><a href="abi/index.html"><strong aria-hidden="true">4.</strong> Application Binary Interface (ABI)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="abi/json-abi-format.html"><strong aria-hidden="true">4.1.</strong> JSON ABI Format</a></li><li class="chapter-item expanded "><a href="abi/receipts.html"><strong aria-hidden="true">4.2.</strong> Receipts</a></li><li class="chapter-item expanded "><a href="abi/fn-selector-encoding.html"><strong aria-hidden="true">4.3.</strong> Function Selector Encoding</a></li><li class="chapter-item expanded "><a href="abi/argument-encoding.html"><strong aria-hidden="true">4.4.</strong> Argument Encoding</a></li><li class="chapter-item expanded "><a href="abi/hash-based-ids.html"><strong aria-hidden="true">4.5.</strong> Hash Based Ids</a></li></ol></li><li class="chapter-item expanded "><a href="fuel-vm/index.html"><strong aria-hidden="true">5.</strong> FuelVM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fuel-vm/instruction-set.html"><strong aria-hidden="true">5.1.</strong> Instruction Set</a></li></ol></li><li class="chapter-item expanded "><a href="networks/index.html"><strong aria-hidden="true">6.</strong> Networks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="networks/poa.html"><strong aria-hidden="true">6.1.</strong> Proof of Authority (PoA)</a></li></ol></li><li class="chapter-item expanded "><a href="tests/index.html"><strong aria-hidden="true">7.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tests/sparse-merkle-tree-tests.html"><strong aria-hidden="true">7.1.</strong> Sparse Merkle Tree</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fuel Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/FuelLabs/fuel-specs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fuel-specifications"><a class="header" href="#fuel-specifications">Fuel Specifications</a></h1>
<!-- markdownlint-disable-next-line MD036 -->
<p><strong>Fuel: A Secure Decentralized Generalized Massively Scalable Transaction Ledger</strong></p>
<p>This book specifies the Fuel protocol, including the Fuel Virtual Machine
(short: FuelVM), a blazingly fast verifiable blockchain virtual machine.</p>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<ul>
<li><a href="./tx-format/index.html"><strong>Transaction Format</strong></a> - The Fuel transaction format.</li>
<li><a href="./identifiers/index.html"><strong>Computing Identifiers</strong></a> - Computing unique IDs for transactions, contracts and UTXOs.</li>
<li><a href="./protocol/tx-validity.html"><strong>Transaction Validity</strong></a> - Defines transaction validity rules.</li>
<li><a href="./protocol/cryptographic-primitives.html"><strong>Cryptographic Primitives</strong></a> - Cryptographic primitives used in Fuel.</li>
<li><a href="./abi/index.html"><strong>Application Binary Interface (ABI)</strong></a> - Low-level details on interfacing with Fuel bytecode.</li>
<li><a href="./protocol/storage-initialization.html"><strong>Storage Slot Initialization</strong></a> - JSON format for contract storage slot initialization.</li>
<li><a href="./protocol/block-header.html"><strong>Block Header Format</strong></a> - The Fuel block header format.</li>
<li><a href="./protocol/relayer.html"><strong>Relayer/Bridge</strong></a> - The Fuel relayer/bridge protocol.</li>
</ul>
<h2 id="fuelvm"><a class="header" href="#fuelvm">FuelVM</a></h2>
<ul>
<li><a href="./fuel-vm/index.html"><strong>Overview</strong></a> - Describes the FuelVM at a high level, from its architecture to how it is initialized.</li>
<li><a href="./fuel-vm/instruction-set.html"><strong>Instruction Set</strong></a> - Defines the FuelVM instruction set.</li>
</ul>
<h2 id="network-specific"><a class="header" href="#network-specific">Network-Specific</a></h2>
<ul>
<li><a href="./networks/poa.html"><strong>Proof of Authority (PoA)</strong></a> - The Fuel Proof of Authority Network.</li>
</ul>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<ul>
<li><a href="./tests/sparse-merkle-tree-tests.html"><strong>Sparse Merkle Tree</strong></a> - A test suite for verifying correctness of SMT outputs.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-format"><a class="header" href="#transaction-format">Transaction Format</a></h1>
<p>The Fuel Transaction Format.</p>
<ul>
<li><a href="tx-format/./consensus_parameters.html">Consensus Parameters</a></li>
<li><a href="tx-format/./transaction.html">Transaction</a>
<ul>
<li><a href="tx-format/./transaction.html#transactionscript"><code>TransactionScript</code></a></li>
<li><a href="tx-format/./transaction.html#transactioncreate"><code>TransactionCreate</code></a></li>
<li><a href="tx-format/./transaction.html#transactionmint"><code>TransactionMint</code></a></li>
<li><a href="tx-format/./transaction.html#transactionupgrade"><code>TransactionUpgrade</code></a></li>
<li><a href="tx-format/./transaction.html#transactionupload"><code>TransactionUpload</code></a></li>
<li><a href="tx-format/./transaction.html#transactionblob"><code>TransactionBlob</code></a></li>
</ul>
</li>
<li><a href="tx-format/./input.html">Input</a>
<ul>
<li><a href="tx-format/./input.html#inputcoin"><code>InputCoin</code></a></li>
<li><a href="tx-format/./input.html#inputcontract"><code>InputContract</code></a></li>
<li><a href="tx-format/./input.html#inputmessage"><code>InputMessage</code></a></li>
</ul>
</li>
<li><a href="tx-format/./output.html">Output</a>
<ul>
<li><a href="tx-format/./output.html#outputcoin"><code>OutputCoin</code></a></li>
<li><a href="tx-format/./output.html#outputcontract"><code>OutputContract</code></a></li>
<li><a href="tx-format/./output.html#outputchange"><code>OutputChange</code></a></li>
<li><a href="tx-format/./output.html#outputvariable"><code>OutputVariable</code></a></li>
<li><a href="tx-format/./output.html#outputcontractcreated"><code>OutputContractCreated</code></a></li>
</ul>
</li>
<li><a href="tx-format/./witness.html"><code>Witness</code></a></li>
<li><a href="tx-format/./policy.html"><code>Policy</code></a></li>
<li><a href="tx-format/./tx-pointer.html"><code>TXPointer</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consensus-parameters"><a class="header" href="#consensus-parameters">Consensus Parameters</a></h1>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>GAS_PER_BYTE</code></td><td><code>uint64</code></td><td>Gas charged per byte of the transaction.</td></tr>
<tr><td><code>GAS_PRICE_FACTOR</code></td><td><code>uint64</code></td><td>Unit factor for gas price.</td></tr>
<tr><td><code>MAX_GAS_PER_TX</code></td><td><code>uint64</code></td><td>Maximum gas per transaction.</td></tr>
<tr><td><code>MAX_INPUTS</code></td><td><code>uint64</code></td><td>Maximum number of inputs.</td></tr>
<tr><td><code>MAX_OUTPUTS</code></td><td><code>uint64</code></td><td>Maximum number of outputs.</td></tr>
<tr><td><code>MAX_PREDICATE_LENGTH</code></td><td><code>uint64</code></td><td>Maximum length of predicate, in instructions.</td></tr>
<tr><td><code>MAX_GAS_PER_PREDICATE</code></td><td><code>uint64</code></td><td>Maximum gas per predicate.</td></tr>
<tr><td><code>MAX_PREDICATE_DATA_LENGTH</code></td><td><code>uint64</code></td><td>Maximum length of predicate data, in bytes.</td></tr>
<tr><td><code>MAX_SCRIPT_LENGTH</code></td><td><code>uint64</code></td><td>Maximum length of script, in instructions.</td></tr>
<tr><td><code>MAX_SCRIPT_DATA_LENGTH</code></td><td><code>uint64</code></td><td>Maximum length of script data, in bytes.</td></tr>
<tr><td><code>MAX_MESSAGE_DATA_LENGTH</code></td><td><code>uint64</code></td><td>Maximum length of message data, in bytes.</td></tr>
<tr><td><code>MAX_STORAGE_SLOTS</code></td><td><code>uint64</code></td><td>Maximum number of initial storage slots.</td></tr>
<tr><td><code>MAX_TRANSACTION_SIZE</code></td><td><code>uint64</code></td><td>Maximum size of a transaction, in bytes.</td></tr>
<tr><td><code>MAX_WITNESSES</code></td><td><code>uint64</code></td><td>Maximum number of witnesses.</td></tr>
<tr><td><code>MAX_BYTECODE_SUBSECTIONS</code></td><td><code>uint64</code></td><td>Maximum number of bytecode subsections.</td></tr>
<tr><td><code>CHAIN_ID</code></td><td><code>uint64</code></td><td>A unique per-chain identifier.</td></tr>
<tr><td><code>BASE_ASSET_ID</code></td><td><code>bytes32</code></td><td>The base asset of the chain.</td></tr>
<tr><td><code>PRIVILEGED_ADDRESS</code></td><td><code>bytes32</code></td><td>The privileged address of the network who can perform upgrade.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="transaction"><a class="header" href="#transaction">Transaction</a></h1>
<pre><code class="language-c++">enum TransactionType : uint8 {
    Script = 0,
    Create = 1,
    Mint = 2,
    Upgrade = 3,
    Upload = 4,
    Blob = 5,
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><a href="tx-format/transaction.html#transaction"><code>TransactionType</code></a></td><td>Transaction type.</td></tr>
<tr><td><code>data</code></td><td>One of <a href="tx-format/transaction.html#transactionscript"><code>TransactionScript</code></a>, <a href="tx-format/transaction.html#transactioncreate"><code>TransactionCreate</code></a>, <a href="tx-format/transaction.html#transactionmint"><code>TransactionMint</code></a>, <a href="tx-format/transaction.html#transactionupgrade"><code>TransactionUpgrade</code></a>, or <a href="tx-format/transaction.html#transactionupload"><code>TransactionUpload</code></a></td><td>Transaction data.</td></tr>
</tbody></table>
</div>
<p>Given helper <code>max_gas()</code> returns the maximum gas that the transaction can use.
Given helper <code>count_ones()</code> that returns the number of ones in the binary representation of a field.
Given helper <code>count_variants()</code> that returns the number of variants in an enum.
Given helper <code>sum_variants()</code> that sums all variants of an enum.</p>
<p>Transaction is invalid if:</p>
<ul>
<li><code>type</code> is not valid <code>TransactionType</code> value</li>
<li><code>inputsCount &gt; MAX_INPUTS</code></li>
<li><code>outputsCount &gt; MAX_OUTPUTS</code></li>
<li><code>witnessesCount &gt; MAX_WITNESSES</code></li>
<li><code>size &gt; MAX_TRANSACTION_SIZE</code>. The size of a transaction is calculated as the sum of the sizes of its static and dynamic parts, as determined by canonical serialization.</li>
<li>No inputs are of type <code>InputType.Coin</code> or <code>InputType.Message</code> with <code>input.dataLength</code> == 0</li>
<li>More than one output is of type <code>OutputType.Change</code> for any asset ID in the input set</li>
<li>More than one output is of type <code>OutputType.Change</code> with identical <code>asset_id</code> fields.</li>
<li>Any output is of type <code>OutputType.Change</code> for any asset ID not in the input set</li>
<li>More than one input of type <code>InputType.Coin</code> for any <a href="tx-format/../identifiers/utxo-id.html#coin-id">Coin ID</a> in the input set</li>
<li>More than one input of type <code>InputType.Contract</code> for any <a href="tx-format/../identifiers/utxo-id.html#contract-id">Contract ID</a> in the input set</li>
<li>More than one input of type <code>InputType.Message</code> for any <a href="tx-format/../identifiers/utxo-id.html#message-id">Message ID</a> in the input set</li>
<li>if <code>type != TransactionType.Mint</code>
<ul>
<li><code>max_gas(tx) &gt; MAX_GAS_PER_TX</code></li>
<li>No policy of type <code>PolicyType.MaxFee</code> is set</li>
<li><code>count_ones(policyTypes) &gt; count_variants(PolicyType)</code></li>
<li><code>policyTypes &gt; sum_variants(PolicyType)</code></li>
<li><code>len(policies) &gt; count_ones(policyTypes)</code></li>
</ul>
</li>
</ul>
<p>When serializing a transaction, fields are serialized as follows (with inner structs serialized recursively):</p>
<ol>
<li><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>: big-endian right-aligned to 8 bytes.</li>
<li><code>byte[32]</code>: as-is.</li>
<li><code>byte[]</code>: as-is, with padding zeroes aligned to 8 bytes.</li>
</ol>
<p>When deserializing a transaction, the reverse is done. If there are insufficient bytes or too many bytes, the transaction is invalid.</p>
<h2 id="transactionscript"><a class="header" href="#transactionscript"><code>TransactionScript</code></a></h2>
<pre><code class="language-c++">enum ReceiptType : uint8 {
    Call = 0,
    Return = 1,
    ReturnData = 2,
    Panic = 3,
    Revert = 4,
    Log = 5,
    LogData = 6,
    Transfer = 7,
    TransferOut = 8,
    ScriptResult = 9,
    MessageOut = 10,
    Mint = 11,
    Burn = 12,
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>scriptGasLimit</code></td><td><code>uint64</code></td><td>Gas limits the script execution.</td></tr>
<tr><td><code>receiptsRoot</code></td><td><code>byte[32]</code></td><td>Merkle root of receipts.</td></tr>
<tr><td><code>scriptLength</code></td><td><code>uint64</code></td><td>Script length, in instructions.</td></tr>
<tr><td><code>scriptDataLength</code></td><td><code>uint64</code></td><td>Length of script input data, in bytes.</td></tr>
<tr><td><code>policyTypes</code></td><td><code>uint32</code></td><td>Bitfield of used policy types.</td></tr>
<tr><td><code>inputsCount</code></td><td><code>uint16</code></td><td>Number of inputs.</td></tr>
<tr><td><code>outputsCount</code></td><td><code>uint16</code></td><td>Number of outputs.</td></tr>
<tr><td><code>witnessesCount</code></td><td><code>uint16</code></td><td>Number of witnesses.</td></tr>
<tr><td><code>script</code></td><td><code>byte[]</code></td><td>Script to execute.</td></tr>
<tr><td><code>scriptData</code></td><td><code>byte[]</code></td><td>Script input data (parameters).</td></tr>
<tr><td><code>policies</code></td><td><a href="tx-format/./policy.html">Policy</a><code>[]</code></td><td>List of policies, sorted by <code>PolicyType</code>.</td></tr>
<tr><td><code>inputs</code></td><td><a href="tx-format/./input.html">Input</a><code>[]</code></td><td>List of inputs.</td></tr>
<tr><td><code>outputs</code></td><td><a href="tx-format/./output.html">Output</a><code>[]</code></td><td>List of outputs.</td></tr>
<tr><td><code>witnesses</code></td><td><a href="tx-format/./witness.html">Witness</a><code>[]</code></td><td>List of witnesses.</td></tr>
</tbody></table>
</div>
<p>Given helper <code>len()</code> that returns the number of bytes of a field.</p>
<p>Transaction is invalid if:</p>
<ul>
<li>Any output is of type <code>OutputType.ContractCreated</code></li>
<li><code>scriptLength &gt; MAX_SCRIPT_LENGTH</code></li>
<li><code>scriptDataLength &gt; MAX_SCRIPT_DATA_LENGTH</code></li>
<li><code>scriptLength * 4 != len(script)</code></li>
<li><code>scriptDataLength != len(scriptData)</code></li>
</ul>
<blockquote>
<p><strong>Note:</strong> when signing a transaction, <code>receiptsRoot</code> is set to zero.</p>
<p><strong>Note:</strong> when verifying a predicate or executing a script, <code>receiptsRoot</code> is initialized to zero.</p>
</blockquote>
<p>The receipts root <code>receiptsRoot</code> is the root of the <a href="tx-format/../protocol/cryptographic-primitives.html#binary-merkle-tree">binary Merkle tree</a> of receipts. If there are no receipts, its value is set to the root of the empty tree, i.e. <code>0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855</code>.</p>
<h2 id="transactioncreate"><a class="header" href="#transactioncreate"><code>TransactionCreate</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>bytecodeWitnessIndex</code></td><td><code>uint16</code></td><td>Witness index of contract bytecode to create.</td></tr>
<tr><td><code>salt</code></td><td><code>byte[32]</code></td><td>Salt.</td></tr>
<tr><td><code>storageSlotsCount</code></td><td><code>uint64</code></td><td>Number of storage slots to initialize.</td></tr>
<tr><td><code>policyTypes</code></td><td><code>uint32</code></td><td>Bitfield of used policy types.</td></tr>
<tr><td><code>inputsCount</code></td><td><code>uint16</code></td><td>Number of inputs.</td></tr>
<tr><td><code>outputsCount</code></td><td><code>uint16</code></td><td>Number of outputs.</td></tr>
<tr><td><code>witnessesCount</code></td><td><code>uint16</code></td><td>Number of witnesses.</td></tr>
<tr><td><code>storageSlots</code></td><td><code>(byte[32], byte[32]])[]</code></td><td>List of storage slots to initialize (key, value).</td></tr>
<tr><td><code>policies</code></td><td><a href="tx-format/./policy.html">Policy</a><code>[]</code></td><td>List of policies.</td></tr>
<tr><td><code>inputs</code></td><td><a href="tx-format/./input.html">Input</a><code>[]</code></td><td>List of inputs.</td></tr>
<tr><td><code>outputs</code></td><td><a href="tx-format/./output.html">Output</a><code>[]</code></td><td>List of outputs.</td></tr>
<tr><td><code>witnesses</code></td><td><a href="tx-format/./witness.html">Witness</a><code>[]</code></td><td>List of witnesses.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li>Any input is of type <code>InputType.Contract</code> or <code>InputType.Message</code> where <code>input.dataLength &gt; 0</code></li>
<li>Any input uses non-base asset.</li>
<li>Any output is of type <code>OutputType.Contract</code> or <code>OutputType.Variable</code> or <code>OutputType.Message</code></li>
<li>Any output is of type <code>OutputType.Change</code> with non-base <code>asset_id</code></li>
<li>It does not have exactly one output of type <code>OutputType.ContractCreated</code></li>
<li><code>tx.data.witnesses[bytecodeWitnessIndex].dataLength &gt; CONTRACT_MAX_SIZE</code></li>
<li><code>bytecodeWitnessIndex &gt;= tx.witnessesCount</code></li>
<li>The keys of <code>storageSlots</code> are not in ascending lexicographic order</li>
<li>The computed contract ID (see below) is not equal to the <code>contractID</code> of the one <code>OutputType.ContractCreated</code> output</li>
<li><code>storageSlotsCount &gt; MAX_STORAGE_SLOTS</code></li>
<li>The <a href="tx-format/../protocol/cryptographic-primitives.html#sparse-merkle-tree">Sparse Merkle tree</a> root of <code>storageSlots</code> is not equal to the <code>stateRoot</code> of the one <code>OutputType.ContractCreated</code> output</li>
</ul>
<p>Creates a contract with contract ID as computed <a href="tx-format/../identifiers/contract-id.html">here</a>.</p>
<h2 id="transactionmint"><a class="header" href="#transactionmint"><code>TransactionMint</code></a></h2>
<p>The transaction is created by the block producer and is not signed. Since it is not usable outside of block creation or execution, all fields must be fully set upon creation without any zeroing.
This means that the transaction ID must also include the correct <code>txPointer</code> value, not zeroed out.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>txPointer</code></td><td><a href="tx-format/./tx-pointer.html"><code>TXPointer</code></a></td><td>The location of the <code>Mint</code> transaction in the block.</td></tr>
<tr><td><code>inputContract</code></td><td><a href="tx-format/./input.html"><code>InputContract</code></a></td><td>The contract UTXO that assets are minted to.</td></tr>
<tr><td><code>outputContract</code></td><td><a href="tx-format/./output.html"><code>OutputContract</code></a></td><td>The contract UTXO that assets are being minted to.</td></tr>
<tr><td><code>mintAmount</code></td><td><code>uint64</code></td><td>The amount of funds minted.</td></tr>
<tr><td><code>mintAssetId</code></td><td><code>byte[32]</code></td><td>The asset IDs corresponding to the minted amount.</td></tr>
<tr><td><code>gasPrice</code></td><td><code>uint64</code></td><td>The gas price to be used in calculating all fees for transactions on block</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>txPointer</code> is zero or doesn't match the block.</li>
<li><code>outputContract.inputIndex</code> is not zero</li>
</ul>
<h2 id="transactionupgrade"><a class="header" href="#transactionupgrade"><code>TransactionUpgrade</code></a></h2>
<p>The <code>Upgrade</code> transaction allows upgrading either consensus parameters or state transition function used by the network to produce future blocks. The <code>Upgrade Purpose</code> type defines the purpose of the upgrade.</p>
<p>The <code>Upgrade</code> transaction is chargeable, and the sender should pay for it. Transaction inputs should contain only base assets.</p>
<p>Only the privileged address from <a href="tx-format/./consensus_parameters.html"><code>ConsensusParameters</code></a> can upgrade the network. The privileged address can be either a real account or a predicate.</p>
<p>When the upgrade type is <code>UpgradePurposeType.ConsensusParameters</code> serialized consensus parameters are available in the witnesses and the <code>Upgrade</code> transaction is self-contained because it has all the required information.</p>
<p>When the upgrade type is <code>UpgradePurposeType.StateTransition</code>, the <code>bytecodeRoot</code> field contains the Merkle root of the new bytecode of the state transition function. The bytecode should already be available on the blockchain at the upgrade point; otherwise, the upgrade will fail. The bytecode can be part of the genesis block or can be uploaded via the <code>TransactionUpload</code> transaction.</p>
<p>The block header contains information about which versions of consensus parameters and state transition function are used to produce a block, and the <code>Upgrade</code> transaction defines behavior corresponding to the version. When the block executes the <code>Upgrade</code> transaction, it defines new behavior for either <code>BlockHeader.consensusParametersVersion + 1</code> or <code>BlockHeader.stateTransitionBytecodeVersion + 1</code>(it depends on the purpose of the upgrade).</p>
<p>When the <code>Upgrade</code> transaction is included in the block, it doesn't affect the current block execution. Since behavior is now defined, the inclusion of the <code>Upgrade</code> transaction allows the production of the next block with a new version. The block producer can still continue to use the previous version and start using a new version later unless the state transition function forbids it.</p>
<p>The behavior is set once per version. It is forbidden to override the behavior of the network. Each behavior should have its own version. The version should grow monotonically without jumps.</p>
<p>The <code>BlockHeader.consensusParametersVersion</code> and <code>BlockHeader.stateTransitionBytecodeVersion</code> are independent and can grow at different speeds.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>upgradePurpose</code></td><td><a href="tx-format/./upgrade_purpose.html">UpgradePurpose</a></td><td>The purpose of the upgrade.</td></tr>
<tr><td><code>policyTypes</code></td><td><code>uint32</code></td><td>Bitfield of used policy types.</td></tr>
<tr><td><code>inputsCount</code></td><td><code>uint16</code></td><td>Number of inputs.</td></tr>
<tr><td><code>outputsCount</code></td><td><code>uint16</code></td><td>Number of outputs.</td></tr>
<tr><td><code>witnessesCount</code></td><td><code>uint16</code></td><td>Number of witnesses.</td></tr>
<tr><td><code>policies</code></td><td><a href="tx-format/./policy.html">Policy</a><code>[]</code></td><td>List of policies.</td></tr>
<tr><td><code>inputs</code></td><td><a href="tx-format/./input.html">Input</a><code>[]</code></td><td>List of inputs.</td></tr>
<tr><td><code>outputs</code></td><td><a href="tx-format/./output.html">Output</a><code>[]</code></td><td>List of outputs.</td></tr>
<tr><td><code>witnesses</code></td><td><a href="tx-format/./witness.html">Witness</a><code>[]</code></td><td>List of witnesses.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li>Any input is of type <code>InputType.Contract</code> or <code>InputType.Message</code> where <code>input.dataLength &gt; 0</code></li>
<li>Any input uses non-base asset.</li>
<li>Any output is of type <code>OutputType.Contract</code> or <code>OutputType.Variable</code> or <code>OutputType.Message</code> or <code>OutputType.ContractCreated</code></li>
<li>Any output is of type <code>OutputType.Change</code> with non-base <code>asset_id</code></li>
<li>No input where <code>InputType.Message.owner == PRIVILEGED_ADDRESS</code> or <code>InputType.Coint.owner == PRIVILEGED_ADDRESS</code></li>
<li>The <code>UpgradePurpose</code> is invalid</li>
</ul>
<h2 id="transactionupload"><a class="header" href="#transactionupload"><code>TransactionUpload</code></a></h2>
<p>The <code>Upload</code> transaction allows the huge bytecode to be divided into subsections and uploaded slowly to the chain. The <a href="tx-format/../protocol/cryptographic-primitives.html#binary-merkle-tree">Binary Merkle root</a> built on top of subsections is an identifier of the bytecode.</p>
<p>Each transaction uploads a subsection of the code and must contain proof of connection to the root. All subsections should be uploaded sequentially, which allows the concatenation of previously uploaded subsections with new subsection. The bytecode is considered final when the last subsection is uploaded, and future <code>Upload</code> transactions with the same <code>root</code> fields should be rejected.</p>
<p>When the bytecode is completed it can be used to upgrade the network.</p>
<p>The size of each subsection can be arbitrary; the only limit is the maximum number of subsections allowed by the network. The combination of the transaction gas limit and the number of subsections limits the final maximum size of the bytecode.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>root</code></td><td><code>byte[32]</code></td><td>The root of the Merkle tree is created over the bytecode.</td></tr>
<tr><td><code>witnessIndex</code></td><td><code>uint16</code></td><td>The witness index of the subsection of the bytecode.</td></tr>
<tr><td><code>subsectionIndex</code></td><td><code>uint16</code></td><td>The index of the subsection of the bytecode.</td></tr>
<tr><td><code>subsectionsNumber</code></td><td><code>uint16</code></td><td>The total number of subsections on which bytecode was divided.</td></tr>
<tr><td><code>proofSetCount</code></td><td><code>uint16</code></td><td>Number of Merkle nodes in the proof.</td></tr>
<tr><td><code>policyTypes</code></td><td><code>uint32</code></td><td>Bitfield of used policy types.</td></tr>
<tr><td><code>inputsCount</code></td><td><code>uint16</code></td><td>Number of inputs.</td></tr>
<tr><td><code>outputsCount</code></td><td><code>uint16</code></td><td>Number of outputs.</td></tr>
<tr><td><code>witnessesCount</code></td><td><code>uint16</code></td><td>Number of witnesses.</td></tr>
<tr><td><code>proofSet</code></td><td><code>byte[32][]</code></td><td>The proof set of Merkle nodes to verify the connection of the subsection to the <code>root</code>.</td></tr>
<tr><td><code>policies</code></td><td><a href="tx-format/./policy.html">Policy</a><code>[]</code></td><td>List of policies.</td></tr>
<tr><td><code>inputs</code></td><td><a href="tx-format/./input.html">Input</a><code>[]</code></td><td>List of inputs.</td></tr>
<tr><td><code>outputs</code></td><td><a href="tx-format/./output.html">Output</a><code>[]</code></td><td>List of outputs.</td></tr>
<tr><td><code>witnesses</code></td><td><a href="tx-format/./witness.html">Witness</a><code>[]</code></td><td>List of witnesses.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li>Any input is of type <code>InputType.Contract</code> or <code>InputType.Message</code> where <code>input.dataLength &gt; 0</code></li>
<li>Any input uses non-base asset.</li>
<li>Any output is of type <code>OutputType.Contract</code> or <code>OutputType.Variable</code> or <code>OutputType.Message</code> or <code>OutputType.ContractCreated</code></li>
<li>Any output is of type <code>OutputType.Change</code> with non-base <code>asset_id</code></li>
<li><code>witnessIndex &gt;= tx.witnessesCount</code></li>
<li><code>subsectionIndex</code> &gt;= <code>subsectionsNumber</code></li>
<li><code>subsectionsNumber &gt; MAX_BYTECODE_SUBSECTIONS</code></li>
<li>The <a href="tx-format/../protocol/cryptographic-primitives.html#binary-merkle-tree">Binary Merkle tree</a> root calculated from <code>(witnesses[witnessIndex], subsectionIndex, subsectionsNumber, proofSet)</code> is not equal to the <code>root</code>. Root calculation is affected by all fields, so modification of one of them invalidates the proof.</li>
</ul>
<h2 id="transactionblob"><a class="header" href="#transactionblob"><code>TransactionBlob</code></a></h2>
<p>The <code>Blob</code> inserts a simple binary blob in the chain. It's raw immutable data that can be cheaply loaded by the VM and used as instructions or just data. Unlike <code>Create</code>, it doesn't hold any state or balances.</p>
<p><code>Blob</code>s are content-addressed, i.e. the they are uniquely identified by hash of the data field. Programs running on the VM can load an already-posted blob just by the hash, without having to specify it in contract inputs.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>id</code></td><td><code>byte[32]</code></td><td>Blob id, i.e. hash of the data.</td></tr>
<tr><td><code>witnessIndex</code></td><td><code>uint16</code></td><td>The witness index of the data.</td></tr>
<tr><td><code>policyTypes</code></td><td><code>uint32</code></td><td>Bitfield of used policy types.</td></tr>
<tr><td><code>inputsCount</code></td><td><code>uint16</code></td><td>Number of inputs.</td></tr>
<tr><td><code>outputsCount</code></td><td><code>uint16</code></td><td>Number of outputs.</td></tr>
<tr><td><code>witnessesCount</code></td><td><code>uint16</code></td><td>Number of witnesses.</td></tr>
<tr><td><code>policies</code></td><td><a href="tx-format/./policy.html">Policy</a><code>[]</code></td><td>List of policies.</td></tr>
<tr><td><code>inputs</code></td><td><a href="tx-format/./input.html">Input</a><code>[]</code></td><td>List of inputs.</td></tr>
<tr><td><code>outputs</code></td><td><a href="tx-format/./output.html">Output</a><code>[]</code></td><td>List of outputs.</td></tr>
<tr><td><code>witnesses</code></td><td><a href="tx-format/./witness.html">Witness</a><code>[]</code></td><td>List of witnesses.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li>Any input is of type <code>InputType.Contract</code> or <code>InputType.Message</code> where <code>input.dataLength &gt; 0</code></li>
<li>Any input uses non-base asset.</li>
<li>Any output is of type <code>OutputType.Contract</code> or <code>OutputType.Variable</code> or <code>OutputType.Message</code> or <code>OutputType.ContractCreated</code></li>
<li>Any output is of type <code>OutputType.Change</code> with non-base <code>asset_id</code></li>
<li><code>witnessIndex &gt;= tx.witnessesCount</code></li>
<li><code>sha256(witnesses[witnessIndex]) != id</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgradepurposetype"><a class="header" href="#upgradepurposetype"><code>UpgradePurposeType</code></a></h1>
<pre><code class="language-c++">enum UpgradePurposeType : uint8 {
    ConsensusParameters = 0,
    StateTransition = 1,
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><a href="tx-format/upgrade_purpose.html#upgradepurposetype"><code>UpgradePurposeType</code></a></td><td>Type of upgrade purpose.</td></tr>
<tr><td><code>data</code></td><td>One of <a href="tx-format/upgrade_purpose.html#consensusparameters"><code>ConsensusParameters</code></a>, <a href="tx-format/upgrade_purpose.html#statetransition"><code>StateTransition</code></a></td><td>Upgrade purposes.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>type</code> is not valid <code>UpgradePurposeType</code> value`</li>
</ul>
<h2 id="consensusparameters"><a class="header" href="#consensusparameters"><code>ConsensusParameters</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>witnessIndex</code></td><td><code>uint16</code></td><td>Index of witness that contains a serialized(with <a href="https://docs.rs/postcard/latest/postcard/">postcard</a>) consensus parameters.</td></tr>
<tr><td><code>checksum</code></td><td><code>byte[32]</code></td><td>The hash of the serialized consensus parameters.</td></tr>
</tbody></table>
</div>
<p>Given helper <code>deserialize_consensus_parameters()</code> that deserializes the consensus parameters from a witness by using <a href="https://docs.rs/postcard/latest/postcard/">postcard</a> algorithm.</p>
<p>Transaction is invalid if:</p>
<ul>
<li><code>witnessIndex &gt;= tx.witnessesCount</code></li>
<li><code>checksum != sha256(tx.data.witnesses[witnessIndex])</code></li>
<li><code>deserialize_consensus_parameters(tx.data.witnesses[witnessIndex])</code> returns an error.</li>
</ul>
<h2 id="statetransition"><a class="header" href="#statetransition"><code>StateTransition</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>bytecodeRoot</code></td><td><code>byte[32]</code></td><td>The root of the new bytecode of the state transition function.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="policy"><a class="header" href="#policy">Policy</a></h1>
<pre><code class="language-c++">// index using powers of 2 for efficient bitmasking
enum PolicyType : uint32 {
    Tip = 1,
    WitnessLimit = 2,
    Maturity = 4,
    MaxFee = 8,
    Expiration = 16,
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>data</code></td><td>One of <a href="tx-format/policy.html#tip"><code>Tip</code></a>, <a href="tx-format/policy.html#witnesslimit"><code>WitnessLimit</code></a>, <a href="tx-format/policy.html#maturity"><code>Maturity</code></a> or <a href="tx-format/policy.html#expiration"><code>Expiration</code></a></td><td>Policy data.</td></tr>
</tbody></table>
</div>
<h2 id="tip"><a class="header" href="#tip"><code>Tip</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>tip</code></td><td><code>uint64</code></td><td>Additional, optional fee in <code>BASE_ASSET</code> to incentivize block producer to include transaction</td></tr>
</tbody></table>
</div>
<h2 id="witnesslimit"><a class="header" href="#witnesslimit"><code>WitnessLimit</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>witnessLimit</code></td><td><code>uint64</code></td><td>The maximum amount of witness data allowed for the transaction</td></tr>
</tbody></table>
</div>
<p>Given helper <code>len()</code> that returns the number of bytes of a field.</p>
<p>Transaction is invalid if:</p>
<ul>
<li><code>len(tx.witnesses) &gt; witnessLimit</code></li>
</ul>
<h2 id="maturity"><a class="header" href="#maturity"><code>Maturity</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>maturity</code></td><td><code>uint32</code></td><td>Block until which the transaction cannot be included.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>blockheight() &lt; maturity</code></li>
</ul>
<h2 id="expiration"><a class="header" href="#expiration"><code>Expiration</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>expiration</code></td><td><code>uint32</code></td><td>Block after which the transaction cannot be included.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>blockheight() &gt; expiration</code></li>
</ul>
<h2 id="maxfee"><a class="header" href="#maxfee"><code>MaxFee</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>max_fee</code></td><td><code>uint64</code></td><td>Required policy to specify the maximum fee payable by this transaction using <code>BASE_ASSET</code>. This is used to check transactions before the actual <code>gas_price</code> is known.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>max_fee &gt; sum_inputs(tx, BASE_ASSET_ID) - sum_outputs(tx, BASE_ASSET_ID)</code></li>
<li><code>max_fee &lt; max_fee(tx, BASE_ASSET_ID, gas_price)</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input"><a class="header" href="#input">Input</a></h1>
<pre><code class="language-c++">enum InputType : uint8 {
    Coin = 0,
    Contract = 1,
    Message = 2,
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><a href="tx-format/input.html#input"><code>InputType</code></a></td><td>Type of input.</td></tr>
<tr><td><code>data</code></td><td>One of <a href="tx-format/input.html#inputcoin"><code>InputCoin</code></a>, <a href="tx-format/input.html#inputcontract"><code>InputContract</code></a>, or <a href="tx-format/input.html#inputmessage"><code>InputMessage</code></a></td><td>Input data.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>type &gt; InputType.Message</code></li>
</ul>
<h2 id="inputcoin"><a class="header" href="#inputcoin"><code>InputCoin</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>txID</code></td><td><code>byte[32]</code></td><td>Hash of transaction.</td></tr>
<tr><td><code>outputIndex</code></td><td><code>uint16</code></td><td>Index of transaction output.</td></tr>
<tr><td><code>owner</code></td><td><code>byte[32]</code></td><td>Owning address or predicate root.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of coins.</td></tr>
<tr><td><code>asset_id</code></td><td><code>byte[32]</code></td><td>Asset ID of the coins.</td></tr>
<tr><td><code>txPointer</code></td><td><a href="tx-format/./tx-pointer.html"><code>TXPointer</code></a></td><td>Points to the TX whose output is being spent.</td></tr>
<tr><td><code>witnessIndex</code></td><td><code>uint16</code></td><td>Index of witness that authorizes spending the coin.</td></tr>
<tr><td><code>predicateGasUsed</code></td><td><code>uint64</code></td><td>Gas used by predicate.</td></tr>
<tr><td><code>predicateLength</code></td><td><code>uint64</code></td><td>Length of predicate, in instructions.</td></tr>
<tr><td><code>predicateDataLength</code></td><td><code>uint64</code></td><td>Length of predicate input data, in bytes.</td></tr>
<tr><td><code>predicate</code></td><td><code>byte[]</code></td><td>Predicate bytecode.</td></tr>
<tr><td><code>predicateData</code></td><td><code>byte[]</code></td><td>Predicate input data (parameters).</td></tr>
</tbody></table>
</div>
<p>Given helper <code>len()</code> that returns the number of bytes of a field.</p>
<p>Transaction is invalid if:</p>
<ul>
<li><code>witnessIndex &gt;= tx.witnessesCount</code></li>
<li><code>predicateLength &gt; MAX_PREDICATE_LENGTH</code></li>
<li><code>predicateDataLength &gt; MAX_PREDICATE_DATA_LENGTH</code></li>
<li>If <code>predicateLength &gt; 0</code>; the computed predicate root (see below) is not equal <code>owner</code></li>
<li><code>predicateLength * 4 != len(predicate)</code></li>
<li><code>predicateDataLength != len(predicateData)</code></li>
<li><code>predicateGasUsed &gt; MAX_GAS_PER_PREDICATE</code></li>
</ul>
<blockquote>
<p><strong>Note:</strong> when signing a transaction, <code>txPointer</code> and <code>predicateGasUsed</code> are set to zero.</p>
<p><strong>Note:</strong> when verifying and estimating a predicate or executing a script, <code>txPointer</code> and <code>predicateGasUsed</code> are initialized to zero.</p>
</blockquote>
<p>The predicate root is computed <a href="tx-format/../identifiers/predicate-id.html">here</a>.</p>
<h2 id="inputcontract"><a class="header" href="#inputcontract"><code>InputContract</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>txID</code></td><td><code>byte[32]</code></td><td>Hash of transaction.</td></tr>
<tr><td><code>outputIndex</code></td><td><code>uint16</code></td><td>Index of transaction output.</td></tr>
<tr><td><code>balanceRoot</code></td><td><code>byte[32]</code></td><td>Root of amount of coins owned by contract before transaction execution.</td></tr>
<tr><td><code>stateRoot</code></td><td><code>byte[32]</code></td><td>State root of contract before transaction execution.</td></tr>
<tr><td><code>txPointer</code></td><td><a href="tx-format/./tx-pointer.html"><code>TXPointer</code></a></td><td>Points to the TX whose output is being spent.</td></tr>
<tr><td><code>contractID</code></td><td><code>byte[32]</code></td><td>Contract ID.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li>there is not exactly one output of type <code>OutputType.Contract</code> with <code>inputIndex</code> equal to this input's index</li>
</ul>
<blockquote>
<p><strong>Note:</strong> when signing a transaction, <code>txID</code>, <code>outputIndex</code>, <code>balanceRoot</code>, <code>stateRoot</code>, and <code>txPointer</code> are set to zero.</p>
<p><strong>Note:</strong> when verifying a predicate or executing a script, <code>txID</code>, <code>outputIndex</code>, <code>balanceRoot</code>, <code>stateRoot</code>, and <code>txPointer</code> are initialized to zero.</p>
</blockquote>
<h2 id="inputmessage"><a class="header" href="#inputmessage"><code>InputMessage</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>sender</code></td><td><code>byte[32]</code></td><td>The address of the message sender.</td></tr>
<tr><td><code>recipient</code></td><td><code>byte[32]</code></td><td>The address or predicate root of the message recipient.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of base asset coins sent with message.</td></tr>
<tr><td><code>nonce</code></td><td><code>byte[32]</code></td><td>The message nonce.</td></tr>
<tr><td><code>witnessIndex</code></td><td><code>uint16</code></td><td>Index of witness that authorizes spending the coin.</td></tr>
<tr><td><code>predicateGasUsed</code></td><td><code>uint64</code></td><td>Gas used by predicate execution.</td></tr>
<tr><td><code>dataLength</code></td><td><code>uint64</code></td><td>Length of message data, in bytes.</td></tr>
<tr><td><code>predicateLength</code></td><td><code>uint64</code></td><td>Length of predicate, in instructions.</td></tr>
<tr><td><code>predicateDataLength</code></td><td><code>uint64</code></td><td>Length of predicate input data, in bytes.</td></tr>
<tr><td><code>data</code></td><td><code>byte[]</code></td><td>The message data.</td></tr>
<tr><td><code>predicate</code></td><td><code>byte[]</code></td><td>Predicate bytecode.</td></tr>
<tr><td><code>predicateData</code></td><td><code>byte[]</code></td><td>Predicate input data (parameters).</td></tr>
</tbody></table>
</div>
<p>Given helper <code>len()</code> that returns the number of bytes of a field.</p>
<p>Transaction is invalid if:</p>
<ul>
<li><code>witnessIndex &gt;= tx.witnessesCount</code></li>
<li><code>dataLength &gt; MAX_MESSAGE_DATA_LENGTH</code></li>
<li><code>predicateLength &gt; MAX_PREDICATE_LENGTH</code></li>
<li><code>predicateDataLength &gt; MAX_PREDICATE_DATA_LENGTH</code></li>
<li>If <code>predicateLength &gt; 0</code>; the computed predicate root (see below) is not equal <code>recipient</code></li>
<li><code>dataLength != len(data)</code></li>
<li><code>predicateLength * 4 != len(predicate)</code></li>
<li><code>predicateDataLength != len(predicateData)</code></li>
<li><code>predicateGasUsed &gt; MAX_GAS_PER_PREDICATE</code></li>
</ul>
<p>The predicate root is computed <a href="tx-format/../identifiers/predicate-id.html">here</a>.</p>
<blockquote>
<p><strong>Note:</strong> <code>InputMessages</code> with data length greater than zero are not considered spent until they are included in a transaction of type <code>TransactionType.Script</code> with a <code>ScriptResult</code> receipt where <code>result</code> is equal to <code>0</code> indicating a successful script exit</p>
<p><strong>Note:</strong> when signing a transaction, <code>predicateGasUsed</code> is set to zero.</p>
<p><strong>Note:</strong> when verifying and estimating a predicate, <code>predicateGasUsed</code> is initialized to zero.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output"><a class="header" href="#output">Output</a></h1>
<pre><code class="language-c++">enum OutputType : uint8 {
    Coin = 0,
    Contract = 1,
    Change = 2,
    Variable = 3,
    ContractCreated = 4,
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><a href="tx-format/output.html#output"><code>OutputType</code></a></td><td>Type of output.</td></tr>
<tr><td><code>data</code></td><td>One of <a href="tx-format/output.html#outputcoin"><code>OutputCoin</code></a>, <a href="tx-format/output.html#outputcontract"><code>OutputContract</code></a>, <a href="tx-format/output.html#outputchange"><code>OutputChange</code></a>, <a href="tx-format/output.html#outputvariable"><code>OutputVariable</code></a>, or <a href="tx-format/output.html#outputcontractcreated"><code>OutputContractCreated</code></a>.</td><td>Output data.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>type &gt; OutputType.ContractCreated</code></li>
</ul>
<h2 id="outputcoin"><a class="header" href="#outputcoin"><code>OutputCoin</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>to</code></td><td><code>byte[32]</code></td><td>Receiving address or predicate root.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of coins to send.</td></tr>
<tr><td><code>asset_id</code></td><td><code>byte[32]</code></td><td>Asset ID of coins.</td></tr>
</tbody></table>
</div>
<h2 id="outputcontract"><a class="header" href="#outputcontract"><code>OutputContract</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>inputIndex</code></td><td><code>uint16</code></td><td>Index of input contract.</td></tr>
<tr><td><code>balanceRoot</code></td><td><code>byte[32]</code></td><td>Root of amount of coins owned by contract after transaction execution.</td></tr>
<tr><td><code>stateRoot</code></td><td><code>byte[32]</code></td><td>State root of contract after transaction execution.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li><code>inputIndex &gt;= tx.inputsCount</code></li>
<li><code>tx.inputs[inputIndex].type != InputType.Contract</code></li>
</ul>
<blockquote>
<p><strong>Note:</strong> when signing a transaction, <code>balanceRoot</code> and <code>stateRoot</code> are set to zero.</p>
<p><strong>Note:</strong> when verifying a predicate or executing a script, <code>balanceRoot</code> and <code>stateRoot</code> are initialized to zero.</p>
</blockquote>
<p>The balance root <code>balanceRoot</code> is the root of the <a href="tx-format/../protocol/cryptographic-primitives.html#sparse-merkle-tree">SMT</a> of balance leaves. Each balance is a <code>uint64</code>, keyed by asset ID (a <code>byte[32]</code>).</p>
<p>The state root <code>stateRoot</code> is the root of the <a href="tx-format/../protocol/cryptographic-primitives.html#sparse-merkle-tree">SMT</a> of storage slots. Each storage slot is a <code>byte[32]</code>, keyed by a <code>byte[32]</code>.</p>
<h2 id="outputchange"><a class="header" href="#outputchange"><code>OutputChange</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>to</code></td><td><code>byte[32]</code></td><td>Receiving address or predicate root.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of coins to send.</td></tr>
<tr><td><code>asset_id</code></td><td><code>byte[32]</code></td><td>Asset ID of coins.</td></tr>
</tbody></table>
</div>
<p>Transaction is invalid if:</p>
<ul>
<li>any other output has type <code>OutputType.OutputChange</code> and asset ID <code>asset_id</code> (i.e. only one change output per asset ID is allowed)</li>
</ul>
<blockquote>
<p><strong>Note:</strong> when signing a transaction, <code>amount</code> is set to zero.</p>
<p><strong>Note:</strong> when verifying a predicate or executing a script, <code>amount</code> is initialized to zero.</p>
</blockquote>
<p>This output type indicates that the output's amount may vary based on transaction execution, but is otherwise identical to a <a href="tx-format/output.html#outputcoin">Coin</a> output. An <code>amount</code> of zero after transaction execution indicates that the output is unspendable and can be pruned from the UTXO set.</p>
<h2 id="outputvariable"><a class="header" href="#outputvariable"><code>OutputVariable</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>to</code></td><td><code>byte[32]</code></td><td>Receiving address or predicate root.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of coins to send.</td></tr>
<tr><td><code>asset_id</code></td><td><code>byte[32]</code></td><td>Asset ID of coins.</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note:</strong> when signing a transaction, <code>to</code>, <code>amount</code>, and <code>asset_id</code> are set to zero.</p>
<p><strong>Note:</strong> when verifying a predicate or executing a script, <code>to</code>, <code>amount</code>, and <code>asset_id</code> are initialized to zero.</p>
</blockquote>
<p>This output type indicates that the output's amount and owner may vary based on transaction execution, but is otherwise identical to a <a href="tx-format/output.html#outputcoin">Coin</a> output. An <code>amount</code> of zero after transaction execution indicates that the output is unspendable and can be pruned from the UTXO set.</p>
<h2 id="outputcontractcreated"><a class="header" href="#outputcontractcreated"><code>OutputContractCreated</code></a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>contractID</code></td><td><code>byte[32]</code></td><td>Contract ID.</td></tr>
<tr><td><code>stateRoot</code></td><td><code>byte[32]</code></td><td>Initial state root of contract.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="witness"><a class="header" href="#witness">Witness</a></h1>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>dataLength</code></td><td><code>uint64</code></td><td>Length of witness data, in bytes.</td></tr>
<tr><td><code>data</code></td><td><code>byte[]</code></td><td>Witness data.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="txpointer"><a class="header" href="#txpointer"><code>TXPointer</code></a></h1>
<p>The location of the transaction in the block. It can be used by UTXOs as a reference to the transaction or by the transaction itself to make it unique.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>blockHeight</code></td><td><code>uint32</code></td><td>Block height.</td></tr>
<tr><td><code>txIndex</code></td><td><code>uint16</code></td><td>Transaction index.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h1>
<p>This chapter defines how to compute unique identifiers.</p>
<ul>
<li><a href="identifiers/./asset.html">Asset ID</a></li>
<li><a href="identifiers/./blob-id.html">Blob ID</a></li>
<li><a href="identifiers/./contract-id.html">Contract ID</a></li>
<li><a href="identifiers/./predicate-id.html">Predicate ID</a></li>
<li><a href="identifiers/./transaction-id.html">Transaction ID</a></li>
<li><a href="identifiers/./utxo-id.html">UTXO ID</a>
<ul>
<li><a href="identifiers/./utxo-id.html#coin-id">Coin ID</a></li>
<li><a href="identifiers/./utxo-id.html#message-id">Message ID</a>
<ul>
<li><a href="identifiers/./utxo-id.html#message-nonce">Message Nonce</a></li>
</ul>
</li>
<li><a href="identifiers/./utxo-id.html#fee-id">Fee ID</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-id"><a class="header" href="#asset-id">Asset ID</a></h1>
<p>The <em>asset ID</em> (also called <em>asset hash</em>) of a asset is computed as
the <a href="identifiers/../protocol/cryptographic-primitives.html#hashing">hash</a> of the <code>CONTRACT_ID</code> and a 256-bit <code>SUB_IDENTIFIER</code>.</p>
<pre><code class="language-python">sha256(CONTRACT_ID ++ SUB_IDENTIFIER)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blob-id"><a class="header" href="#blob-id">Blob ID</a></h1>
<p>The <em>blob ID</em> (also called <em>blob hash</em>) of a transaction is computed as
the <a href="identifiers/../protocol/cryptographic-primitives.html#hashing">hash</a> of the blob data.</p>
<p>Blob ID calculation doesn't vary between chains.</p>
<pre><code class="language-python">sha256(blob_data)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-id"><a class="header" href="#contract-id">Contract ID</a></h1>
<p>For a transaction of type <code>TransactionType.Create</code>, <code>tx</code>, the contract ID is
<code>sha256(0x4655454C ++ tx.data.salt ++ root(tx.data.witnesses[bytecodeWitnessIndex].data) ++ root_smt(tx.storageSlots))</code>,
where <code>root</code> is the Merkle root of <a href="identifiers/../protocol/cryptographic-primitives.html#binary-merkle-tree">the binary Merkle tree</a> with
each leaf being 16KiB of instructions, and <code>root_smt</code> is the
<a href="identifiers/../protocol/cryptographic-primitives.html#sparse-merkle-tree">Sparse Merkle tree</a> root of the provided key-value pairs.
If the bytecode is not a multiple of 16 KiB, the final leaf should be zero-padded rounding up to the nearest multiple
of 8 bytes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicate-id"><a class="header" href="#predicate-id">Predicate ID</a></h1>
<p>For an input of type <code>InputType.Coin</code> or <code>InputType.Message</code>, <code>input</code>, the predicate owner is calculated as:
<code>sha256(0x4655454C ++ root(input.predicate))</code>, where <code>root</code> is the Merkle root of
<a href="identifiers/../protocol/cryptographic-primitives.html#binary-merkle-tree">the binary Merkle tree</a> each leaf being 16KiB of instructions.
If the bytecode is not a multiple of 16 KiB, the final leaf should be zero-padded rounding up to the nearest multiple of 8 bytes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-id"><a class="header" href="#transaction-id">Transaction ID</a></h1>
<p>The <em>transaction ID</em> (also called <em>transaction hash</em>) of a transaction is computed as
the <a href="identifiers/../protocol/cryptographic-primitives.html#hashing">hash</a> of <code>CHAIN_ID</code> and the
<a href="identifiers/../tx-format/transaction.html">serialized transaction</a> with <a href="identifiers/../tx-format/index.html">fields zeroed out for signing</a>
(see different inputs and outputs for which fields are set to zero), and without witness data. In other words, only
all non-witness data is hashed.</p>
<pre><code class="language-python">sha256(CHAIN_ID ++ serialized_tx(tx))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utxo-id"><a class="header" href="#utxo-id">UTXO ID</a></h1>
<h2 id="coin-id"><a class="header" href="#coin-id">Coin ID</a></h2>
<p>Is represented as an <em>outpoint</em>: a pair of <a href="identifiers/./transaction-id.html">transaction ID</a> as <code>byte[32]</code> and output index as a <code>uint16</code>.</p>
<h2 id="message-id"><a class="header" href="#message-id">Message ID</a></h2>
<p>The ID of a message is computed as the <a href="identifiers/../protocol/cryptographic-primitives.html#hashing">hash</a> of:</p>
<ol>
<li>the sender address as <code>byte[32]</code>,</li>
<li>the recipient address as <code>byte[32]</code>,</li>
<li>the <a href="identifiers/utxo-id.html#message-nonce">Message nonce</a> as <code>byte[32]</code>,</li>
<li>the amount being sent with the message as <code>uint64</code>,</li>
<li>the message data as <code>byte[]</code></li>
</ol>
<p><code>hash(byte[32] ++ byte[32] ++ byte[32] ++ uint64 ++ byte[])</code>. The address values are serialized as a byte array of length 32 left-padded with zeroes, and all other value types are serialized according to the standard <a href="identifiers/../tx-format/transaction.html">transaction serialization</a>. Note that the message data length is not included since there is only one dynamically sized field and can be implicitly determined by the hash preimage size.</p>
<h3 id="message-nonce"><a class="header" href="#message-nonce">Message Nonce</a></h3>
<p>The nonce value for <code>InputMessage</code> is determined by the sending system and is published at the time the message is sent. The nonce value for <code>OutputMessage</code> is computed as the <a href="identifiers/../protocol/cryptographic-primitives.html#hashing">hash</a> of the <a href="identifiers/./transaction-id.html">Transaction ID</a> that emitted the message and the index of the message receipt <code>uint16</code> (with canonical encoding): <code>hash(byte[32] ++ canonical(uint16))</code>.</p>
<h2 id="fee-id"><a class="header" href="#fee-id">Fee ID</a></h2>
<p>The UTXO ID of collected fees in a block is the block height as a 32-byte big-endian unsigned integer (i.e. the first byte of the 32-byte array is the most significant byte, and so on).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocol-1"><a class="header" href="#protocol-1">Protocol</a></h1>
<ul>
<li><a href="protocol/./tx-validity.html">Transaction Validity</a></li>
<li><a href="protocol/./cryptographic-primitives.html">Cryptographic Primitives</a></li>
<li><a href="protocol/./storage-initialization.html">Storage Slot Initialization</a></li>
<li><a href="protocol/./block-header.html">Block Header Format</a></li>
<li><a href="protocol/./relayer.html">Relayer/Bridge</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-validity"><a class="header" href="#transaction-validity">Transaction Validity</a></h1>
<ul>
<li><a href="protocol/tx-validity.html#transaction-life-cycle">Transaction Life Cycle</a></li>
<li><a href="protocol/tx-validity.html#access-lists">Access Lists</a></li>
<li><a href="protocol/tx-validity.html#vm-precondition-validity-rules">VM Precondition Validity Rules</a>
<ul>
<li><a href="protocol/tx-validity.html#base-sanity-checks">Base Sanity Checks</a></li>
<li><a href="protocol/tx-validity.html#spending-utxos-and-created-contracts">Spending UTXOs and Created Contracts</a></li>
<li><a href="protocol/tx-validity.html#sufficient-balance">Sufficient Balance</a></li>
<li><a href="protocol/tx-validity.html#valid-signatures">Valid Signatures</a></li>
</ul>
</li>
<li><a href="protocol/tx-validity.html#predicate-verification">Predicate Verification</a></li>
<li><a href="protocol/tx-validity.html#script-execution">Script Execution</a></li>
<li><a href="protocol/tx-validity.html#vm-postcondition-validity-rules">VM Postcondition Validity Rules</a>
<ul>
<li><a href="protocol/tx-validity.html#correct-change">Correct Change</a></li>
<li><a href="protocol/tx-validity.html#state-changes">State Changes</a></li>
</ul>
</li>
</ul>
<h2 id="transaction-life-cycle"><a class="header" href="#transaction-life-cycle">Transaction Life Cycle</a></h2>
<p>Once a transaction is seen, it goes through several stages of validation, in this order:</p>
<ol>
<li><a href="protocol/tx-validity.html#vm-precondition-validity-rules">Pre-checks</a></li>
<li><a href="protocol/tx-validity.html#predicate-verification">Predicate verification</a></li>
<li><a href="protocol/tx-validity.html#script-execution">Script execution</a></li>
<li><a href="protocol/tx-validity.html#vm-postcondition-validity-rules">Post-checks</a></li>
</ol>
<h2 id="access-lists"><a class="header" href="#access-lists">Access Lists</a></h2>
<p>The validity rules below assume sequential transaction validation for side effects (i.e. state changes). However, by construction, transactions with disjoint write access lists can be validated in parallel, including with overlapping read-only access lists. Transactions with overlapping write access lists must be validated and placed in blocks in topological order.</p>
<p>UTXOs and contracts in the read-only and write-destroy access lists must exist (i.e. have been created previously) in order for a transaction to be valid. In other words, for a unique state element ID, the write-create must precede the write-destroy.</p>
<p>Read-only access list:</p>
<p>Write-destroy access list:</p>
<ul>
<li>For each <a href="protocol/../tx-format/input.html#inputcoin">input <code>InputType.Coin</code></a>
<ul>
<li>The <a href="protocol/../identifiers/utxo-id.html">UTXO ID</a> <code>(txId, outputIndex)</code></li>
</ul>
</li>
<li>For each <a href="protocol/../tx-format/input.html#inputcontract">input <code>InputType.Contract</code></a>
<ul>
<li>The <a href="protocol/../identifiers/utxo-id.html">UTXO ID</a> <code>(txId, outputIndex)</code></li>
</ul>
</li>
<li>For each <a href="protocol/../tx-format/input.html#inputmessage">input <code>InputType.Message</code></a>
<ul>
<li>The <a href="protocol/../identifiers/utxo-id.html#message-id">message ID</a> <code>messageID</code></li>
</ul>
</li>
</ul>
<p>Write-create access list:</p>
<ul>
<li>For each <a href="protocol/../tx-format/output.html#outputcontractcreated">output <code>OutputType.ContractCreated</code></a>
<ul>
<li>The contract ID <code>contractID</code></li>
</ul>
</li>
<li>For each output
<ul>
<li>The <a href="protocol/../identifiers/utxo-id.html">created UTXO ID</a></li>
</ul>
</li>
</ul>
<p>Note that block proposers use the contract ID <code>contractID</code> for inputs and outputs of type <a href="protocol/../tx-format/input.html#inputcontract"><code>InputType.Contract</code></a> and <a href="protocol/../tx-format/output.html#outputcontract"><code>OutputType.Contract</code></a> rather than the pair of <code>txId</code> and <code>outputIndex</code>.</p>
<h2 id="vm-precondition-validity-rules"><a class="header" href="#vm-precondition-validity-rules">VM Precondition Validity Rules</a></h2>
<p>This section defines <em>VM precondition validity rules</em> for transactions: the bare minimum required to accept an unconfirmed transaction into a mempool, and preconditions that the VM assumes to hold prior to execution. Chains of unconfirmed transactions are omitted.</p>
<p>For a transaction <code>tx</code>, UTXO set <code>state</code>, contract set <code>contracts</code>, and message set <code>messages</code>, the following checks must pass.</p>
<blockquote>
<p><strong>Note:</strong> <a href="protocol/../tx-format/input.html#inputmessage"><code>InputMessages</code></a> where <code>input.dataLength &gt; 0</code> are not dropped from the <code>messages</code> message set until they are included in a transaction of type <code>TransactionType.Script</code> with a <code>ScriptResult</code> receipt where <code>result</code> is equal to <code>0</code> indicating a successful script exit.</p>
</blockquote>
<h3 id="base-sanity-checks"><a class="header" href="#base-sanity-checks">Base Sanity Checks</a></h3>
<p>Base sanity checks are defined in the <a href="protocol/../tx-format/index.html">transaction format</a>.</p>
<h3 id="spending-utxos-and-created-contracts"><a class="header" href="#spending-utxos-and-created-contracts">Spending UTXOs and Created Contracts</a></h3>
<pre><code class="language-py">for input in tx.inputs:
    if input.type == InputType.Contract:
        if not input.contractID in contracts:
                return False
    elif input.type == InputType.Message:
        if not input.nonce in messages:
                return False
    else:
        if not (input.txId, input.outputIndex) in state:
            return False
return True
</code></pre>
<p>If this check passes, the UTXO ID <code>(txId, outputIndex)</code> fields of each contract input is set to the UTXO ID of the respective contract. The <code>txPointer</code> of each input is also set to the TX pointer of the UTXO with ID <code>utxoID</code>.</p>
<h3 id="sufficient-balance"><a class="header" href="#sufficient-balance">Sufficient Balance</a></h3>
<p>For each asset ID <code>assetId</code> in the input and output set:</p>
<pre><code class="language-py">def gas_to_fee(gas, gasPrice) -&gt; int:
    &quot;&quot;&quot;
    Converts gas units into a fee amount
    &quot;&quot;&quot;
    return ceil(gas * gasPrice / GAS_PRICE_FACTOR)


def sum_data_messages(tx, assetId) -&gt; int:
    &quot;&quot;&quot;
    Returns the total balance available from messages containing data
    &quot;&quot;&quot;
    total: int = 0
    if assetId == 0:
        for input in tx.inputs:
            if input.type == InputType.Message and input.dataLength &gt; 0:
                total += input.amount
    return total


def sum_inputs(tx, assetId) -&gt; int:
    total: int = 0
    for input in tx.inputs:
        if input.type == InputType.Coin and input.assetId == assetId:
            total += input.amount
        elif input.type == InputType.Message and assetId == 0 and input.dataLength == 0:
            total += input.amount
    return total


def transaction_size_gas_fees(tx) -&gt; int:
    &quot;&quot;&quot;
    Computes the intrinsic gas cost of a transaction based on size in bytes
    &quot;&quot;&quot;
    return size(tx) * GAS_PER_BYTE


def minted(tx, assetId) -&gt; int:
    &quot;&quot;&quot;
    Returns any minted amounts by the transaction
    &quot;&quot;&quot;
    if tx.type != TransactionType.Mint or assetId != tx.mintAssetId:
        return 0
    return tx.mint_amount


def sum_outputs(tx, assetId) -&gt; int:
    total: int = 0
    for output in tx.outputs:
        if output.type == OutputType.Coin and output.assetId == assetId:
            total += output.amount
    return total


def input_gas_fees(tx) -&gt; int:
    &quot;&quot;&quot;
    Computes the intrinsic gas cost of verifying input utxos
    &quot;&quot;&quot;
    total: int = 0
    witnessIndices = set()
    for input in tx.inputs:
        if input.type == InputType.Coin or input.type == InputType.Message:
            # add fees allocated for predicate execution
            if input.predicateLength == 0:
                # notate witness index if input is signed
                witnessIndices.add(input.witnessIndex)
            else:
                # add intrinsic gas cost of predicate merkleization based on number of predicate bytes
                total += contract_code_root_gas_fee(input.predicateLength)
                total += input.predicateGasUsed
                # add intrinsic cost of vm initialization
                total += vm_initialization_gas_fee()
    # add intrinsic cost of verifying witness signatures
    total += len(witnessIndices) * eck1_recover_gas_fee()
    return total


def metadata_gas_fees(tx) -&gt; int:
    &quot;&quot;&quot;
    Computes the intrinsic gas cost of processing transaction outputs
    
    The `contract_code_root_gas_fee`, `sha256_gas_fee`, and `contract_state_root_gas_fee` 
    are based on the benchmarked gas costs of these operations.
    
    Consensus parameters contain definitions of gas costs for all operations and opcodes in the network.
    &quot;&quot;&quot;
    total: int = 0
    if tx.type == TransactionType.Create:
        for output in tx.outputs:
            if output.type == OutputType.OutputContractCreated:
                # add intrinsic cost of calculating the code root based on the size of the contract bytecode
                total += contract_code_root_gas_fee(tx.witnesses[tx.bytecodeWitnessIndex].dataLength)
                # add intrinsic cost of calculating the state root based on the number of sotrage slots
                total += contract_state_root_gas_fee(tx.storageSlotCount)
                # add intrinsic cost of calculating the contract id 
                # size = 4 byte seed + 32 byte salt + 32 byte code root + 32 byte state root
                total += sha256_gas_fee(100)
    elif tx.type == TransactionType.Upgrade:
        if tx.upgradePurpose.type == UpgradePurposeType.ConsensusParameters:
            # add intrinsic cost of calculating the consensus parameters hash
            total += sha256_gas_fee(size(tx.witnesses[tx.upgradePurpose.witnessIndex].data))
    elif tx.type == TransactionType.Upload:
        # add intrinsic cost of calculating the root based on the number of bytecode subsections
        total += contract_state_root_gas_fee(tx.subsectionsNumber)
        # add intrinsic cost of hashing the subsection for verification of the connection with Binary Merkle tree root
        total += sha256_gas_fee(size(tx.witnesses[tx.witnessIndex]))
            
    if tx.type != TransactionType.Mint:
        # add intrinsic cost of calculating the transaction id
        total += sha256_gas_fee(size(tx))
    return total


def intrinsic_gas_fees(tx) -&gt; int:
    &quot;&quot;&quot;
    Computes intrinsic costs for a transaction
    &quot;&quot;&quot;
    fees: int = 0
    # add the cost of initializing a vm for the script
    if tx.type == TransactionType.Create or tx.type == TransactionType.Script:
        fees += vm_initialization_gas_fee()
        fees += metadata_gas_fees(tx)
        fees += intrinsic_input_gas_fees(tx)
    return fees


def min_gas(tx) -&gt; int:
    &quot;&quot;&quot;
    Comutes the minimum amount of gas required for a transaction to begin processing.
    &quot;&quot;&quot;
    gas = transaction_size_gas_fees(tx) + intrinsic_gas_fees(tx)
    if tx.type == TransactionType.Upload
        # charge additionally for storing bytecode on chain
        gas += transaction_size_gas_fees(size(tx.witnesses[tx.witnessIndex]))
        
    return gas


def max_gas(tx) -&gt; int:
    &quot;&quot;&quot;
    Computes the amount of gas required to process a transaction.
    &quot;&quot;&quot;
    gas = min_gas(tx)
    gas = gas + (tx.witnessBytesLimit - tx.witnessBytes) * GAS_PER_BYTE
    if tx.type == TransactionType.Script:
       gas += tx.gasLimit
    return gas
    
    
def maxFee(tx, assetId, gasPrice) -&gt; int:
    &quot;&quot;&quot;
    Computes the maximum potential amount of fees that may need to be charged to process a transaction.
    &quot;&quot;&quot;
    maxGas = max_gas(tx)
    feeBalance = gas_to_fee(maxGas, gasPrice)
    # Only base asset can be used to pay for gas
    if assetId == 0:
        return feeBalance
    else:
        return 0


def available_balance(tx, assetId) -&gt; int:
    &quot;&quot;&quot;
    Make the data message balance available to the script
    &quot;&quot;&quot;
    availableBalance = sum_inputs(tx, assetId) + sum_data_messages(tx, assetId) + minted(tx, assetId)
    return availableBalance


def unavailable_balance(tx, assetId) -&gt; int:
    sentBalance = sum_outputs(tx, assetId)
    # Total fee balance
    feeBalance = tx.policies.max_fee
    # Only base asset can be used to pay for gas
    if assetId == 0:
        return sentBalance + feeBalance
    return sentBalance


# The sum_data_messages total is not included in the unavailable_balance since it is spendable as long as there 
# is enough base asset amount to cover gas costs without using data messages. Messages containing data can't
# cover gas costs since they are retryable.
return available_balance(tx, assetId) &gt;= (unavailable_balance(tx, assetId) + sum_data_messages(tx, assetId))
</code></pre>
<h3 id="valid-signatures"><a class="header" href="#valid-signatures">Valid Signatures</a></h3>
<pre><code class="language-py">def address_from(pubkey: bytes) -&gt; bytes:
    return sha256(pubkey)[0:32]

for input in tx.inputs:
    if (input.type == InputType.Coin or input.type == InputType.Message) and input.predicateLength == 0:
        # ECDSA signatures must be 64 bytes
        if tx.witnesses[input.witnessIndex].dataLength != 64:
            return False
        # Signature must be from owner
        if address_from(ecrecover_k1(txhash(), tx.witnesses[input.witnessIndex].data)) != input.owner:
            return False
return True
</code></pre>
<p>Signatures and signature verification are specified <a href="protocol/./cryptographic-primitives.html#public-key-cryptography">here</a>.</p>
<p>The transaction hash is computed as defined <a href="protocol/../identifiers/transaction-id.html">here</a>.</p>
<h2 id="predicate-verification"><a class="header" href="#predicate-verification">Predicate Verification</a></h2>
<p>For each input of type <code>InputType.Coin</code> or <code>InputType.Message</code>, and <code>predicateLength &gt; 0</code>, <a href="protocol/../fuel-vm/index.html#predicate-verification">verify its predicate</a>.</p>
<h2 id="script-execution"><a class="header" href="#script-execution">Script Execution</a></h2>
<p>Given transaction <code>tx</code>, the following checks must pass:</p>
<p>If <code>tx.scriptLength == 0</code>, there is no script and the transaction defines a simple balance transfer, so no further checks are required.</p>
<p>If <code>tx.scriptLength &gt; 0</code>, the script must be executed. For each asset ID <code>assetId</code> in the input set, the free balance available to be moved around by the script and called contracts is <code>freeBalance[assetId]</code>. The initial message balance available to be moved around by the script and called contracts is <code>messageBalance</code>:</p>
<pre><code class="language-py">freeBalance[assetId] = available_balance(tx, assetId) - unavailable_balance(tx, assetId)
messageBalance = sum_data_messages(tx, 0)
</code></pre>
<p>Once the free balances are computed, the <a href="protocol/../fuel-vm/index.html#script-execution">script is executed</a>. After execution, the following is extracted:</p>
<ol>
<li>The transaction in-memory on VM termination is used as the final transaction which is included in the block.</li>
<li>The unspent free balance <code>unspentBalance</code> for each asset ID.</li>
<li>The unspent gas <code>unspentGas</code> from the <code>$ggas</code> register.</li>
</ol>
<p><code>size(tx)</code> encompasses the entire transaction serialized according to the transaction format, including witness data.
This ensures every byte of block space either on Fuel or corresponding DA layer can be accounted for.</p>
<p>If the transaction as included in a block does not match this final transaction, the block is invalid.</p>
<h3 id="fees"><a class="header" href="#fees">Fees</a></h3>
<p>The cost of a transaction can be described by:</p>
<pre><code class="language-py">def cost(tx, gasPrice) -&gt; int:
    return gas_to_fee(min_gas(tx) + tx.gasLimit - unspentGas, gasPrice)
</code></pre>
<p>where:</p>
<ul>
<li><code>min_gas(tx)</code> is the minimum cost of the transaction in gas, including intrinsic gas fees incurred from:
<ul>
<li>The number of bytes comprising the transaction</li>
<li>Processing inputs, including predicates</li>
<li>Processing outputs</li>
<li>VM initialization</li>
</ul>
</li>
<li><code>unspentGas</code> is the amount gas left over after intrinsic fees and execution of the transaction, extracted from the <code>$ggas</code> register. Converting unspent gas to a fee describes how much &quot;change&quot; is left over from the user's payment; the block producer collects this unspent gas as reward.</li>
<li><code>gas_to_fee</code> is a function that converts gas to a concrete fee based on a given gas price.</li>
</ul>
<p>Fees incurred by transaction processing outside the context of execution are collectively referred to as intrinsic fees. Intrinsic fees include the cost of storing the transaction, calculated on a per-byte basis, the cost of processing inputs and outputs, including predicates and signature verification, and initialization of the VM prior to any predicate or script execution. Because intrinsic fees are independent of execution, they can be determined <em>a priori</em> and represent the bare minimum cost of the transaction.</p>
<p>A naturally occurring result of a variable gas limit is the concept of minimum and maximum fees. The minimum fee is, thus, the exact fee required to pay the fee balance, while the maximum fee is the minimum fee plus the gas limit:</p>
<pre><code class="language-py">min_gas = min_gas(tx)
max_gas = min_gas + (tx.witnessBytesLimit - tx.witnessBytes) * GAS_PER_BYTE + tx.gasLimit
min_fee = gas_to_fee(min_gas, gasPrice)
max_fee = gas_to_fee(max_gas, gasPrice)
</code></pre>
<p>The cost of the transaction <code>cost(tx)</code> must lie within the range defined by [<code>min_fee</code>, <code>max_fee</code>]. <code>min_gas</code> is defined as the sum of all intrinsic costs of the transaction known prior to execution. The definition of <code>max_gas</code> illustrates that the delta between minimum gas and maximum gas is the sum of:</p>
<ul>
<li>The remaining allocation of witness bytes, converted to gas</li>
<li>The user-defined <code>tx.gasLimit</code></li>
</ul>
<p>Note that <code>gasLimit</code> applies to transactions of type <code>Script</code>. <code>gasLimit</code> is not applicable for transactions of type <code>Create</code> and is defined to equal <code>0</code> in the above formula.</p>
<p>A transaction cost <code>cost(tx)</code>, in gas, greater than <code>max_gas</code> is invalid and must be rejected; this signifies that the user must provide a higher gas limit for the given transaction. <code>min_fee</code> is the minimum reward the producer is guaranteed to collect, and <code>max_fee</code> is the maximum reward the producer is potentially eligible to collect. In practice, the user is always charged intrinsic fees; thus, <code>unspentGas</code> is the remainder of <code>max_gas</code> after intrinsic fees and the variable cost of execution. Calculating a conversion from <code>unspentGas</code> to an unspent fee describes the reward the producer will collect in addition to <code>min_fee</code>.</p>
<h2 id="vm-postcondition-validity-rules"><a class="header" href="#vm-postcondition-validity-rules">VM Postcondition Validity Rules</a></h2>
<p>This section defines <em>VM postcondition validity rules</em> for transactions: the requirements for a transaction to be valid after it has been executed.</p>
<p>Given transaction <code>tx</code>, state <code>state</code>, and contract set <code>contracts</code>, the following checks must pass.</p>
<h3 id="correct-change"><a class="header" href="#correct-change">Correct Change</a></h3>
<p>If change outputs are present, they must have:</p>
<ul>
<li>if the transaction does not revert;
<ul>
<li>if the asset ID is <code>0</code>; an <code>amount</code> of <code>unspentBalance + floor((unspentGas * gasPrice) / GAS_PRICE_FACTOR)</code></li>
<li>otherwise; an <code>amount</code> of the unspent free balance for that asset ID after VM execution is complete</li>
</ul>
</li>
<li>if the transaction reverts;
<ul>
<li>if the asset ID is <code>0</code>; an <code>amount</code> of the initial free balance plus <code>(unspentGas * gasPrice) - messageBalance</code></li>
<li>otherwise; an <code>amount</code> of the initial free balance for that asset ID.</li>
</ul>
</li>
</ul>
<h3 id="state-changes"><a class="header" href="#state-changes">State Changes</a></h3>
<p>Transaction processing is completed by removing spent UTXOs from the state and adding created UTXOs to the state.</p>
<h3 id="coinbase-transaction"><a class="header" href="#coinbase-transaction">Coinbase Transaction</a></h3>
<p>The coinbase transaction is a mechanism for block creators to collect transaction fees.</p>
<p>In order for a coinbase transaction to be valid:</p>
<ol>
<li>It must be a <a href="protocol/../tx-format/transaction.html#TransactionMint">Mint</a> transaction.</li>
<li>The coinbase transaction must be the last transaction within a block, even if there are no other transactions in the block and the fee is zero.</li>
<li>The <code>mintAmount</code> doesn't exceed the total amount of fees processed from all other transactions within the same block.</li>
<li>The <code>mintAssetId</code> matches the <code>assetId</code> that fees are paid in (<code>assetId == 0</code>).</li>
</ol>
<p>The minted amount of the coinbase transaction intrinsically increases the balance corresponding to the <code>inputContract</code>.
This means the balance of <code>mintAssetId</code> is directly increased by <code>mintAmount</code> on the input contract,
without requiring any VM execution. Compared to coin outputs, intrinsically increasing a contract balance to collect
coinbase amounts prevents the accumulation of dust during low-usage periods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-primitives"><a class="header" href="#cryptographic-primitives">Cryptographic Primitives</a></h1>
<ul>
<li><a href="protocol/cryptographic-primitives.html#hashing">Hashing</a></li>
<li><a href="protocol/cryptographic-primitives.html#merkle-trees">Merkle Trees</a>
<ul>
<li><a href="protocol/cryptographic-primitives.html#binary-merkle-tree">Binary Merkle Tree</a></li>
<li><a href="protocol/cryptographic-primitives.html#sparse-merkle-tree">Sparse Merkle Tree</a></li>
</ul>
</li>
<li><a href="protocol/cryptographic-primitives.html#ecdsa-public-key-cryptography">EcDSA Public-Key Cryptography</a></li>
<li><a href="protocol/cryptographic-primitives.html#eddsa-public-key-cryptography">EdDSA Public-Key Cryptography</a></li>
</ul>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<p>All hashing is done with SHA-2-256 (also known as SHA-256), defined in <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">FIPS 180-4</a>.</p>
<h2 id="hashdigest"><a class="header" href="#hashdigest"><code>HashDigest</code></a></h2>
<p>Output of the <a href="protocol/cryptographic-primitives.html#hashing">hashing</a> function. Exactly 256 bits (32 bytes) long.</p>
<h2 id="merkle-trees"><a class="header" href="#merkle-trees">Merkle Trees</a></h2>
<p>Two Merkle tree structures are used: a Binary Merkle Tree (to commit to bytecode) and a Sparse Merkle Tree (to commit to contract storage, i.e. state).</p>
<h3 id="binary-merkle-tree"><a class="header" href="#binary-merkle-tree">Binary Merkle Tree</a></h3>
<p>Binary Merkle trees are constructed in the same fashion as described in <a href="https://tools.ietf.org/html/rfc6962">Certificate Transparency (RFC-6962)</a>, except for using <a href="protocol/cryptographic-primitives.html#hashing">a different hashing function</a>. Leaves are hashed once to get leaf node values and internal node values are the hash of the concatenation of their children (either leaf nodes or other internal nodes).</p>
<p>Nodes contain a single field:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>v</code></td><td><a href="protocol/cryptographic-primitives.html#hashdigest"><code>HashDigest</code></a></td><td>Node value.</td></tr>
</tbody></table>
</div>
<p>The base case (an empty tree) is defined as the <a href="protocol/cryptographic-primitives.html#hashing">hash</a> of the empty string:</p>
<pre><code class="language-C++">node.v = 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</code></pre>
<p>For leaf node <code>node</code> of leaf data <code>d</code>:</p>
<pre><code class="language-C++">node.v = h(0x00, serialize(d))
</code></pre>
<p>For internal node <code>node</code> with children <code>l</code> and <code>r</code>:</p>
<pre><code class="language-C++">node.v = h(0x01, l.v, r.v)
</code></pre>
<p>Note that rather than duplicating the last node if there are an odd number of nodes (the <a href="https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/consensus/merkle.cpp#L9-L43">Bitcoin design</a>), trees are allowed to be imbalanced. In other words, the height of each leaf may be different. For an example, see Section 2.1.3 of <a href="https://tools.ietf.org/html/rfc6962#section-2.1.3">Certificate Transparency (RFC-6962)</a>.</p>
<p>Leaves and internal nodes are hashed differently: the one-byte <code>0x00</code> is prepended for leaf nodes while <code>0x01</code> is prepended for internal nodes. This avoids a second-preimage attack <a href="https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack">where internal nodes are presented as leaves</a> trees with leaves at different heights.</p>
<h4 id="binary-merkle-tree-inclusion-proofs"><a class="header" href="#binary-merkle-tree-inclusion-proofs">Binary Merkle Tree Inclusion Proofs</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>root</code></td><td><a href="protocol/cryptographic-primitives.html#hashdigest"><code>HashDigest</code></a><code>[]</code></td><td>The expected root of the Merkle tree.</td></tr>
<tr><td><code>data</code></td><td>Bytes</td><td>The data of the leaf (unhashed).</td></tr>
<tr><td><code>siblings</code></td><td><a href="protocol/cryptographic-primitives.html#hashdigest"><code>HashDigest</code></a><code>[]</code></td><td>Sibling hash values, ordered starting from the leaf's neighbor.</td></tr>
</tbody></table>
</div>
<p>A proof for a leaf in a <a href="protocol/cryptographic-primitives.html#binary-merkle-tree">binary Merkle tree</a>, as per Section 2.1.1 of <a href="https://tools.ietf.org/html/rfc6962#section-2.1.1">Certificate Transparency (RFC-6962)</a>.</p>
<p>In some contexts, the array of sibling hashes is also known as the proof set. Note that proof format prescribes that leaf data be in its original, unhashed state, while the proof set (array of sibling data) uses hashed data. This format precludes the proof set from itself including the leaf data from the leaf undergoing the proof; rather, proof verification explicitly requires hashing the leaf data during the calculation of the proof set root.</p>
<h3 id="sparse-merkle-tree"><a class="header" href="#sparse-merkle-tree">Sparse Merkle Tree</a></h3>
<p>Sparse Merkle Trees (SMTs) are <em>sparse</em>, i.e. they contain mostly empty leaves. They can be used as key-value stores for arbitrary data, as each leaf is keyed by its index in the tree. Storage efficiency is achieved through clever use of implicit defaults, avoiding the need to store empty leaves.</p>
<p>Additional rules are added on top of plain <a href="protocol/cryptographic-primitives.html#binary-merkle-tree">binary Merkle trees</a>:</p>
<ol>
<li>Default values are given to leaf nodes with empty leaves.</li>
<li>While the above rule is sufficient to pre-compute the values of intermediate nodes that are roots of empty subtrees, a further simplification is to extend this default value to all nodes that are roots of empty subtrees. The 32-byte zero, i.e. <code>0x0000000000000000000000000000000000000000000000000000000000000000</code>, is used as the default value. This rule takes precedence over the above one.</li>
<li>The number of hashing operations can be reduced to be logarithmic in the number of non-empty leaves on average, assuming a uniform distribution of non-empty leaf keys. An internal node that is the root of a subtree that contains exactly one non-empty leaf is replaced by that leaf's leaf node.</li>
</ol>
<p>Nodes contain a single field:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>v</code></td><td><a href="protocol/cryptographic-primitives.html#hashdigest"><code>HashDigest</code></a></td><td>Node value.</td></tr>
</tbody></table>
</div>
<p>In the base case, where a sparse Merkle tree has <code>height = 0</code>, the root of a tree is defined as the <a href="protocol/cryptographic-primitives.html#hashing">hash</a> of the empty string:</p>
<pre><code class="language-C++">node.v = 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</code></pre>
<p>When a sparse Merkle tree has a height of 0, it can have no leaves, and, therefore, no default value children. The root is then calculated as the hash of the empty string, similar to that of an empty binary Merkle tree.</p>
<p>For a tree with <code>height &gt; 0</code>, the root of an empty tree is defined as the default value:</p>
<pre><code class="language-C++">node.v = 0x0000000000000000000000000000000000000000000000000000000000000000
</code></pre>
<p>Note that this is in contrast to the base case of the sparse and binary Merkle trees, where the root is the hash of the empty string. When a sparse Merkle tree has a height greater than 0, a new tree instance is composed of default value leaves. Nodes containing only default value children have the default value as well. Applying these rules recursively percolates the default value up to the tree's root.</p>
<p>For leaf node <code>node</code> of leaf data <code>d</code> with key <code>k</code>:</p>
<pre><code class="language-C++">node.v = h(0x00, k, h(serialize(d)))
</code></pre>
<p>The key of leaf nodes must be prepended, since the index of a leaf node that is not at maximum depth cannot be determined without this information. Leaf values are hashed so that they do not need to be included in full in non-membership proofs.</p>
<p>For internal node <code>node</code> with children <code>l</code> and <code>r</code>:</p>
<pre><code class="language-C++">node.v = h(0x01, l.v, r.v)
</code></pre>
<h4 id="insertion"><a class="header" href="#insertion">Insertion</a></h4>
<p>Before insertion of the key-value pair, each key of the Sparse Merkle Tree should be hashed with <code>sha256</code> to prevent tree structure manipulations.
During the proof verification, the original leaf key should be hashed similarly. Otherwise, the root will not match.</p>
<h4 id="sparse-merkle-tree-inclusion-proofs"><a class="header" href="#sparse-merkle-tree-inclusion-proofs">Sparse Merkle Tree Inclusion Proofs</a></h4>
<p>SMTs can further be extended with <em>compact</em> proofs. Merkle proofs are composed, among other things, of a list of sibling node values. We note that, since nodes that are roots of empty subtrees have known values (the default value), these values do not need to be provided explicitly; it is sufficient to simply identify which siblings in the Merkle branch are roots of empty subtrees, which can be done with one bit per sibling.</p>
<p>For a Merkle branch of height <code>h</code>, an <code>h</code>-bit value is appended to the proof. The lowest bit corresponds to the sibling of the leaf node, and each higher bit corresponds to the next parent. A value of <code>1</code> indicates that the next value in the list of values provided explicitly in the proof should be used, and a value of <code>0</code> indicates that the default value should be used.</p>
<p>A proof into an SMT is structured as:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>depth</code></td><td><code>uint16</code></td><td>Depth of the leaf node. The root node is at depth <code>0</code>. Must be <code>&lt;= 256</code>.</td></tr>
<tr><td><code>siblings</code></td><td><a href="protocol/cryptographic-primitives.html#hashdigest"><code>HashDigest</code></a><code>[]</code></td><td>Sibling hash values, ordered starting from the leaf's neighbor.</td></tr>
<tr><td><code>includedSiblings</code></td><td><code>byte[32]</code></td><td>Bitfield of explicitly included sibling hashes.</td></tr>
</tbody></table>
</div>
<p>The <code>includedSiblings</code> is ordered by most-significant-byte first, with each byte ordered by most-significant-bit first. The lowest bit corresponds to the leaf node level.</p>
<p>A specification describing a suite of test vectors and outputs of a Sparse Merkle Tree is <a href="protocol/../tests/sparse-merkle-tree-tests.html">here</a>.</p>
<h2 id="ecdsa-public-key-cryptography"><a class="header" href="#ecdsa-public-key-cryptography">ECDSA Public-Key Cryptography</a></h2>
<p>Consensus-critical data is authenticated using <a href="https://www.secg.org/sec1-v2.pdf">ECDSA</a>, with the curve <a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a>. A highly-optimized library is available in <a href="https://github.com/bitcoin-core/secp256k1">C</a>, with wrappers in <a href="https://pkg.go.dev/github.com/ethereum/go-ethereum/crypto/secp256k1">Go</a> and <a href="https://docs.rs/crate/secp256k1">Rust</a>.</p>
<p>Public keys are encoded in uncompressed form, as the concatenation of the <code>x</code> and <code>y</code> values. No prefix is needed to distinguish between encoding schemes as this is the only encoding supported.</p>
<p>Deterministic signatures (<a href="https://www.rfc-editor.org/rfc/rfc6979">RFC-6979</a>) should be used when signing, but this is not enforced at the protocol level as it cannot be.</p>
<p>Signatures are represented as the <code>r</code> and <code>s</code> (each 32 bytes), and <code>v</code> (1-bit) values of the signature. <code>r</code> and <code>s</code> take on their usual meaning (see: <a href="https://www.secg.org/sec1-v2.pdf">SEC 1, 4.1.3 Signing Operation</a>), while <code>v</code> is used for recovering the public key from a signature more quickly (see: <a href="https://www.secg.org/sec1-v2.pdf">SEC 1, 4.1.6 Public Key Recovery Operation</a>). Only low-<code>s</code> values in signatures are valid (i.e. <code>s &lt;= secp256k1.n//2</code>); <code>s</code> can be replaced with <code>-s mod secp256k1.n</code> during the signing process if it is high. Given this, the first bit of <code>s</code> will always be <code>0</code>, and can be used to store the 1-bit <code>v</code> value.</p>
<p><code>v</code> represents the parity of the <code>Y</code> component of the point, <code>0</code> for even and <code>1</code> for odd. The <code>X</code> component of the point is assumed to always be low, since <a href="https://bitcoin.stackexchange.com/a/38909">the possibility of it being high is negligible</a>.</p>
<p>Putting it all together, the encoding for signatures is:</p>
<!-- markdownlint-disable-next-line MD040 -->
<pre><code>|    32 bytes   ||           32 bytes           |
[256-bit r value][1-bit v value][255-bit s value]
</code></pre>
<p>This encoding scheme is derived from <a href="https://eips.ethereum.org/EIPS/eip-2098">EIP 2098: Compact Signature Representation</a>.</p>
<h2 id="eddsa-public-key-cryptography"><a class="header" href="#eddsa-public-key-cryptography">EdDSA Public-Key Cryptography</a></h2>
<p><a href="https://datatracker.ietf.org/doc/html/rfc8032">Ed25519</a> is supported for use by applications built on Fuel. Edwards curve operations are performed by the <a href="https://github.com/dalek-cryptography/ed25519-dalek">ed25519-dalek</a> Rust library.</p>
<p>Public keys are encoded in compressed form as specified by the Ed25519 format <a href="https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.5">RFC-8032 5.1.5</a>. Point compression is performed by replacing the most significant bit in the final octet of the <code>y</code> coordinate with the sign bit from the <code>x</code> coordinate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut pk = y;
pk ^= x.is_negative().unwrap_u8() &lt;&lt; 7;
<span class="boring">}
</span></code></pre></pre>
<p>Public keys are required to be strong enough to prevent malleability, and are checked for weakness during signature verification.</p>
<p>Signatures are 64 bytes, represented as the concatenation of <code>R</code> (32 bytes) and <code>S</code> (32 bytes) Where <code>R</code> and <code>S</code> are defined in <a href="https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.6">RFC-8032 5.1.6</a>.</p>
<p>Signatures must conform to strict <a href="https://github.com/dalek-cryptography/ed25519-dalek#validation-criteria">verification requirements</a> to avoid malleability concerns. While this is not part of the original Ed25519 specification, it has become a growing concern especially in cryptocurrency applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-format-for-contract-storage-initializers"><a class="header" href="#json-format-for-contract-storage-initializers">JSON Format for Contract Storage Initializers</a></h1>
<p>Contracts can request that certain storage slots are initialized to specific values. These initialized slots are represented in JSON format as an array where each element represents a storage slot and has the following properties:</p>
<ul>
<li><code>&quot;key&quot;</code>: String, a 32-byte key for a given storage slot;</li>
<li><code>&quot;value&quot;</code>: String, a 32-byte value that initializes the slot;</li>
</ul>
<p>For instance, the following is a JSON object that requests that the 3 storage slots with keys <code>0x11..11</code>, <code>0x22..22</code>, and <code>0x33..33</code>, are respectively initialized to the values indicated.</p>
<pre><code class="language-json">[
  {
    &quot;key&quot;: &quot;0x1111111111111111111111111111111111111111111111111111111111111111&quot;,
    &quot;value&quot;: &quot;0x1010101010101010101010101010101010101010101010101010101010101010&quot;
  }, 
  {
    &quot;key&quot;: &quot;0x2222222222222222222222222222222222222222222222222222222222222222&quot;,
    &quot;value&quot;: &quot;0x2020202020202020202020202020202020202020202020202020202020202020&quot;
  },
  {
    &quot;key&quot;: &quot;0x3333333333333333333333333333333333333333333333333333333333333333&quot;,
    &quot;value&quot;: &quot;0x0303030303030303030303030303030303030303030303030303030303030303&quot;
  },
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-header"><a class="header" href="#block-header">Block Header</a></h1>
<h2 id="application-header"><a class="header" href="#application-header">Application Header</a></h2>
<p>The application header is a network-agnostic block header. Different <a href="protocol/../networks/index.html">networks</a> may wrap the application header in a consensus header, depending on their consensus protocol.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>da_height</code></td><td><code>uint64</code></td><td>Height of the data availability layer up to which (inclusive) input messages are processed.</td></tr>
<tr><td><code>consensusParametersVersion</code></td><td><code>uint32</code></td><td>The version of the consensus parameters used to execute this block.</td></tr>
<tr><td><code>stateTransitionBytecodeVersion</code></td><td><code>uint32</code></td><td>The version of the state transition bytecode used to execute this block.</td></tr>
<tr><td><code>txCount</code></td><td><code>uint16</code></td><td>Number of <a href="protocol/../tx-format/transaction.html">transaction</a>s in this block.</td></tr>
<tr><td><code>message_receipt_count</code></td><td><code>uint32</code></td><td>Number of <a href="protocol/../abi/receipts.html#messageout-receipt">output message</a>s in this block.</td></tr>
<tr><td><code>txRoot</code></td><td><code>byte[32]</code></td><td><a href="protocol/./cryptographic-primitives.html#binary-merkle-tree">Merkle root</a> of <a href="protocol/../tx-format/transaction.html">transaction</a>s in this block.</td></tr>
<tr><td><code>message_outbox_root</code></td><td><code>byte[32]</code></td><td><a href="protocol/./cryptographic-primitives.html#binary-merkle-tree">Merkle root</a> of <a href="protocol/../abi/receipts.html#messageout-receipt">output message</a>s <a href="protocol/../identifiers/utxo-id.html#message-id"><code>messageId</code></a> in this block.</td></tr>
<tr><td><code>event_inbox_root</code></td><td><code>byte[32]</code></td><td><a href="protocol/./cryptographic-primitives.html#binary-merkle-tree">Merkle root</a> of all <a href="protocol/./relayer.html">events</a> imported from L1 in this block. The order of the events added to the Merkle tree is the L1 block order, and the index of each event within each block</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="layer-1-relayerbridge-protocol"><a class="header" href="#layer-1-relayerbridge-protocol">Layer 1 Relayer/Bridge Protocol</a></h1>
<p>The Fuel relayer/bridge protocol is a set of rules that govern the interaction between the Fuel blockchain and the
Layer 1 (L1) blockchain (e.g. Ethereum).</p>
<p>The Fuel blockchain can emit messages that will be processed by the smart contract on the L1 blockchain. The smart
contract on the L1 can also emit events that will be processed by the Fuel blockchain.
This is used to move any data between the L1 blockchain and the Fuel blockchain.</p>
<h2 id="fuel-message-outbox"><a class="header" href="#fuel-message-outbox">Fuel Message Outbox</a></h2>
<p>The message outbox is the set of messages sent to the L1 blockchain from the Fuel blockchain.</p>
<h2 id="fuel-event-inbox"><a class="header" href="#fuel-event-inbox">Fuel Event Inbox</a></h2>
<p>The event inbox is the set of events received from the L1 blockchain by the Fuel blockchain.</p>
<p>The block producer will receive a list of events from the L1 by some relayer, and then include the
merkle root of the events in the block header.</p>
<p>There are two types of events that can be received from the L1:</p>
<ol>
<li>Messages</li>
<li>Transactions</li>
</ol>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>An arbitrary message sent from the L1 to the Fuel blockchain. This can be used to move assets from the L1
to the Fuel blockchain or send other arbitrary information to the Fuel blockchain.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>sender</code></td><td><code>bytes[32]</code></td><td>The identity of the sender of the message on the L1</td></tr>
<tr><td><code>recipient</code></td><td><code>bytes[32]</code></td><td>The recipient of the message on the Fuel Blockchain</td></tr>
<tr><td><code>nonce</code></td><td><code>bytes[32]</code></td><td>Unique identifier of the message assigned by the L1 contract</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>The amount of the base asset transfer</td></tr>
<tr><td><code>data</code></td><td><code>byte[]</code></td><td>Arbitrary message data</td></tr>
</tbody></table>
</div>
<h3 id="transactions"><a class="header" href="#transactions">Transactions</a></h3>
<p>These are transactions that are submitted on the L1 that must be executed on the Fuel blockchain.
This &quot;Forced Transaction Inclusion&quot; is a security feature that allows participants of the Fuel Blockchain to access
their funds in the (unlikely) event that the Fuel blockchain block production is compromised or malicious, e.g. the
block producer is censoring transactions.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>nonce</code></td><td><code>bytes[32]</code></td><td>Unique identifier of the transaction assigned by the L1                                                                          contract</td></tr>
<tr><td><code>max_gas</code></td><td><code>uint64</code></td><td>The maximum amount of gas allowed to use on  Fuel Blockchain</td></tr>
<tr><td><code>serialized_transaction</code></td><td><code>byte[]</code></td><td>The serialized transaction bytes following canonical serialization</td></tr>
</tbody></table>
</div>
<p>The <code>serialized_transaction</code> can be any <a href="protocol/../tx-format/transaction.html">transaction variant</a> except the <code>Mint</code> transaction, which
is only ever created by the block producer. <code>Mint</code> transactions will be rejected by the Fuel blockchain if they are relayed
from the L1.</p>
<h3 id="ordering"><a class="header" href="#ordering">Ordering</a></h3>
<p>It is important that the L1 events are ordered correctly when they are relayed to the Fuel blockchain. The events will
be ordered by the L1 block height and then by the index of the event within the block.</p>
<p>The order is important because a merkle root will be generated each time events from L1 are included in a Fuel block.
This merkle root can later be used to prove that an arbitrary event was included on that block without having to store
every event on the block header explicitly. Just the merkle root will be on the <a href="protocol/./block-header.html">block header</a>.
The order of the events affects the value of the merkle root.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-binary-interface-abi"><a class="header" href="#application-binary-interface-abi">Application Binary Interface (ABI)</a></h1>
<p>This document describes and specifies the ABI (Application Binary Interface) of the FuelVM, the Sway programming language, and contracts written in Sway.</p>
<ul>
<li><a href="abi/./json-abi-format.html">JSON ABI Format</a></li>
<li><a href="abi/./receipts.html">Receipts</a></li>
<li><a href="abi/./fn-selector-encoding.html">Function Selector Encoding</a></li>
<li><a href="abi/./argument-encoding.html">Argument Encoding</a></li>
<li><a href="abi/./hash-based-ids.html">Hash Based Ids</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-abi-format"><a class="header" href="#json-abi-format">JSON ABI Format</a></h1>
<p>The JSON of an ABI is the human-readable representation of the interface of a Sway contract.</p>
<h2 id="spec-version"><a class="header" href="#spec-version">Spec Version</a></h2>
<p>Current <code>specVersion</code> is <code>1.0</code></p>
<p>The version above should be updated each time this spec changes and the JSON ABI generator should be updated with the new changes along with an increment in the spec version.</p>
<h2 id="notation"><a class="header" href="#notation">Notation</a></h2>
<p>Before describing the format of the JSON ABI, we provide some definitions that will make the JSON ABI spec easier to read.</p>
<p>Given the example below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { x: bool }
struct Bar&lt;T&gt; { y: T }

fn baz(input1: Foo, input2: Bar&lt;u64&gt;); // an ABI function
<span class="boring">}
</span></code></pre></pre>
<p>we define the following expressions:</p>
<ul>
<li><em>type concrete declaration</em>: the declaration or definition of a type which can be generic. <code>struct Foo { .. }</code> and <code>struct Bar&lt;T&gt; { .. }</code> in the example above are both type declarations. Note that generic types may have multiple <em>type concrete declaration</em>.</li>
<li><em>type metadata declaration</em>: the declaration or definition of a type which can be generic. <code>struct Foo { .. }</code> and <code>struct Bar&lt;T&gt; { .. }</code> in the example above are both type declarations. The metadata declaration contains component details about the type. And a single <em>type metadata declaration</em> is generated per type, even for generic types.</li>
<li><em>type application</em>: the application or use of a type. <code>Foo</code> and <code>Bar&lt;u64&gt;</code> in <code>fn baz(input1: Foo, input2: Bar&lt;u64&gt;);</code> in the example above are both applications of the type declarations <code>struct Foo { .. }</code> and <code>struct Bar&lt;T&gt; { .. }</code> respectively.</li>
<li><em>type parameter</em>: a generic parameter used in a type declaration. <code>T</code> in <code>struct Bar&lt;T&gt;</code> in the example above is a type parameter.</li>
<li><em>type argument</em>: an application of a type parameter used in a type application. <code>u64</code> in <code>input2: Bar&lt;u64&gt;</code> in the example above is a type argument.</li>
</ul>
<h2 id="json-abi-spec"><a class="header" href="#json-abi-spec">JSON ABI Spec</a></h2>
<p>The ABI of a contract is represented as a JSON object containing the following properties:</p>
<ul>
<li><code>&quot;specVersion&quot;</code>: a string representing the version pointing to this document versioning. <code>specVersion</code> enables the reader of the JSON ABI to find the correct specification for that file, this can be done by comparing it to value in <a href="abi/json-abi-format.html#spec-version">spec version</a>.</li>
<li><code>&quot;encodingVersion&quot;</code>: a string representing the version of the <code>ABIEncode</code> and <code>ABIDecode</code> used in this program.</li>
<li><code>&quot;programType&quot;</code>: a string that can be <code>&quot;script&quot;</code>, <code>&quot;contract&quot;</code>, <code>&quot;predicate&quot;</code>, <code>&quot;library&quot;</code>. This is used by the SDK to generate types without having to manually specify the program type.</li>
<li><code>&quot;concreteTypes&quot;</code>: an array describing all the <em>type concrete declarations</em> used (or transitively used) in the ABI. Each <em>type concrete declaration</em> is a JSON object that contains the following properties:
<ul>
<li><code>&quot;type&quot;</code>: a string representing the type, the <code>sha256</code> of this string generates the <code>concreteTypeId</code>.</li>
<li><code>&quot;concreteTypeId&quot;</code>: a unique string hash based ID. Generated as specified in <a href="abi/./hash-based-ids.html">Hash Based Ids</a>.</li>
<li><code>&quot;metadataTypeId&quot;</code>: the <em>type metadata declaration</em> ID of this type, if the type metadata has components or is generic, otherwise nonexistent.</li>
<li><code>&quot;typeArguments&quot;</code>: an array of <em>type concrete declarations</em> hash based IDs of the type parameters of the type, if the type is generic, otherwise nonexistent.</li>
</ul>
</li>
<li><code>&quot;metadataTypes&quot;</code>: an array describing all the <em>type metadata declarations</em> used (or transitively used) in the ABI. Each <em>type metadata declaration</em> is a JSON object that contains the following properties:
<ul>
<li><code>&quot;type&quot;</code>: a string representation of the <em>type metadata declaration</em>. The section <a href="abi/json-abi-format.html#json-abi-format-for-each-possible-metadata-type-declaration">JSON ABI Format for Each Possible Metadata Type Declaration</a> specifies the format for each possible type.</li>
<li><code>&quot;metadataTypeId&quot;</code>: a unique integer ID.</li>
<li><code>&quot;components&quot;</code>: an array of the components of a given type, if any, otherwise nonexistent. Each component is a <em>type application</em> represented as a JSON object that contains the following properties:
<ul>
<li><code>&quot;name&quot;</code>: the name of the component.</li>
<li><code>&quot;typeId&quot;</code>: the <em>type metadata declaration</em> ID (number) or <em>type concrete declaration</em> hash based ID (string) of the type of the component.</li>
<li><code>&quot;typeArguments&quot;</code>: an array of the <em>type arguments</em> used when applying the type of the component, if the type is generic, otherwise nonexistent. Each <em>type argument</em> is a <em>type application</em> represented as a JSON object that contains the following properties:
<ul>
<li><code>&quot;typeId&quot;</code>: the <em>type metadata declaration</em> ID (number) or <em>type concrete declaration</em> hash based ID (string) of the type of the component.</li>
<li><code>&quot;typeArguments&quot;</code>: an array of the <em>type arguments</em> used when applying the type of the <em>type argument</em>, if the type is generic, otherwise nonexistent. The format of the elements of this array recursively follows the rules described in this section.</li>
</ul>
</li>
</ul>
</li>
<li><code>&quot;typeParameters&quot;</code>: an array of <em>type metadata declaration</em> ID of the <em>type parameters</em> of the type, if the type is generic, otherwise nonexistent. Each <em>type parameter</em> is a type declaration and is represented as described in <a href="abi/json-abi-format.html#generic-type-parameter">Generic Type Parameter</a>.</li>
</ul>
</li>
<li><code>&quot;functions</code>&quot;: an array describing all the functions in the ABI. Each function is a JSON object that contains the following properties:
<ul>
<li><code>&quot;name&quot;</code>: the name of the function</li>
<li><code>&quot;inputs&quot;</code>: an array of objects that represents the inputs to the function (i.e. its parameters). Each input is a <em>type application</em> represented as a JSON object that contains the following properties:
<ul>
<li><code>&quot;name&quot;</code>: the name of the input.</li>
<li><code>&quot;concreteTypeId&quot;</code>: the <em>type concrete declaration</em> hash based ID of the type of the input.</li>
</ul>
</li>
<li><code>&quot;output&quot;</code>: the <em>type concrete declaration</em> hash based ID of the type being returned by the function.</li>
<li><code>&quot;attributes&quot;</code>: an optional array of <em>attributes</em>. Each <em>attribute</em> is explained in the <a href="abi/json-abi-format.html#attributes-semantics">dedicated section</a> and is represented as a JSON object that contains the following properties:
<ul>
<li><code>&quot;name&quot;</code>: the name of the attribute.</li>
<li><code>&quot;arguments&quot;</code>: an array of attribute arguments.</li>
</ul>
</li>
</ul>
</li>
<li><code>&quot;loggedTypes&quot;</code>: an array describing all instances of <a href="abi/../fuel-vm/instruction-set.html#log-log-event"><code>log</code></a> or <a href="abi/../fuel-vm/instruction-set.html#logd-log-data-event"><code>logd</code></a> in the contract's bytecode. Each instance is a JSON object that contains the following properties:
<ul>
<li><code>&quot;logId&quot;</code>: a string containing the 64bit hash based decimal ID calculated from the first 8 bytes of the <code>sha256</code> of a string that represents the type logged as defined in <a href="abi/./hash-based-ids.html">Hash Based Ids</a>. The <a href="abi/../fuel-vm/instruction-set.html#log-log-event"><code>log</code></a> and <a href="abi/../fuel-vm/instruction-set.html#logd-log-data-event"><code>logd</code></a> instructions must set their <code>$rB</code> register to that ID.</li>
<li><code>&quot;concreteTypeId&quot;</code>: the <em>type concrete declaration</em> hash based ID of the value being logged.</li>
</ul>
</li>
<li><code>&quot;messagesTypes&quot;</code>: an array describing all instances of <a href="abi/../fuel-vm/instruction-set.html#smo-send-message-to-output"><code>smo</code></a> in the contract's bytecode. Each instance is a JSON object that contains the following properties:
<ul>
<li><code>&quot;message_id&quot;</code>: a unique string ID.</li>
<li><code>&quot;concreteTypeId&quot;</code>: the <em>type concrete declaration</em> hash based ID of the message data being sent.</li>
</ul>
</li>
<li><code>&quot;configurables&quot;</code>: an array describing all <code>configurable</code> variables used in the contract. Each <code>configurable</code> variable is represented as a JSON object that contains the following properties:
<ul>
<li><code>&quot;name&quot;</code>: the name of the <code>configurable</code> variable.</li>
<li><code>&quot;concreteTypeId&quot;</code>: the <em>type concrete declaration</em> hash based ID of the type of the <code>configurable</code> variable.</li>
<li><code>&quot;offset&quot;</code>: the specific offset within the contract's bytecode, in bytes, to the data section entry for the <code>configurable</code> variable.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: This JSON should be both human-readable and parsable by the tooling around the FuelVM and the Sway programming language. There is a detailed specification for the binary encoding backing this readable descriptor. The <a href="abi/./fn-selector-encoding.html">Function Selector Encoding</a> section specifies the encoding for the function being selected to be executed and each of the argument types.</p>
</blockquote>
<h3 id="attributes-semantics"><a class="header" href="#attributes-semantics">Attributes Semantics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Attribute name</th><th>Attribute arguments</th><th>Semantics</th></tr></thead><tbody>
<tr><td><code>storage</code></td><td><code>read</code> and/or <code>write</code></td><td>Specifies if a function reads or writes to/from storage</td></tr>
<tr><td><code>payable</code></td><td>None</td><td>Specifies if a function can accept coins: a function without <code>payable</code> attribute must not accept coins</td></tr>
<tr><td><code>test</code></td><td>None</td><td>Specifies if a function is a unit test</td></tr>
<tr><td><code>inline</code></td><td><code>never</code> or <code>always</code>, but not both</td><td>Specifies if a function should be inlined during code generation</td></tr>
<tr><td><code>doc-comment</code></td><td>String</td><td>Documentation comment</td></tr>
<tr><td><code>doc</code></td><td>Not defined yet</td><td>Not defined yet</td></tr>
</tbody></table>
</div>
<h2 id="a-simple-example"><a class="header" href="#a-simple-example">A Simple Example</a></h2>
<p>Below is a simple example showing how the JSON ABI for an example that does not use generic or complex types. We will later go over more complex examples.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>abi MyContract {
    fn first_function(arg: u64) -&gt; bool;
    fn second_function(arg: b256);
}
<span class="boring">}
</span></code></pre></pre>
<p>the JSON representation of this ABI looks like:</p>
<pre><code class="language-json">{
  &quot;concreteTypes&quot;: [
    {
      &quot;type&quot;: &quot;u64&quot;,
      &quot;concreteTypeId&quot;: &quot;1506e6f44c1d6291cdf46395a8e573276a4fa79e8ace3fc891e092ef32d1b0a0&quot;
    },
    {
      &quot;type&quot;: &quot;b256&quot;,
      &quot;concreteTypeId&quot;: &quot;7c5ee1cecf5f8eacd1284feb5f0bf2bdea533a51e2f0c9aabe9236d335989f3b&quot;
    },
    {
      &quot;type&quot;: &quot;bool&quot;,
      &quot;concreteTypeId&quot;: &quot;b760f44fa5965c2474a3b471467a22c43185152129295af588b022ae50b50903&quot;
    },
    {
      &quot;type&quot;: &quot;()&quot;,
      &quot;concreteTypeId&quot;: &quot;2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d&quot;
    }
  ],
  &quot;metadataTypes&quot;: [],
  &quot;functions&quot;: [
    {
      &quot;inputs&quot;: [
        {
          &quot;name&quot;: &quot;arg&quot;,
          &quot;concreteTypeId&quot;: &quot;1506e6f44c1d6291cdf46395a8e573276a4fa79e8ace3fc891e092ef32d1b0a0&quot;
        }
      ],
      &quot;name&quot;: &quot;first_function&quot;,
      &quot;output&quot;: &quot;b760f44fa5965c2474a3b471467a22c43185152129295af588b022ae50b50903&quot;
    },
    {
      &quot;inputs&quot;: [
        {
          &quot;name&quot;: &quot;arg&quot;,
          &quot;concreteTypeId&quot;: &quot;7c5ee1cecf5f8eacd1284feb5f0bf2bdea533a51e2f0c9aabe9236d335989f3b&quot;
        }
      ],
      &quot;name&quot;: &quot;second_function&quot;,
      &quot;output&quot;: &quot;2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d&quot;
    }
  ],
  &quot;loggedTypes&quot;: []
}
</code></pre>
<h2 id="json-abi-format-for-each-possible-metadata-type-declaration"><a class="header" href="#json-abi-format-for-each-possible-metadata-type-declaration">JSON ABI Format for Each Possible Metadata Type Declaration</a></h2>
<p>Below is a list of the JSON ABI formats for each possible metadata type declaration:</p>
<h3 id="struct"><a class="header" href="#struct"><code>struct</code></a></h3>
<pre><code class="language-json">{
  &quot;metadataTypeId&quot;: &lt;id&gt;,
  &quot;type&quot;: &quot;struct &lt;struct_name&gt;&quot;,
  &quot;components&quot;: [
    {
      &quot;name&quot;: &quot;&lt;field1_name&gt;&quot;,
      &quot;typeId&quot;: &quot;&lt;field1_type_id&gt;&quot;,
      &quot;typeArguments&quot;: [
        {
          &quot;typeId&quot;: &quot;&lt;type_arg1_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        {
          &quot;typeId&quot;: &quot;&lt;type_arg2_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        ...
      ]
    },
    {
      &quot;name&quot;: &quot;&lt;field2_name&gt;&quot;,
      &quot;typeId&quot;: &quot;&lt;field2_type_id&gt;&quot;,
      &quot;typeArguments&quot;: [
        {
          &quot;typeId&quot;: &quot;&lt;type_arg1_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        {
          &quot;typeId&quot;: &quot;&lt;type_arg2_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        ...
      ]
    },
    ...
  ],
  &quot;typeParameters&quot;: [
    &lt;type_param1_type_id&gt;,
    &lt;type_param2_type_id&gt;,
    ...
  ]
}
</code></pre>
<h3 id="enum"><a class="header" href="#enum"><code>enum</code></a></h3>
<pre><code class="language-json">{
  &quot;metadataTypeId&quot;: &lt;id&gt;,
  &quot;type&quot;: &quot;enum &lt;enum_name&gt;&quot;,
  &quot;components&quot;: [
    {
      &quot;name&quot;: &quot;&lt;variant1_name&gt;&quot;,
      &quot;typeId&quot;: &quot;&lt;variant1_type_id&gt;&quot;,
      &quot;typeArguments&quot;: [
        {
          &quot;typeId&quot;: &quot;&lt;type_arg1_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        {
          &quot;typeId&quot;: &quot;&lt;type_arg2_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        ...
      ]
    },
    {
      &quot;name&quot;: &quot;&lt;variant2_name&gt;&quot;,
      &quot;typeId&quot;: &quot;&lt;variant2_type_id&gt;&quot;,
      &quot;typeArguments&quot;: [
        {
          &quot;typeId&quot;: &quot;&lt;type_arg1_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        {
          &quot;typeId&quot;: &quot;&lt;type_arg2_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        ...
      ]
    },
    ...
  ],
  &quot;typeParameters&quot;: [
    &lt;type_param1_type_id&gt;,
    &lt;type_param2_type_id&gt;,
    ...
  ]
}
</code></pre>
<h3 id="array"><a class="header" href="#array"><code>array</code></a></h3>
<pre><code class="language-json">{
  &quot;metadataTypeId&quot;: &lt;id&gt;,
  &quot;type&quot;: &quot;[_; &lt;n&gt;]&quot;,
  &quot;components&quot;: [
    {
      &quot;name&quot;: &quot;__array_element&quot;,
      &quot;typeId&quot;: &quot;&lt;element_type&gt;&quot;,
      &quot;typeArguments&quot;: ...
    }
    {
      &quot;name&quot;: &quot;__array_element&quot;,
      &quot;typeId&quot;: &quot;&lt;element_type_id&gt;&quot;,
      &quot;typeArguments&quot;: [
        {
          &quot;typeId&quot;: &quot;&lt;type_arg1_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        {
          &quot;typeId&quot;: &quot;&lt;type_arg2_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        ...
      ]
    },
  ]
}
</code></pre>
<ul>
<li><code>&lt;n&gt;</code> is the size of the array.</li>
</ul>
<h3 id="tuple"><a class="header" href="#tuple"><code>tuple</code></a></h3>
<pre><code class="language-json">{
  &quot;metadataTypeId&quot;: &lt;id&gt;,
  &quot;type&quot;: &quot;(_, _, ...)&quot;,
  &quot;components&quot;: [
    {
      &quot;name&quot;: &quot;__tuple_element&quot;,
      &quot;typeId&quot;: &quot;&lt;field1_type_id&gt;&quot;,
      &quot;typeArguments&quot;: [
        {
          &quot;typeId&quot;: &quot;&lt;type_arg1_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        {
          &quot;typeId&quot;: &quot;&lt;type_arg2_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        ...
      ]
    },
    {
      &quot;name&quot;: &quot;__tuple_element&quot;,
      &quot;typeId&quot;: &quot;&lt;field2_type_id&gt;&quot;,
      &quot;typeArguments&quot;: [
        {
          &quot;typeId&quot;: &quot;&lt;type_arg1_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        {
          &quot;typeId&quot;: &quot;&lt;type_arg2_type_id&gt;&quot;,
          &quot;typeArguments&quot;: ...
        },
        ...
      ]
    },
    ...
  ]
}
</code></pre>
<h3 id="generic-type-parameter"><a class="header" href="#generic-type-parameter">Generic Type Parameter</a></h3>
<pre><code class="language-json">{
  &quot;metadataTypeId&quot;: &lt;id&gt;,
  &quot;type&quot;: &quot;generic &lt;name&gt;&quot;
}
</code></pre>
<p><code>&lt;name&gt;</code> is the name of the generic parameter as specified in the struct or enum declaration that uses it.</p>
<h2 id="some-complex-examples"><a class="header" href="#some-complex-examples">Some Complex Examples</a></h2>
<h3 id="an-example-with-non-generic-custom-types"><a class="header" href="#an-example-with-non-generic-custom-types">An Example with Non-Generic Custom Types</a></h3>
<p>Given the following ABI declaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    Foo: u64,
    Bar: bool,
}

struct MyStruct {
    bim: u64,
    bam: MyEnum,
}

abi MyContract {
    /// this is a doc comment
    #[payable, storage(read, write)]
    fn complex_function(
        arg1: ([str[5]; 3], bool, b256),
        arg2: MyStruct,
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>its JSON representation would look like:</p>
<pre><code class="language-json">{
  &quot;concreteTypes&quot;: [
    {
      &quot;type&quot;: &quot;([str[5]; 3], bool, b256)&quot;,
      &quot;concreteTypeId&quot;: &quot;625531542be70834dd127e771101ac1014111718451bfae996d97abe700c66a5&quot;,
      &quot;metadataTypeId&quot;: 1,
    },
    {
      &quot;type&quot;: &quot;str[5]&quot;,
      &quot;concreteTypeId&quot;: &quot;84877f6e98274b9e4721db68b4c0bdb9e52b8e9572c5bd7811c07a41ced882c7&quot;,
    },
    {
      &quot;type&quot;: &quot;struct MyStruct&quot;,
      &quot;concreteTypeId&quot;: &quot;392d58c694d2d91f3025f2bccfadacf2a105936f5da881b0899185d49f264522&quot;,
      &quot;metadataTypeId&quot;: 4,
    },
    {
      &quot;type&quot;: &quot;u64&quot;,
      &quot;concreteTypeId&quot;: &quot;1506e6f44c1d6291cdf46395a8e573276a4fa79e8ace3fc891e092ef32d1b0a0&quot;
    },
    {
      &quot;type&quot;: &quot;b256&quot;,
      &quot;concreteTypeId&quot;: &quot;7c5ee1cecf5f8eacd1284feb5f0bf2bdea533a51e2f0c9aabe9236d335989f3b&quot;
    },
    {
      &quot;type&quot;: &quot;bool&quot;,
      &quot;concreteTypeId&quot;: &quot;b760f44fa5965c2474a3b471467a22c43185152129295af588b022ae50b50903&quot;
    },
    {
      &quot;type&quot;: &quot;()&quot;,
      &quot;concreteTypeId&quot;: &quot;2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d&quot;
    }
  ],
  &quot;metadataTypes&quot;: [
    {
      &quot;metadataTypeId&quot;: 1,
      &quot;type&quot;: &quot;(_, _, _)&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;__tuple_element&quot;,
          &quot;typeId&quot;: 2,
        },
        {
          &quot;name&quot;: &quot;__tuple_element&quot;,
          &quot;typeId&quot;: &quot;b760f44fa5965c2474a3b471467a22c43185152129295af588b022ae50b50903&quot;,
        },
        {
          &quot;name&quot;: &quot;__tuple_element&quot;,
          &quot;typeId&quot;: &quot;7c5ee1cecf5f8eacd1284feb5f0bf2bdea533a51e2f0c9aabe9236d335989f3b&quot;,
        }
      ]
    },
    {
      &quot;metadataTypeId&quot;: 2,
      &quot;type&quot;: &quot;[_; 3]&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;__array_element&quot;,
          &quot;typeId&quot;: &quot;84877f6e98274b9e4721db68b4c0bdb9e52b8e9572c5bd7811c07a41ced882c7&quot;,
        }
      ]
    },
    {
      &quot;metadataTypeId&quot;: 3,
      &quot;type&quot;: &quot;enum MyEnum&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;Foo&quot;,
          &quot;typeId&quot;: &quot;1506e6f44c1d6291cdf46395a8e573276a4fa79e8ace3fc891e092ef32d1b0a0&quot;,
        },
        {
          &quot;name&quot;: &quot;Bar&quot;,
          &quot;typeId&quot;: &quot;b760f44fa5965c2474a3b471467a22c43185152129295af588b022ae50b50903&quot;,
        }
      ]
    },
    {
      &quot;metadataTypeId&quot;: 4,
      &quot;type&quot;: &quot;struct MyStruct&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;bim&quot;,
          &quot;typeId&quot;: &quot;1506e6f44c1d6291cdf46395a8e573276a4fa79e8ace3fc891e092ef32d1b0a0&quot;,
        },
        {
          &quot;name&quot;: &quot;bam&quot;,
          &quot;typeId&quot;: 3,
        }
      ]
    },
  ],
  &quot;functions&quot;: [
    {
      &quot;inputs&quot;: [
        {
          &quot;name&quot;: &quot;arg1&quot;,
          &quot;concreteTypeId&quot;: &quot;625531542be70834dd127e771101ac1014111718451bfae996d97abe700c66a5&quot;,
        },
        {
          &quot;name&quot;: &quot;arg2&quot;,
          &quot;concreteTypeId&quot;: &quot;392d58c694d2d91f3025f2bccfadacf2a105936f5da881b0899185d49f264522&quot;
        }
      ],
      &quot;name&quot;: &quot;complex_function&quot;,
      &quot;output&quot;: &quot;2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d&quot;,
      &quot;attributes&quot;: [
        {
          &quot;name&quot;: &quot;doc-comment&quot;,
          &quot;arguments&quot;: [&quot; this is a doc comment&quot;]
        },
        {
          &quot;name&quot;: &quot;payable&quot;,
        },
        {
          &quot;name&quot;: &quot;storage&quot;,
          &quot;arguments&quot;: [&quot;read&quot;, &quot;write&quot;]
        }
      ]
    }
  ],
  &quot;loggedTypes&quot;: []
}
</code></pre>
<h3 id="an-example-with-generic-types"><a class="header" href="#an-example-with-generic-types">An Example with Generic Types</a></h3>
<p>Given the following ABI declaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum&lt;T, U&gt; {
    Foo: T,
    Bar: U,
}
struct MyStruct&lt;W&gt; {
    bam: MyEnum&lt;W, W&gt;,
}

abi MyContract {
    fn complex_function(
        arg1: MyStruct&lt;b256&gt;,
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>its JSON representation would look like:</p>
<pre><code class="language-json">{
  &quot;concreteTypes&quot;: [
    {
      &quot;type&quot;: &quot;struct MyStruct&lt;b256&gt;&quot;,
      &quot;concreteTypeId&quot;: &quot;3ddd5c1768dd7869663dc2f868ea8a8ce68bd6064244dbc4286e2c921c8ce962&quot;,
      &quot;metadataTypeId&quot;: 5,
      &quot;typeArguments&quot;: [
        &quot;7c5ee1cecf5f8eacd1284feb5f0bf2bdea533a51e2f0c9aabe9236d335989f3b&quot;
      ]
    },
    {
      &quot;type&quot;: &quot;b256&quot;,
      &quot;concreteTypeId&quot;: &quot;7c5ee1cecf5f8eacd1284feb5f0bf2bdea533a51e2f0c9aabe9236d335989f3b&quot;,
    },
    {
      &quot;type&quot;: &quot;()&quot;,
      &quot;concreteTypeId&quot;: &quot;2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d&quot;,
    }
  ],
  &quot;metadataTypes&quot;: [
    {
      &quot;metadataTypeId&quot;: 1,
      &quot;type&quot;: &quot;enum MyEnum&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;Foo&quot;,
          &quot;typeId&quot;: 2,
        },
        {
          &quot;name&quot;: &quot;Bar&quot;,
          &quot;typeId&quot;: 3,
        }
      ],
      &quot;typeParameters&quot;: [2, 3]
    },
    {
      &quot;metadataTypeId&quot;: 2,
      &quot;type&quot;: &quot;generic T&quot;,
    },
    {
      &quot;metadataTypeId&quot;: 3,
      &quot;type&quot;: &quot;generic U&quot;,
    },
    {
      &quot;metadataTypeId&quot;: 4,
      &quot;type&quot;: &quot;generic W&quot;,
    },
    {
      &quot;metadataTypeId&quot;: 5,
      &quot;type&quot;: &quot;struct MyStruct&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;bam&quot;,
          &quot;typeId&quot;: 1,
          &quot;typeArguments&quot;: [
            {
              &quot;typeId&quot;: 4,
            },
            {
              &quot;typeId&quot;: 4,
            }
          ]
        }
      ],
      &quot;typeParameters&quot;: [4]
    }
  ],
  &quot;functions&quot;: [
    {
      &quot;inputs&quot;: [
        {
          &quot;name&quot;: &quot;arg1&quot;,
          &quot;concreteTypeId&quot;: &quot;3ddd5c1768dd7869663dc2f868ea8a8ce68bd6064244dbc4286e2c921c8ce962&quot;
        }
      ],
      &quot;name&quot;: &quot;complex_function&quot;,
      &quot;output&quot;: &quot;2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d&quot;
    }
  ],
  &quot;loggedTypes&quot;: []
}
</code></pre>
<h3 id="an-example-with-logs"><a class="header" href="#an-example-with-logs">An Example with Logs</a></h3>
<p>Given the following contract:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStruct&lt;W&gt; {
    x: W,
}

abi MyContract {
    fn logging();
}

...

fn logging() {
    log(MyStruct { x: 42 });
    log(MyStruct { x: true });
}
<span class="boring">}
</span></code></pre></pre>
<p>its JSON representation would look like:</p>
<pre><code class="language-json">{
  &quot;concreteTypes&quot;: [
    {      
      &quot;type&quot;: &quot;struct MyStruct&lt;bool&gt;&quot;,
      &quot;concreteTypeId&quot;: &quot;eca2a040ce95fc19b7cd5f75bac530d052484d0b1a49267a2eb07a7a1b00c389&quot;,
      &quot;metadataTypeId&quot;: 1,
      &quot;typeArguments&quot;: [
        &quot;b760f44fa5965c2474a3b471467a22c43185152129295af588b022ae50b50903&quot;
      ]
    },
    {      
      &quot;type&quot;: &quot;struct MyStruct&lt;u64&gt;&quot;,
      &quot;concreteTypeId&quot;: &quot;b2fa346d9ca66ceca61951a27dba2977b2a82b8aa8600670604f286a1393dffe&quot;,
      &quot;metadataTypeId&quot;: 1,
      &quot;typeArguments&quot;: [
        &quot;1506e6f44c1d6291cdf46395a8e573276a4fa79e8ace3fc891e092ef32d1b0a0&quot;
      ]
    },
    {      
      &quot;type&quot;: &quot;bool&quot;,
      &quot;concreteTypeId&quot;: &quot;b760f44fa5965c2474a3b471467a22c43185152129295af588b022ae50b50903&quot;,
    },
    {      
      &quot;type&quot;: &quot;u64&quot;,
      &quot;concreteTypeId&quot;: &quot;1506e6f44c1d6291cdf46395a8e573276a4fa79e8ace3fc891e092ef32d1b0a0&quot;,
    },
    {
      &quot;type&quot;: &quot;()&quot;,
      &quot;concreteTypeId&quot;: &quot;2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d&quot;,
    }
  ],
  &quot;metadataTypes&quot;: [
    {
      &quot;metadataTypeId&quot;: 1,
      &quot;type&quot;: &quot;struct MyStruct&quot;,
      &quot;components&quot;: [
        {
          &quot;name&quot;: &quot;x&quot;,
          &quot;typeId&quot;: 2,
          &quot;typeArguments&quot;: null
        }
      ],
      &quot;typeParameters&quot;: [2]
    },
    {
      &quot;metadataTypeId&quot;: 2,
      &quot;type&quot;: &quot;generic W&quot;,
    },
  ],
  &quot;functions&quot;: [
    {
      &quot;inputs&quot;: [],
      &quot;name&quot;: &quot;logging&quot;,
      &quot;output&quot;: &quot;2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d&quot;
    }
  ],
  &quot;loggedTypes&quot;: [
    {
      &quot;logId&quot;: &quot;12896678128313068780&quot;,
      &quot;concreteTypeId&quot;: &quot;b2fa346d9ca66ceca61951a27dba2977b2a82b8aa8600670604f286a1393dffe&quot;
    },
    {
      &quot;logId&quot;: &quot;16383228984366451899&quot;,
      &quot;concreteTypeId&quot;: &quot;eca2a040ce95fc19b7cd5f75bac530d052484d0b1a49267a2eb07a7a1b00c389&quot;
    }
  ]
}
</code></pre>
<p>The <code>logIds</code> are calculated from:</p>
<ul>
<li>First 8 bytes of <code>sha256(&quot;struct MyStruct&lt;u64&gt;&quot;)</code> =&gt; &quot;12896678128313068780&quot;</li>
<li>First 8 bytes of <code>sha256(&quot;struct MyStruct&lt;bool&gt;&quot;)</code> =&gt; &quot;16383228984366451899&quot;</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="receipts"><a class="header" href="#receipts">Receipts</a></h1>
<p>Upon execution of ABI calls, i.e scripts being executed, a JSON object representing a list of receipts will be returned to the caller. Below is the JSON specification of the possible receipt types. The root will be <code>receipts_root</code> which will include an array of <code>receipts</code>.</p>
<pre><code class="language-json">{
  &quot;receipts_list&quot;:[
    {
      &quot;type&quot;:&quot;&lt;receipt_type&gt;&quot;,
      ...
    },
    ...
  ]
}
</code></pre>
<p>All receipts will have a <code>type</code> property:</p>
<ul>
<li><code>type</code>: String; the type of the receipt. Can be one of:
<ul>
<li><a href="abi/receipts.html#call-receipt"><code>Call</code></a></li>
<li><a href="abi/receipts.html#return-receipt"><code>Return</code></a></li>
<li><a href="abi/receipts.html#returndata-receipt"><code>ReturnData</code></a></li>
<li><a href="abi/receipts.html#panic-receipt"><code>Panic</code></a></li>
<li><a href="abi/receipts.html#revert-receipt"><code>Revert</code></a></li>
<li><a href="abi/receipts.html#log-receipt"><code>Log</code></a></li>
<li><a href="abi/receipts.html#mint-receipt"><code>Mint</code></a></li>
<li><a href="abi/receipts.html#burn-receipt"><code>Burn</code></a></li>
<li><a href="abi/receipts.html#logdata-receipt"><code>LogData</code></a></li>
<li><a href="abi/receipts.html#transfer-receipt"><code>Transfer</code></a></li>
<li><a href="abi/receipts.html#transferout-receipt"><code>TransferOut</code></a></li>
<li><a href="abi/receipts.html#scriptresult-receipt"><code>ScriptResult</code></a></li>
<li><a href="abi/receipts.html#messageout-receipt"><code>MessageOut</code></a></li>
</ul>
</li>
</ul>
<p>Then, each receipt type will have its own properties. Some of these properties are related to the FuelVM's registers, as specified in more detail <a href="abi/../fuel-vm/instruction-set.html">here</a>.</p>
<p><em>Important note:</em> For the JSON representation of receipts, we represent 64-bit unsigned integers as a JSON <code>String</code> due to limitations around the type <code>Number</code> in the JSON specification, which only supports numbers up to <code>2^{53-1}</code>, while the FuelVM's registers hold values up to <code>2^64</code>.</p>
<h2 id="panic-receipt"><a class="header" href="#panic-receipt">Panic Receipt</a></h2>
<ul>
<li><code>type</code>: <code>Panic</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context. <code>null</code> otherwise.</li>
<li><code>reason</code>: Optional decimal string representation of an 8-bit unsigned integer; panic reason.
Not included in canonical receipt form.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
<li><code>contractId</code>: Optional hexadecimal string representation of the 256-bit (32-byte) contract ID if applicable. <code>null</code> otherwise.
Not included in canonical receipt form. Primary use is for access-list estimation by SDK.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Panic&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;reason&quot;: &quot;1&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;,
  &quot;contractId&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;
}
</code></pre>
<h2 id="return-receipt"><a class="header" href="#return-receipt"><code>Return</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>Return</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context; <code>null</code> otherwise.</li>
<li><code>val</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rA</code>.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Return&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;val&quot;: &quot;18446744073709551613&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="call-receipt"><a class="header" href="#call-receipt"><code>Call</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>Call</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context; <code>null</code> otherwise.</li>
<li><code>to</code>: Hexadecimal representation of the 256-bit (32-byte) contract ID of the callee.</li>
<li><code>amount</code>: Decimal string representation of a 64-bit unsigned integer; amount of coins to forward.</li>
<li><code>asset_id</code>: Hexadecimal string representation of the 256-bit (32-byte) asset ID of coins to forward.</li>
<li><code>gas</code>: Decimal string representation of a 64-bit unsigned integer; amount gas to forward; value in register <code>$rD</code>.</li>
<li><code>param1</code>: Hexadecimal string representation of a 64-bit unsigned integer; first parameter, holds the function selector.</li>
<li><code>param2</code>: Hexadecimal string representation of a 64-bit unsigned integer; second parameter, typically used for the user-specified input to the ABI function being selected.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Call&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;to&quot;: &quot;0x1c98ff5d121a6d5afc8135821acb3983e460ef0590919266d620bfc7b9b6f24d&quot;,
  &quot;amount&quot;: &quot;10000&quot;,
  &quot;asset_id&quot;: &quot;0xa5149ac6064222922eaa226526b0d853e7871e28c368f6afbcfd60a6ef8d6e61&quot;,
  &quot;gas&quot;: &quot;500&quot;,
  &quot;param1&quot;: &quot;0x28f5c28f5c28f5c&quot;,
  &quot;param2&quot;: &quot;0x68db8bac710cb&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="log-receipt"><a class="header" href="#log-receipt"><code>Log</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>Log</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context. <code>null</code> otherwise.</li>
<li><code>ra</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rA</code>.</li>
<li><code>rb</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rB</code>.</li>
<li><code>rc</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rC</code>.</li>
<li><code>rd</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rD</code>.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Log&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;ra&quot;: &quot;1844674407370&quot;,
  &quot;rb&quot;: &quot;1844674407371&quot;,
  &quot;rc&quot;: &quot;1844674407372&quot;,
  &quot;rd&quot;: &quot;1844674407373&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="mint-receipt"><a class="header" href="#mint-receipt"><code>Mint</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>Mint</code>.</li>
<li><code>sub_id</code>: Hexadecimal string representation of the 256-bit (32-byte) asset sub identifier ID; derived from register <code>$rB</code>.</li>
<li><code>contract_id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context.</li>
<li><code>val</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rA</code>.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Mint&quot;,
  &quot;sub_id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;contract_id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;val&quot;: &quot;18446744073709551613&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="burn-receipt"><a class="header" href="#burn-receipt"><code>Burn</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>Burn</code>.</li>
<li><code>sub_id</code>: Hexadecimal string representation of the 256-bit (32-byte) asset sub identifier ID; derived from register <code>$rB</code>.</li>
<li><code>contract_id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context.</li>
<li><code>val</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rA</code>.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Burn&quot;,
  &quot;sub_id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;contract_id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;val&quot;: &quot;18446744073709551613&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="logdata-receipt"><a class="header" href="#logdata-receipt"><code>LogData</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>LogData</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context. <code>null</code> otherwise.</li>
<li><code>ra</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rA</code></li>
<li><code>rb</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rB</code></li>
<li><code>ptr</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$rC</code>.</li>
<li><code>len</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rD</code>.</li>
<li><code>digest</code>: Hexadecimal string representation of the 256-bit (32-byte) hash of <code>MEM[$rC, $rD]</code>.</li>
<li><code>data</code>: Hexadecimal string representation of the value of the memory range <code>MEM[$rC, $rD]</code>.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;LogData&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;ra&quot;: &quot;1844674407370&quot;,
  &quot;rb&quot;: &quot;1844674407371&quot;,
  &quot;ptr&quot;: &quot;0x1ad7f29abcc&quot;,
  &quot;len&quot;: &quot;66544&quot;,
  &quot;digest&quot;: &quot;0xd28b78894e493c98a196aa51b432b674e4813253257ed9331054ee8d6813b3aa&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;data&quot;: &quot;0xa7c5ac471b47&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="returndata-receipt"><a class="header" href="#returndata-receipt"><code>ReturnData</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>ReturnData</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context. <code>null</code> otherwise.</li>
<li><code>ptr</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$rA</code>.</li>
<li><code>len</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rB</code>.</li>
<li><code>digest</code>: Hexadecimal string representation of 256-bit (32-byte), hash of <code>MEM[$rA, $rB]</code>.</li>
<li><code>data</code>: Hexadecimal string representation of the value of the memory range <code>MEM[$rA, $rB]</code>.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;ReturnData&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;ptr&quot;: &quot;0x1ad7f29abcc&quot;,
  &quot;len&quot;: &quot;1844&quot;,
  &quot;digest&quot;: &quot;0xd28b78894e493c98a196aa51b432b674e4813253257ed9331054ee8d6813b3aa&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;data&quot;: &quot;0xa7c5ac471b47&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="revert-receipt"><a class="header" href="#revert-receipt"><code>Revert</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>Revert</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context. <code>null</code> otherwise.</li>
<li><code>val</code>: Decimal string representation of a 64-bit unsigned integer; value of register <code>$rA</code>.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Revert&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;val&quot;: &quot;1844674407372&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="transfer-receipt"><a class="header" href="#transfer-receipt"><code>Transfer</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>Transfer</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context. <code>null</code> otherwise.</li>
<li><code>to</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the recipient contract.</li>
<li><code>amount</code>: Decimal string representation of a 64-bit unsigned integer; amount of coins to forward.</li>
<li><code>asset_id</code>: Hexadecimal string representation of the 256-bit (32-byte) asset ID of coins to forward.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;Transfer&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;to&quot;: &quot;0x1c98ff5d121a6d5afc8135821acb3983e460ef0590919266d620bfc7b9b6f24d&quot;,
  &quot;amount&quot;: &quot;10000&quot;,
  &quot;asset_id&quot;: &quot;0xa5149ac6064222922eaa226526b0d853e7871e28c368f6afbcfd60a6ef8d6e61&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="transferout-receipt"><a class="header" href="#transferout-receipt"><code>TransferOut</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>TransferOut</code>.</li>
<li><code>id</code>: Hexadecimal string representation of the 256-bit (32-byte) contract ID of the current context if in an internal context. <code>null</code> otherwise.</li>
<li><code>to</code>: Hexadecimal string representation of the 256-bit (32-byte) <em>address</em> to transfer coins to.</li>
<li><code>amount</code>: Decimal string representation of a 64-bit unsigned integer; amount of coins to forward.</li>
<li><code>asset_id</code>: Hexadecimal string representation of the 256-bit (32-byte) asset ID of coins to forward.</li>
<li><code>pc</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$pc</code>.</li>
<li><code>is</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$is</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;TransferOut&quot;,
  &quot;id&quot;: &quot;0x39150017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;to&quot;: &quot;0x1c98ff5d121a6d5afc8135821acb3983e460ef0590919266d620bfc7b9b6f24d&quot;,
  &quot;amount&quot;: &quot;10000&quot;,
  &quot;asset_id&quot;: &quot;0xa5149ac6064222922eaa226526b0d853e7871e28c368f6afbcfd60a6ef8d6e61&quot;,
  &quot;pc&quot;: &quot;0xffffffffffffffff&quot;,
  &quot;is&quot;: &quot;0xfffffffffffffffe&quot;
}
</code></pre>
<h2 id="scriptresult-receipt"><a class="header" href="#scriptresult-receipt"><code>ScriptResult</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>ScriptResult</code>.</li>
<li><code>result</code>: Hexadecimal string representation of a 64-bit unsigned integer; <code>0</code> if script exited successfully, <code>any</code> otherwise.</li>
<li><code>gas_used</code>: Decimal string representation of a 64-bit unsigned integer; amount of gas consumed by the script.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;ScriptResult&quot;,
  &quot;result&quot;: &quot;0x00&quot;,
  &quot;gas_used&quot;: &quot;400&quot;
}
</code></pre>
<h2 id="messageout-receipt"><a class="header" href="#messageout-receipt"><code>MessageOut</code> Receipt</a></h2>
<ul>
<li><code>type</code>: <code>MessageOut</code>.</li>
<li><code>sender</code>: Hexadecimal string representation of the 256-bit (32-byte) address of the message sender: <code>MEM[$fp, 32]</code>.</li>
<li><code>recipient</code>: Hexadecimal string representation of the 256-bit (32-byte) address of the message recipient: <code>MEM[$rA, 32]</code>.</li>
<li><code>amount</code>: Hexadecimal string representation of a 64-bit unsigned integer; value of register <code>$rD</code>.</li>
<li><code>nonce</code>: Hexadecimal string representation of the 256-bit (32-byte) message nonce as described <a href="abi/../identifiers/utxo-id.html#message-nonce">here</a>.</li>
<li><code>len</code>: Decimal string representation of a 16-bit unsigned integer; value of register <code>$rC</code>.</li>
<li><code>digest</code>: Hexadecimal string representation of 256-bit (32-byte), hash of <code>MEM[$rB, $rC]</code>.</li>
<li><code>data</code>: Hexadecimal string representation of the value of the memory range <code>MEM[$rB, $rC]</code>.</li>
</ul>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;MessageOut&quot;,
  &quot;sender&quot;: &quot;0x38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff05139150017c9e&quot;,
  &quot;recipient&quot;: &quot;0x4710162c2e3a95a6faff05139150017c9e38e5e280432d546fae345d6ce6d8fe&quot;,
  &quot;amount&quot;: &quot;0xe6d8fe4710162c2e&quot;,
  &quot;nonce&quot;: &quot;0x47101017c9e38e5e280432d546fae345d6ce6d8fe4710162c2e3a95a6faff051&quot;,
  &quot;len&quot;: &quot;65535&quot;,
  &quot;digest&quot;: &quot;0xd28b78894e493c98a196aa51b432b674e4813253257ed9331054ee8d6813b3aa&quot;,
  &quot;data&quot;: &quot;0xa7c5ac471b47&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-selector-encoding"><a class="header" href="#function-selector-encoding">Function Selector Encoding</a></h1>
<p>To select which function you want to call, first, this function must be in an ABI struct of a Sway program. For instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>abi MyContract {
    fn foo(a: u64);
    fn bar(a: InputStruct );
} {
    fn baz(a: ()) { }
}
<span class="boring">}
</span></code></pre></pre>
<p>The function selector is the first 4 bytes of the SHA-256 hash function of the signature of the Sway function being called. Then, these 4 bytes are right-aligned to 8 bytes, left-padded with zeroes.</p>
<blockquote>
<p><strong>Note</strong>: The word size for the FuelVM is 8 bytes.</p>
</blockquote>
<h2 id="function-signature"><a class="header" href="#function-signature">Function Signature</a></h2>
<p>The signature is composed of the function name with the parenthesized list of comma-separated parameter types without spaces. All strings encoded with UTF-8. For custom types such as <code>enum</code> and <code>struct</code>, there is a prefix added to the parenthesized list (see below). Generic <code>struct</code> and <code>enum</code> types also accept a list of comma-separated type arguments in between angle brackets right after the prefix.</p>
<p>For instance, to compute the selector for the following function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn entry_one(arg: u64);
<span class="boring">}
</span></code></pre></pre>
<p>we should pass <code>&quot;entry_one(u64)&quot;</code> to the <code>sha256()</code> hashing algorithm. The full digest would be:</p>
<pre><code class="language-text">0x0c36cb9cb766ff60422db243c4fff06d342949da3c64a3c6ac564941f84b6f06
</code></pre>
<p>Then we would get only the first 4 bytes of this digest and left-pad it to 8 bytes:</p>
<pre><code class="language-text">0x000000000c36cb9c
</code></pre>
<p>The table below summarizes how each function argument type is encoded</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Encoding</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>u8</code></td><td><code>u8</code></td></tr>
<tr><td><code>u16</code></td><td><code>u16</code></td></tr>
<tr><td><code>u32</code></td><td><code>u32</code></td></tr>
<tr><td><code>u64</code></td><td><code>u64</code></td></tr>
<tr><td><code>b256</code></td><td><code>b256</code></td></tr>
<tr><td><code>struct</code></td><td><code>s&lt;&lt;arg1&gt;,&lt;arg2&gt;,...&gt;(&lt;ty1&gt;,&lt;ty2&gt;,...)</code> where <code>&lt;ty1&gt;</code>, <code>&lt;ty2&gt;</code>, ... are the encoded types of the struct fields and <code>&lt;arg1&gt;</code>, <code>&lt;arg2&gt;</code>, ... are the encoded type arguments</td></tr>
<tr><td><code>enum</code></td><td><code>e&lt;&lt;arg1&gt;&gt;,&lt;arg_2&gt;,...&gt;(&lt;ty1&gt;,&lt;ty2&gt;,...)</code> where <code>&lt;ty1&gt;</code>, <code>&lt;ty2&gt;</code>, ... are the encoded types of the enum variants and <code>&lt;arg1&gt;</code>, <code>&lt;arg2&gt;</code>, ... are the encoded type arguments</td></tr>
<tr><td><code>str[&lt;n&gt;]</code></td><td><code>str[&lt;n&gt;]</code></td></tr>
<tr><td><code>array</code></td><td><code>a[&lt;ty&gt;;&lt;n&gt;]</code> where <code>&lt;ty&gt;</code> is the encoded element type of the array and <code>&lt;n&gt;</code> is its length</td></tr>
<tr><td><code>tuple</code></td><td><code>(&lt;ty1&gt;,&lt;ty2&gt;,...)</code> where <code>&lt;ty1&gt;</code>, <code>&lt;ty2&gt;</code>, ... are the encoded types of the tuple fields</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note:</strong> Non-generic structs and enums do not require angle brackets.</p>
</blockquote>
<h2 id="a-complex-example"><a class="header" href="#a-complex-example">A Complex Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum&lt;V&gt; {
    Foo: u64,
    Bar: bool,
}
struct MyStruct&lt;T, U&gt; {
    bim: T,
    bam: MyEnum&lt;u64&gt;,
}

struct MyOtherStruct {
    bom: u64,
}

fn complex_function(
    arg1: MyStruct&lt;[b256; 3], u8&gt;,
    arg2: [MyStruct&lt;u64, bool&gt;; 4],
    arg3: (str[5], bool),
    arg4: MyOtherStruct,
);
<span class="boring">}
</span></code></pre></pre>
<p>is encoded as:</p>
<pre><code class="language-text">abi MyContract {
    complex_function(s&lt;a[b256;3],u8&gt;(a[b256;3],e&lt;u64&gt;(u64,bool)),a[s&lt;u64,bool&gt;(u64,e&lt;u64&gt;(u64,bool));4],(str[5],bool),s(u64))
}
</code></pre>
<p>which is then hashed into:</p>
<pre><code class="language-text">51fdfdadc37ff569e281a622281af7ec055f8098c40bc566118cbb48ca5fd28b
</code></pre>
<p>and then the encoded function selector is:</p>
<pre><code class="language-text">0x0000000051fdfdad
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="argument-encoding"><a class="header" href="#argument-encoding">Argument Encoding</a></h1>
<h2 id="version-0"><a class="header" href="#version-0">Version 0</a></h2>
<blockquote>
<p>:warning: This version is being deprecated for Version 1 (see below).</p>
</blockquote>
<p>When crafting transaction script data, you must encode the arguments you wish to pass to the script.</p>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>These are the available types that can be encoded in the ABI:</p>
<ul>
<li>Unsigned integers:
<ul>
<li><code>u8</code>, 8 bits.</li>
<li><code>u16</code>, 16 bits.</li>
<li><code>u32</code>, 32 bits.</li>
<li><code>u64</code>, 64 bits.</li>
<li><code>u128</code>, 128 bits.</li>
<li><code>u256</code>, 256 bits.</li>
</ul>
</li>
<li>Boolean: <code>bool</code>, either <code>0</code> or <code>1</code> encoded identically to <code>u8</code>.</li>
<li>B256: <code>b256</code>, arbitrary 256-bits value.</li>
<li>Address : <code>address</code>, a 256-bit (32-byte) address.</li>
<li>Fixed size string</li>
<li>Array</li>
<li>Enums (sum types)</li>
<li>Structs</li>
<li>Vectors</li>
<li>Tuples</li>
</ul>
<p>These types are encoded in-place. Here's how to encode them. We define <code>enc(X)</code> the encoding of the type <code>X</code>.</p>
<h3 id="unsigned-integers"><a class="header" href="#unsigned-integers">Unsigned Integers</a></h3>
<p><code>u&lt;M&gt;</code> where <code>M</code> is either 8, 16, 32, 64, 128 or 256 bits.</p>
<p><code>enc(X)</code> is the big-endian (i.e. right-aligned) representation of <code>X</code> left-padded with zero-bytes.</p>
<ul>
<li>In the case of <code>M</code> being 8, 16, 32 or 64, total length must be 8 bytes.</li>
<li>If <code>M</code> is 128, total length must be 16 bytes.</li>
<li>If <code>M</code> is 256, total length must be 32 bytes.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> since all integer values are unsigned, there is no need to preserve the sign when extending/padding; padding with only zeroes is sufficient._</p>
</blockquote>
<p><strong>Example:</strong></p>
<p>Encoding <code>42</code> yields: <code>0x000000000000002a</code>, which is the hexadecimal representation of the decimal number <code>42</code>, right-aligned to 8 bytes.
Encoding <code>u128::MAX - 1</code> yields: <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE</code>, it's right-aligned to 16 bytes</p>
<h3 id="boolean"><a class="header" href="#boolean"><code>Boolean</code></a></h3>
<p><code>enc(X)</code> is <code>0</code> if <code>X</code> is false or <code>1</code> if <code>X</code> is true, left-padded with zero-bytes. Total length must be 8 bytes. Similar to the <code>u8</code> encoding.</p>
<p><strong>Example:</strong></p>
<p>Encoding <code>true</code> yields:</p>
<pre><code class="language-text">0x0000000000000001
</code></pre>
<h3 id="b256"><a class="header" href="#b256"><code>B256</code></a></h3>
<p><code>b256</code> is a fixed size bit array of length 256. Used for 256-bit hash digests and other 256-bit types. It is encoded as-is.</p>
<p><strong>Example:</strong></p>
<p>Encoding <code>0xc7fd1d987ada439fc085cfa3c49416cf2b504ac50151e3c2335d60595cb90745</code> yields:</p>
<pre><code class="language-text">0xc7fd1d987ada439fc085cfa3c49416cf2b504ac50151e3c2335d60595cb90745
</code></pre>
<h3 id="address"><a class="header" href="#address"><code>Address</code></a></h3>
<p>A 256-bit (32-byte) address, encoded in the same way as a <code>b256</code> argument: encoded as-is.</p>
<p><strong>Example:</strong></p>
<p>Encoding <code>0xc7fd1d987ada439fc085cfa3c49416cf2b504ac50151e3c2335d60595cb90745</code> yields:</p>
<pre><code class="language-text">0xc7fd1d987ada439fc085cfa3c49416cf2b504ac50151e3c2335d60595cb90745
</code></pre>
<h3 id="array-1"><a class="header" href="#array-1">Array</a></h3>
<p>An array of a certain type <code>T</code>, <code>[T; n]</code>, where <code>n</code> is the length of the array.</p>
<p>Arrays in Sway have a fixed-length which is known at compile time. This means the ABI encoding for arrays also happens in-place, with no need to account for dynamic sizing.</p>
<p>The encoding for the array contains, in order, the encoding of each element in <code>[T; n]</code>, recursively following the encoding for the type <code>T</code>.</p>
<p>For instance, consider the function signature <code>my_func(bool, [u64; 2])</code> with the values <code>(true, [1, 2])</code>.</p>
<p>The encoding will be:</p>
<ol>
<li><code>0x0000000000000001</code>, the <code>true</code> bool encoded in-place.</li>
<li><code>0x0000000000000001</code>, First element of the parameter <code>[u64; 2]</code>, <code>1</code>, encoded as a <code>u64</code>.</li>
<li><code>0x0000000000000002</code>, Second element of the parameter <code>[u64; 2]</code>, <code>2</code>, encoded as a <code>u64</code>.</li>
</ol>
<p>The resulting encoded ABI will be:</p>
<pre><code class="language-text">0x000000000000000100000000000000010000000000000002
</code></pre>
<h3 id="fixed-length-strings"><a class="header" href="#fixed-length-strings">Fixed-length Strings</a></h3>
<p>Strings have fixed length and are encoded in-place. <code>str[n]</code>, where <code>n</code> is the fixed-size of the string. Rather than padding the string, the encoding of the elements of the string is tightly packed. And unlike the other type encodings, the string encoding is left-aligned.</p>
<p>Note that all strings are encoded in UTF-8.</p>
<p><strong>Example:</strong></p>
<p>Encoding <code>&quot;Hello, World&quot;</code> as a <code>str[12]</code> <strong>yields</strong>:</p>
<pre><code class="language-text">0x48656c6c6f2c20576f726c6400000000
</code></pre>
<p>Note that we're padding with zeroes in order to keep it right-aligned to 8 bytes (FuelVM's word size).</p>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>Encoding ABIs that contain custom types, such as structs, is similar to encoding a set of primitive types. The encoding will proceed in the order that the inner types of a custom type are declared and <em>recursively</em> just like encoding any other type. This way you can encode structs with primitive types or structs with more complex types in them such as other structs, arrays, strings, and enums.</p>
<p>Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InputStruct {
    field_1: bool,
    field_2: u8,
}


abi MyContract {
    fn foo(a: u64);
    fn bar(a: InputStruct);
} {
    fn baz(a: ()) { }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>bar</code> with <code>InputStruct { field_1: true, field_2: 5 }</code> yields:</p>
<pre><code class="language-plaintext">0x
0000000000000001 // `true` encoded as a bool
0000000000000005 // `5` encoded as u8
</code></pre>
<p>A more complex scenario:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InputStruct {
    field_1: bool,
    field_2: [u8; 2], // An array of u8, with length 2.
}


abi MyContract {
    fn foo(a: u64);
    fn bar(a: InputStruct);
} {
    fn baz(a: ()) { }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>bar</code> with <code>InputStruct { field_1: true, field_2: [1, 2] }</code> yields:</p>
<pre><code class="language-plaintext">0x
0000000000000001 // `true` encoded as a bool
0000000000000001 // `1` encoded as u8
0000000000000002 // `2` encoded as u8
</code></pre>
<h3 id="enums-sum-types"><a class="header" href="#enums-sum-types">Enums (sum types)</a></h3>
<p>ABI calls containing enums (sum types) are encoded similarly to structs: encode the discriminant first, then recursively encode the type of the enum variant being passed to the function being called.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MySumType
{
    X: u32,
    Y: bool,
}

abi MyContract {
    fn foo(a: u64);
    fn bar(a: MySumType);
} {
    fn baz(a: ()) { }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>bar</code> with <code>MySumType::X(42)</code> yields:</p>
<pre><code class="language-plaintext">0x
0000000000000000 // The discriminant of the chosen enum, in this case `0`.
000000000000002a // `42` encoded as u64
</code></pre>
<p>If the sum type has variants of different sizes, then left padding is required.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MySumType
{
    X: b256,
    Y: u32,
}

abi MyContract {
    fn foo(a: u64);
    fn bar(a: MySumType);
} {
    fn baz(a: ()) { }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>bar</code> with <code>MySumType::Y(42)</code> yields:</p>
<pre><code class="language-plaintext">0x
0000000000000001 // The discriminant of the chosen enum, in this case `1`.
0000000000000000 // Left padding
0000000000000000 // Left padding
0000000000000000 // Left padding
000000000000002a // `42` encoded as u64
</code></pre>
<p>Note that three words of padding are required because the largest variant of <code>MySumType</code> is 4 words wide.</p>
<p>If all the variants of a sum type are of type <code>()</code>, or unit, then only the discriminant needs to be encoded.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MySumType
{
    X: (),
    Y: (),
    Z: (),
}

abi MyContract {
    fn foo(a: u64);
    fn bar(a: MySumType);
} {
    fn baz(a: ()) { }
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>bar</code> with <code>MySumType::Z</code> yields:</p>
<pre><code class="language-plaintext">0x
0000000000000002 // The discriminant of the chosen enum, in this case `2`.
</code></pre>
<h3 id="vectors"><a class="header" href="#vectors">Vectors</a></h3>
<p>ABI calls containing vectors are encoded in the following way:</p>
<ul>
<li>First, figure out the the length <code>l</code> of the vector. Its length will also be its capacity.</li>
<li>Encode the content of the vector according to the spec of its type, e.g. for a <code>Vec&lt;bool&gt;</code>,
encode each <code>bool</code> element according to the <code>bool</code> specs. This gives out data that is stored
on the heap, and we encode only the pointer to this data</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>abi MyContract {
  fn foo(a: Vec&lt;u32&gt;);
} {
  fn foo(a: Vec&lt;u32&gt;) {};
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>foo</code> with <code>vec![1u32, 2u32, 3u32, 4u32]</code>:</p>
<ul>
<li><code>length</code> is 4, <code>capacity</code> is 4</li>
<li><code>data</code>: [0x0000000000000001, 0x0000000000000002, 0x0000000000000003, 0x0000000000000004], stored at pointer address <code>0x000000000000beef</code></li>
</ul>
<blockquote>
<p>Note: to understand how the <code>u32</code> are encoded, see the section about encoding integers.</p>
</blockquote>
<pre><code class="language-plaintext">0x
000000000000beef // pointer address
0000000000000004 // length = 4
0000000000000004 // capacity = 4
</code></pre>
<p>At the pointer address, then the vector's content are encoded as such:</p>
<pre><code class="language-plaintext">0x
0000000000000001 // 1u32
0000000000000002 // 2u32
0000000000000003 // 3u32
0000000000000004 // 4u32
</code></pre>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>ABI calls containing tuples are encoded as such:
If <code>X</code> is a tuple with the type signature <code>(T_1, T_2, ..., T_n)</code>, with <code>T_1,...,T_n</code> being any type except for vector, then <code>enc(X)</code> is encoded as the concatenation of <code>enc(T_1)</code>, <code>enc(T_2)</code>,<code>enc (T_3)</code>, ..., <code>enc(T_n)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>abi MyContract {
  fn foo(a: (u64, str[3], bool));
} {
  fn foo(a: (u64, str[4], bool)) {};
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>foo</code> with <code>(1u64, &quot;fuel&quot;, true)</code> :</p>
<pre><code class="language-plaintext">0x
0000000000000001 // 1u64
6675656c00000000 // &quot;fuel&quot; encoded as per the specs
0000000000000001 // true
</code></pre>
<h2 id="version-1"><a class="header" href="#version-1">Version 1</a></h2>
<p>This version was created to replace the older version 0 described above, and follows three philosophical tenets:</p>
<ul>
<li>being self-sufficient: it must be possible to completely decode the original data only using the encoded bytes and the original type (there are no references to data outside the encoded bytes);</li>
<li>no overhead: only the bare minimum bytes are necessary to do the encoding. No metadata, headers, etc...;</li>
<li>no relation with runtime memory layout: no padding, no alignment, etc...</li>
</ul>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<p>Primitive types will be encoded using the exact number of bits they need:</p>
<ul>
<li><code>u8</code>: 1 byte;</li>
<li><code>u16</code>: 2 bytes;</li>
<li><code>u32</code>: 4 bytes;</li>
<li><code>u64</code>: 8 bytes;</li>
<li><code>u256</code>: 32 bytes;</li>
<li><code>b256</code>: 32 bytes;</li>
</ul>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Arrays are encoded without any padding or alignment, with one item after the other.</p>
<ul>
<li>[T; 1] is encoded [encode(T)];</li>
<li>[T; 2] is encoded [encode(T), encode(T)]</li>
</ul>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>String arrays are encoded just like arrays, without any overhead.</p>
<ul>
<li><code>str[1]</code> = 1 byte</li>
<li><code>str[2]</code> = 2 bytes</li>
<li><code>str[n]</code> = <code>n</code> bytes</li>
</ul>
<p>String slices do contain their length as u64, and the string itself is encoded packed without alignment or padding.</p>
<ul>
<li><code>&quot;abc&quot;</code> = <code>[0, 0, 0, 0, 0, 0, 0, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></li>
</ul>
<h3 id="slices"><a class="header" href="#slices">Slices</a></h3>
<p><code>raw_slice</code>, also being dynamic, contains their length as u64 and is treated as a &quot;slice of bytes&quot;. Each byte is encoded as <code>u8</code> (1 byte) and is packed without alignment and padding.</p>
<p>For example, a slice of three bytes like <code>[0u8, 1u8, 2u8]</code> will be encoded as bytes <code>[0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 2]</code></p>
<h3 id="tuple-1"><a class="header" href="#tuple-1">Tuple</a></h3>
<p>Tuples are encoded just like arrays, without any overhead like padding and alignment:</p>
<ul>
<li><code>(A, B, C)</code> = <code>[encode(A), encode(B), encode(C)]</code></li>
</ul>
<h3 id="structs-v1"><a class="header" href="#structs-v1">Structs (v1)</a></h3>
<p>Structs can be encoded in two ways:</p>
<ul>
<li>first, with the automatic implementation;</li>
<li>second, with the custom implementation.</li>
</ul>
<p>Auto implementation follows the same rules as tuples. So we can imagine that</p>
<pre><code class="language-sway">struct S {
    a: A,
    b: B,
    c: C
}
</code></pre>
<p>is encoded the same way as the tuple <code>(A, B, C)</code>.</p>
<p>Custom implementation allows the developer to choose how a struct is encoded.</p>
<p>A struct has auto-implemented encoding if no custom was found.</p>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p><code>Enums</code> can also be encoded with the automatic or the custom implementation.</p>
<p>The auto implementation first encoded the variant with a <code>u64</code> number starting from zero as the first variant and increments this value for each variant, following declaration order.</p>
<pre><code class="language-sway">enum E {
    VARIANT_A: A, // &lt;- variant 0
    VARIANT_B: B, // &lt;- variant 1
    VARIANT_C: C  // &lt;- variant 2 
}
</code></pre>
<p>will be encoded as <code>[encode(variant), encode(value)]</code>.</p>
<p>The variant data will be encoded right after the variant tag, without any alignment or padding.</p>
<p>An enum has auto-implemented encoding if no custom was found.</p>
<h3 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h3>
<p>Some common data structures also have well-defined encoding:</p>
<ul>
<li><code>Vec</code> will be encoded as <code>[encode(length), &lt;encode each item&gt;]</code></li>
<li><code>Bytes</code> will be encoded as <code>[encode(length), &lt;bytes&gt;]</code></li>
<li><code>String</code> will be encoded as <code>[encode (length), &lt;data&gt;]</code></li>
</ul>
<p>All of them first contain the length and then their data right after, without any padding or alignment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-based-ids"><a class="header" href="#hash-based-ids">Hash based IDs</a></h1>
<p>Hash based ids are deterministically generated from associated types and are used in the JSON ABI for <code>type</code> IDs and for <code>logId</code>.
This document specifies how the hash based IDS are generated for <code>type</code> IDs and for <code>logId</code>.</p>
<h2 id="generation"><a class="header" href="#generation">Generation</a></h2>
<p>Hash based ids for <code>type</code> IDs are generated from the <code>sha256</code> of a string that represents the type.</p>
<p>For <code>logIds</code> we use the first 8 bytes of the <code>sha256</code> of a string that represents the type, this is because the <code>LOG</code> and <code>LOGD</code> opcodes use a 64bit value as log id.</p>
<h2 id="string-representation-of-types"><a class="header" href="#string-representation-of-types">String representation of types</a></h2>
<p>For describing the string representation of type we will use the notation <code>{abi_str(T)}</code> that should be replaced by the respective ABI string representation of the respective type <code>T</code>.</p>
<h3 id="intrinsics"><a class="header" href="#intrinsics">Intrinsics</a></h3>
<p><code>u8</code>   =&gt; <code>&quot;u8&quot;</code>
<code>u16</code>  =&gt; <code>&quot;u16&quot;</code>
<code>u32</code>  =&gt; <code>&quot;u32&quot;</code>
<code>u64</code>  =&gt; <code>&quot;u64&quot;</code>
<code>u256</code> =&gt; <code>&quot;u256&quot;</code>
<code>b256</code> =&gt; <code>&quot;b256&quot;</code>
<code>bool</code> =&gt; <code>&quot;bool&quot;</code></p>
<h3 id="string-arrays"><a class="header" href="#string-arrays">String arrays</a></h3>
<p>String array of size <code>1</code> =&gt; <code>&quot;str[1]&quot;</code>
String array of size <code>2</code> =&gt; <code>&quot;str[2]&quot;</code>
etc.</p>
<h3 id="string-slices"><a class="header" href="#string-slices">String slices</a></h3>
<p>String slice =&gt; <code>&quot;str&quot;</code></p>
<h3 id="arrays-1"><a class="header" href="#arrays-1">Arrays</a></h3>
<p><code>[T; 1]</code> =&gt; <code>&quot;[{abi_str(T)}; 1]&quot;</code>
<code>[T; 2]</code> =&gt; <code>&quot;[{abi_str(T)}; 2]&quot;</code>
etc.</p>
<h3 id="tuples-1"><a class="header" href="#tuples-1">Tuples</a></h3>
<p><code>()</code>      =&gt; <code>&quot;()&quot;</code>
<code>(T1)</code>    =&gt; <code>&quot;({abi_str(T1)})&quot;</code>
<code>(T1,T2)</code> =&gt; <code>&quot;({abi_str(T1)}, {abi_str(T2)})&quot;</code>
etc.</p>
<h3 id="enums-1"><a class="header" href="#enums-1">Enums</a></h3>
<p><code>Option</code> enum with type parameter <code>T</code> =&gt; <code>&quot;enum std::option::Option&lt;{abi_str(T)}&gt;&quot;</code>
Enum without type parameters named <code>MyEnum</code> =&gt; <code>&quot;enum MyEnum&quot;</code>
Enum with type parameter <code>T1</code> named <code>MyEnum</code> =&gt; <code>&quot;enum MyEnum&lt;{abi_str(T1)}&gt;&quot;</code>
Enum with type parameters <code>T1</code>, <code>T2</code> named <code>MyEnum</code> in <code>my_module</code> =&gt; <code>&quot;enum my_module::MyEnum&lt;{abi_str(T1)},{abi_str(T2)}&gt;&quot;</code></p>
<h3 id="structs-1"><a class="header" href="#structs-1">Structs</a></h3>
<p><code>Vec</code> struct with type parameter <code>T</code> =&gt; <code>&quot;struct std::vec::Vec&lt;{abi_str(T)}&gt;&quot;</code>
Struct without type parameters named <code>MyStruct</code> =&gt; <code>&quot;struct MyStruct&quot;</code>
Struct with type parameter <code>T1</code> named <code>MyStruct</code> =&gt; <code>&quot;struct MyStruct&lt;{abi_str(T1)}&gt;&quot;</code>
Struct with type parameters <code>T1</code>, <code>T2</code> named <code>MyStruct</code> in <code>my_module</code> =&gt; <code>&quot;struct my_module::MyStruct&lt;{abi_str(T1)},{abi_str(T2)}&gt;&quot;</code></p>
<h3 id="generic-type-parameter-1"><a class="header" href="#generic-type-parameter-1">Generic Type Parameter</a></h3>
<p>Generic type parameter <code>T</code> if root type =&gt; <code>&quot;generic T&quot;</code>
Generic type parameter <code>T</code> if not root type =&gt; <code>&quot;T&quot;</code> as in <code>&quot;struct MyStruct&lt;T&gt;&quot;</code></p>
<h3 id="complex-examples-composition"><a class="header" href="#complex-examples-composition">Complex examples composition</a></h3>
<p>Tuple of array and <code>u64</code> =&gt; <code>&quot;([u64,1]; u64)&quot;</code>
Array of <code>Option&lt;u64&gt;</code>=&gt; <code>&quot;[enum std::option::Option&lt;u64&gt;; 3]&quot;</code>
Struct with tuple type parameter =&gt; <code>&quot;struct my_module::MyStruct&lt;(u64, u64)&gt;&quot;</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuel-vm-specification"><a class="header" href="#fuel-vm-specification">Fuel VM Specification</a></h1>
<ul>
<li><a href="fuel-vm/index.html#introduction">Introduction</a></li>
<li><a href="fuel-vm/index.html#parameters">Parameters</a></li>
<li><a href="fuel-vm/index.html#semantics">Semantics</a></li>
<li><a href="fuel-vm/index.html#flags">Flags</a></li>
<li><a href="fuel-vm/index.html#instruction-set">Instruction Set</a></li>
<li><a href="fuel-vm/index.html#vm-initialization">VM Initialization</a></li>
<li><a href="fuel-vm/index.html#contexts">Contexts</a>
<ul>
<li><a href="fuel-vm/index.html#predicate-estimation-and-verification">Predicate Estimation and Verification</a></li>
<li><a href="fuel-vm/index.html#script-execution">Script Execution</a></li>
<li><a href="fuel-vm/index.html#call">Call</a></li>
</ul>
</li>
<li><a href="fuel-vm/index.html#call-frames">Call Frames</a></li>
<li><a href="fuel-vm/index.html#ownership">Ownership</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This document provides the specification for the Fuel Virtual Machine (FuelVM). The specification covers the types, instruction set, and execution semantics.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>value</th><th>note</th></tr></thead><tbody>
<tr><td><code>CONTRACT_MAX_SIZE</code></td><td><code>uint64</code></td><td></td><td>Maximum contract size, in bytes.</td></tr>
<tr><td><code>VM_MAX_RAM</code></td><td><code>uint64</code></td><td><code>2**26</code></td><td>64 MiB.</td></tr>
<tr><td><code>MESSAGE_MAX_DATA_SIZE</code></td><td><code>uint64</code></td><td></td><td>Maximum size of message data, in bytes.</td></tr>
</tbody></table>
</div>
<h2 id="semantics"><a class="header" href="#semantics">Semantics</a></h2>
<p>FuelVM instructions are exactly 32 bits (4 bytes) wide and comprise of a combination of:</p>
<ul>
<li>Opcode: 8 bits</li>
<li>Register/special register (see below) identifier: 6 bits</li>
<li>Immediate value: 12, 18, or 24 bits, depending on operation</li>
</ul>
<p>Of the 64 registers (6-bit register address space), the first <code>16</code> are reserved:</p>
<div class="table-wrapper"><table><thead><tr><th>value</th><th>register</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>0x00</code></td><td><code>$zero</code></td><td>zero</td><td>Contains zero (<code>0</code>), for convenience.</td></tr>
<tr><td><code>0x01</code></td><td><code>$one</code></td><td>one</td><td>Contains one (<code>1</code>), for convenience.</td></tr>
<tr><td><code>0x02</code></td><td><code>$of</code></td><td>overflow</td><td>Contains overflow/underflow of addition, subtraction, and multiplication.</td></tr>
<tr><td><code>0x03</code></td><td><code>$pc</code></td><td>program counter</td><td>The program counter. Memory address of the current instruction.</td></tr>
<tr><td><code>0x04</code></td><td><code>$ssp</code></td><td>stack start pointer</td><td>Memory address of bottom of current writable stack area.</td></tr>
<tr><td><code>0x05</code></td><td><code>$sp</code></td><td>stack pointer</td><td>Memory address on top of current writable stack area (points to free memory).</td></tr>
<tr><td><code>0x06</code></td><td><code>$fp</code></td><td>frame pointer</td><td>Memory address of beginning of current call frame.</td></tr>
<tr><td><code>0x07</code></td><td><code>$hp</code></td><td>heap pointer</td><td>Memory address below the current bottom of the heap (points to used/OOB memory).</td></tr>
<tr><td><code>0x08</code></td><td><code>$err</code></td><td>error</td><td>Error codes for particular operations.</td></tr>
<tr><td><code>0x09</code></td><td><code>$ggas</code></td><td>global gas</td><td>Remaining gas globally.</td></tr>
<tr><td><code>0x0A</code></td><td><code>$cgas</code></td><td>context gas</td><td>Remaining gas in the context.</td></tr>
<tr><td><code>0x0B</code></td><td><code>$bal</code></td><td>balance</td><td>Received balance for this context.</td></tr>
<tr><td><code>0x0C</code></td><td><code>$is</code></td><td>instructions start</td><td>Pointer to the start of the currently-executing code.</td></tr>
<tr><td><code>0x0D</code></td><td><code>$ret</code></td><td>return value</td><td>Return value or pointer.</td></tr>
<tr><td><code>0x0E</code></td><td><code>$retl</code></td><td>return length</td><td>Return value length in bytes.</td></tr>
<tr><td><code>0x0F</code></td><td><code>$flag</code></td><td>flags</td><td>Flags register.</td></tr>
</tbody></table>
</div>
<p>Integers are represented in <a href="https://en.wikipedia.org/wiki/Endianness">big-endian</a> format, and all operations are unsigned. Boolean <code>false</code> is <code>0</code> and Boolean <code>true</code> is <code>1</code>.</p>
<p>Registers are 64 bits (8 bytes) wide. Words are the same width as registers.</p>
<p>Persistent state (i.e. storage) is a key-value store with 32-byte keys and 32-byte values. Each contract has its own persistent state that is independent of other contracts. This is committed to in a Sparse Binary Merkle Tree.</p>
<h2 id="flags"><a class="header" href="#flags">Flags</a></h2>
<div class="table-wrapper"><table><thead><tr><th>value</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>0x01</code></td><td><code>F_UNSAFEMATH</code></td><td>If set, undefined arithmetic zeroes target and sets <code>$err</code> without panic.</td></tr>
<tr><td><code>0x02</code></td><td><code>F_WRAPPING</code></td><td>If set, overflowing arithmetic wraps around and sets <code>$of</code> without panic.</td></tr>
</tbody></table>
</div>
<p>All other flags are reserved, any must be set to zero.</p>
<h2 id="instruction-set"><a class="header" href="#instruction-set">Instruction Set</a></h2>
<p>A complete instruction set of the Fuel VM is documented in <a href="fuel-vm/./instruction-set.html">the following page</a>.</p>
<h2 id="vm-initialization"><a class="header" href="#vm-initialization">VM Initialization</a></h2>
<p>Every time the VM runs, a single monolithic memory of size <code>VM_MAX_RAM</code> bytes is allocated, indexed by individual byte. A stack and heap memory model is used, allowing for dynamic memory allocation in higher-level languages. The stack begins at <code>0</code> and grows upward. The heap begins at <code>VM_MAX_RAM</code> and grows downward.</p>
<p>To initialize the VM, the following is pushed on the stack sequentially:</p>
<ol>
<li>Transaction hash (<code>byte[32]</code>, word-aligned), computed as defined <a href="fuel-vm/../identifiers/transaction-id.html">here</a>.</li>
<li>Base asset ID (<code>byte[32]</code>, word-aligned)</li>
<li><a href="fuel-vm/../tx-format/consensus_parameters.html"><code>MAX_INPUTS</code></a> pairs of <code>(asset_id: byte[32], balance: uint64)</code>, of:
<ol>
<li>For <a href="fuel-vm/index.html#predicate-estimation-and-verification">predicate estimation and verification</a>, zeroes.</li>
<li>For <a href="fuel-vm/index.html#script-execution">script execution</a>, the free balance for each asset ID seen in the transaction's inputs, ordered in ascending order. If there are fewer than <code>MAX_INPUTS</code> asset IDs, the pair has a value of zero.</li>
</ol>
</li>
<li>Transaction length, in bytes (<code>uint64</code>, word-aligned).</li>
<li>The <a href="fuel-vm/../tx-format/index.html">transaction, serialized</a>.</li>
</ol>
<p>Then the following registers are initialized (without explicit initialization, all registers are initialized to zero):</p>
<ol>
<li><code>$ssp = 32 + 32 + MAX_INPUTS*(32+8) + size(tx))</code>: the writable stack area starts immediately after the serialized transaction in memory (see above).</li>
<li><code>$sp = $ssp</code>: writable stack area is empty to start.</li>
<li><code>$hp = VM_MAX_RAM</code>: the heap area begins at the top and is empty to start.</li>
</ol>
<h2 id="contexts"><a class="header" href="#contexts">Contexts</a></h2>
<p>There are 4 <em>contexts</em> in the FuelVM: <a href="fuel-vm/index.html#predicate-estimation-and-verification">predicate estimation and verification</a>, <a href="fuel-vm/index.html#script-execution">scripts</a>, and <a href="fuel-vm/index.html#call">calls</a>. A context is an isolated execution environment with defined <a href="fuel-vm/index.html#ownership">memory ownership</a> and can be <em>external</em> or <em>internal</em>:</p>
<ul>
<li>External: predicate and script. <code>$fp</code> will be zero.</li>
<li>Internal: call. <code>$fp</code> will be non-zero.</li>
</ul>
<p><a href="fuel-vm/./instruction-set.html#return-return-from-call">Returning</a> from a context behaves differently depending on whether the context is external or internal.</p>
<h3 id="predicate-estimation-and-verification"><a class="header" href="#predicate-estimation-and-verification">Predicate Estimation and Verification</a></h3>
<p>There are two ways to run predicates on the VM:</p>
<ol>
<li>Estimation: runs the predicate and updates the amount of gas used</li>
<li>Verification: runs the predicate and verifies the amount of gas used matches the input</li>
</ol>
<p>For any input of type <a href="fuel-vm/../tx-format/input.html#inputcoin"><code>InputType.Coin</code></a> or <a href="fuel-vm/../tx-format/input.html#inputmessage"><code>InputType.Message</code></a>, a non-zero <code>predicateLength</code> field means the UTXO being spent is a <a href="https://en.bitcoin.it/P2SH"><code>P2SH</code></a> rather than a <a href="https://en.bitcoin.it/P2PKH"><code>P2PKH</code></a> output.</p>
<p>For each such input in the transaction, the VM is <a href="fuel-vm/index.html#vm-initialization">initialized</a>, then:</p>
<ol>
<li><code>$pc</code> and <code>$is</code> are set to the start of the input's <code>predicate</code> field.</li>
<li><code>$ggas</code> and <code>$cgas</code> are set to <code>MAX_GAS_PER_PREDICATE</code> for estimation, and <code>predicateGasUsed</code> for verification.</li>
</ol>
<p>Predicate execution will fail if gas is exhausted during execution.</p>
<p>During predicate mode, hitting any <a href="fuel-vm/./instruction-set.html#contract-instructions">contract instruction</a> (except <code>ldc</code> with non-contract target) causes predicate verification to halt, returning Boolean <code>false</code>.</p>
<p>A predicate that halts without returning Boolean <code>true</code> would not pass verification, making the entire transaction invalid. Note that predicate return value is monotonic with respect to time (i.e. if a predicate evaluates to <code>true</code> then it will always evaluate to <code>true</code> in the future).</p>
<p>After successful execution, the run mode is determines the final step:</p>
<ol>
<li>Estimation: <code>predicateGasUsed</code> is set to <code>MAX_GAS_PER_PREDICATE - $ggas</code>.</li>
<li>Verification: if <code>$ggas</code> is non-zero, predicate verification fails.</li>
</ol>
<h3 id="script-execution-1"><a class="header" href="#script-execution-1">Script Execution</a></h3>
<p>If script bytecode is present, transaction validation requires execution.</p>
<p>The VM is <a href="fuel-vm/index.html#vm-initialization">initialized</a>, then:</p>
<ol>
<li><code>$pc</code> and <code>$is</code> are set to the start of the transaction's script bytecode.</li>
<li><code>$ggas</code> and <code>$cgas</code> are set to <code>tx.scriptGasLimit</code>.</li>
</ol>
<p>Following initialization, execution begins.</p>
<p>For each instruction, its gas cost <code>gc</code> is first computed. If <code>gc &gt; $cgas</code>, deduct <code>$cgas</code> from <code>$ggas</code> and <code>$cgas</code> (i.e. spend all of <code>$cgas</code> and no more), then <a href="fuel-vm/./instruction-set.html#rvrt-revert">revert</a> immediately without actually executing the instruction. Otherwise, deduct <code>gc</code> from <code>$ggas</code> and <code>$cgas</code>.</p>
<p>After the script has been executed, <code>tx.receiptsRoot</code> is updated to contain the Merkle root of the receipts, <a href="fuel-vm/../tx-format/transaction.html#%60TransactionScript%60">as described in the <code>TransactionScript</code> spec</a>.</p>
<h3 id="call"><a class="header" href="#call">Call</a></h3>
<p>Call context is entered via <a href="fuel-vm/./instruction-set.html#call-call-contract"><code>CALL</code> instruction</a>. It's also called <em>internal context</em>, or <em>contract context</em>. Call context is used to access state of a contract.</p>
<h2 id="call-frames"><a class="header" href="#call-frames">Call Frames</a></h2>
<p>Cross-contract calls push a <em>call frame</em> onto the stack, similar to a stack frame used in regular languages for function calls (which may be used by a high-level language that targets the FuelVM). The distinction is as follows:</p>
<ol>
<li>Stack frames: store metadata across trusted internal (i.e. intra-contract) function calls. Not supported natively by the FuelVM, but may be used as an abstraction at a higher layer.</li>
<li>Call frames: store metadata across untrusted external (i.e. inter-contract) calls. Supported natively by the FuelVM.</li>
</ol>
<p>Call frames are needed to ensure that the called contract cannot mutate the running state of the current executing contract. They segment access rights for memory: the currently-executing contracts may only write to their own call frame and their own heap.</p>
<p>A call frame consists of the following, word-aligned:</p>
<div class="table-wrapper"><table><thead><tr><th>bytes</th><th>type</th><th>value</th><th>description</th></tr></thead><tbody>
<tr><td></td><td></td><td></td><td><strong>Unwritable area begins.</strong></td></tr>
<tr><td>32</td><td><code>byte[32]</code></td><td><code>to</code></td><td>Contract ID for this call.</td></tr>
<tr><td>32</td><td><code>byte[32]</code></td><td><code>asset_id</code></td><td>asset ID of forwarded coins.</td></tr>
<tr><td>8*64</td><td><code>byte[8][64]</code></td><td><code>regs</code></td><td>Saved registers from previous context.</td></tr>
<tr><td>8</td><td><code>uint64</code></td><td><code>codesize</code></td><td>Code size in bytes, padded to the next word boundary.</td></tr>
<tr><td>8</td><td><code>byte[8]</code></td><td><code>param1</code></td><td>First parameter.</td></tr>
<tr><td>8</td><td><code>byte[8]</code></td><td><code>param2</code></td><td>Second parameter.</td></tr>
<tr><td>1*</td><td><code>byte[]</code></td><td><code>code</code></td><td>Zero-padded to 8-byte alignment, but individual instructions are not aligned.</td></tr>
<tr><td></td><td></td><td></td><td><strong>Unwritable area ends.</strong></td></tr>
<tr><td>*</td><td></td><td></td><td>Call frame's stack.</td></tr>
</tbody></table>
</div>
<h2 id="access-rights"><a class="header" href="#access-rights">Access rights</a></h2>
<p>Only memory that has been allocated is accessible.
In other words, memory between highest-ever <code>$sp</code> value and current <code>$hp</code>
is inaccessible. Attempting to read or write
memory that has not been allocated will result in VM panic.
Similarly reads or writes that cross from the stack to the heap
will panic. Note that stack remains readable even after stack
frame has been shrunk. However, if the heap is afterwards expanded
to cover that area, the crossing read prohibition still remains,
while all memory is accessible.</p>
<h3 id="ownership"><a class="header" href="#ownership">Ownership</a></h3>
<p>Whenever memory is written to (i.e. with <a href="fuel-vm/./instruction-set.html#sb-store-byte"><code>SB</code></a> or <a href="fuel-vm/./instruction-set.html#sw-store-word"><code>SW</code></a>), or write access is granted (i.e. with <a href="fuel-vm/./instruction-set.html#call-call-contract"><code>CALL</code></a>), ownership must be checked.</p>
<p>If the context is external, the owned memory range is:</p>
<ol>
<li><code>[$ssp, $sp)</code>: the writable stack area.</li>
<li><code>[$hp, VM_MAX_RAM)</code>: the heap area allocated by this script or predicate.</li>
</ol>
<p>If the context is internal, the owned memory range for a call frame is:</p>
<ol>
<li><code>[$ssp, $sp)</code>: the writable stack area of the call frame.</li>
<li><code>[$hp, $fp-&gt;$hp)</code>: the heap area allocated by this call frame.</li>
</ol>
<h3 id="executability"><a class="header" href="#executability">Executability</a></h3>
<p>Memory is only executable in range <code>[$is, $ssp)</code>. Attempting to execute instructions outside these boundaries will cause a panic. This area never overlaps with writable memory, essentially providing <a href="https://en.wikipedia.org/wiki/W%5EX">W^X</a> protection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuelvm-instruction-set"><a class="header" href="#fuelvm-instruction-set">FuelVM Instruction Set</a></h1>
<ul>
<li><a href="fuel-vm/instruction-set.html#reading-guide">Reading Guide</a></li>
<li><a href="fuel-vm/instruction-set.html#arithmeticlogic-alu-instructions">Arithmetic/Logic (ALU) Instructions</a>
<ul>
<li><a href="fuel-vm/instruction-set.html#add-add"><code>ADD</code>: Add</a></li>
<li><a href="fuel-vm/instruction-set.html#addi-add-immediate"><code>ADDI</code>: Add immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#and-and"><code>AND</code>: AND</a></li>
<li><a href="fuel-vm/instruction-set.html#andi-and-immediate"><code>ANDI</code>: AND immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#div-divide"><code>DIV</code>: Divide</a></li>
<li><a href="fuel-vm/instruction-set.html#divi-divide-immediate"><code>DIVI</code>: Divide immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#eq-equals"><code>EQ</code>: Equals</a></li>
<li><a href="fuel-vm/instruction-set.html#exp-exponentiate"><code>EXP</code>: Exponentiate</a></li>
<li><a href="fuel-vm/instruction-set.html#expi-exponentiate-immediate"><code>EXPI</code>: Exponentiate immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#gt-greater-than"><code>GT</code>: Greater than</a></li>
<li><a href="fuel-vm/instruction-set.html#lt-less-than"><code>LT</code>: Less than</a></li>
<li><a href="fuel-vm/instruction-set.html#mlog-math-logarithm"><code>MLOG</code>: Math logarithm</a></li>
<li><a href="fuel-vm/instruction-set.html#mod-modulus"><code>MOD</code>: Modulus</a></li>
<li><a href="fuel-vm/instruction-set.html#modi-modulus-immediate"><code>MODI</code>: Modulus immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#move-move"><code>MOVE</code>: Move</a></li>
<li><a href="fuel-vm/instruction-set.html#movi-move-immediate"><code>MOVI</code>: Move immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#mroo-math-root"><code>MROO</code>: Math root</a></li>
<li><a href="fuel-vm/instruction-set.html#mul-multiply"><code>MUL</code>: Multiply</a></li>
<li><a href="fuel-vm/instruction-set.html#muli-multiply-immediate"><code>MULI</code>: Multiply immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#mldv-fused-multiply-divide"><code>MLDV</code>: Fused multiply-divide</a></li>
<li><a href="fuel-vm/instruction-set.html#noop-no-operation"><code>NOOP</code>: No operation</a></li>
<li><a href="fuel-vm/instruction-set.html#not-invert"><code>NOT</code>: Invert</a></li>
<li><a href="fuel-vm/instruction-set.html#or-or"><code>OR</code>: OR</a></li>
<li><a href="fuel-vm/instruction-set.html#ori-or-immediate"><code>ORI</code>: OR immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#sll-shift-left-logical"><code>SLL</code>: Shift left logical</a></li>
<li><a href="fuel-vm/instruction-set.html#slli-shift-left-logical-immediate"><code>SLLI</code>: Shift left logical immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#srl-shift-right-logical"><code>SRL</code>: Shift right logical</a></li>
<li><a href="fuel-vm/instruction-set.html#srli-shift-right-logical-immediate"><code>SRLI</code>: Shift right logical immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#sub-subtract"><code>SUB</code>: Subtract</a></li>
<li><a href="fuel-vm/instruction-set.html#subi-subtract-immediate"><code>SUBI</code>: Subtract immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#subi-subtract-immediate"><code>SUBI</code>: Subtract immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#wdcm-128-bit-integer-comparison"><code>WDCM</code>: 128-bit integer comparison</a></li>
<li><a href="fuel-vm/instruction-set.html#wqcm-256-bit-integer-comparison"><code>WQCM</code>: 256-bit integer comparison</a></li>
<li><a href="fuel-vm/instruction-set.html#wdop-misc-128-bit-integer-operations"><code>WDOP</code>: Misc 128-bit integer operations</a></li>
<li><a href="fuel-vm/instruction-set.html#wqop-misc-256-bit-integer-operations"><code>WQOP</code>: Misc 256-bit integer operations</a></li>
<li><a href="fuel-vm/instruction-set.html#wdml-multiply-128-bit-integers"><code>WDML</code>: Multiply 128-bit integers</a></li>
<li><a href="fuel-vm/instruction-set.html#wqml-multiply-256-bit-integers"><code>WQML</code>: Multiply 256-bit integers</a></li>
<li><a href="fuel-vm/instruction-set.html#wddv-128-bit-integer-division"><code>WDDV</code>: 128-bit integer division</a></li>
<li><a href="fuel-vm/instruction-set.html#wqdv-256-bit-integer-division"><code>WQDV</code>: 256-bit integer division</a></li>
<li><a href="fuel-vm/instruction-set.html#wdmd-128-bit-integer-fused-multiply-divide"><code>WDMD</code>: 128-bit integer fused multiply-divide</a></li>
<li><a href="fuel-vm/instruction-set.html#wqmd-256-bit-integer-fused-multiply-divide"><code>WQMD</code>: 256-bit integer fused multiply-divide</a></li>
<li><a href="fuel-vm/instruction-set.html#wdam-modular-128-bit-integer-addition"><code>WDAM</code>: Modular 128-bit integer addition</a></li>
<li><a href="fuel-vm/instruction-set.html#wqam-modular-256-bit-integer-addition"><code>WQAM</code>: Modular 256-bit integer addition</a></li>
<li><a href="fuel-vm/instruction-set.html#wdmm-modular-128-bit-integer-multiplication"><code>WDMM</code>: Modular 128-bit integer multiplication</a></li>
<li><a href="fuel-vm/instruction-set.html#wqmm-modular-256-bit-integer-multiplication"><code>WQMM</code>: Modular 256-bit integer multiplication</a></li>
<li><a href="fuel-vm/instruction-set.html#xor-xor"><code>XOR</code>: XOR</a></li>
<li><a href="fuel-vm/instruction-set.html#xori-xor-immediate"><code>XORI</code>: XOR immediate</a></li>
</ul>
</li>
<li><a href="fuel-vm/instruction-set.html#control-flow-instructions">Control Flow Instructions</a>
<ul>
<li><a href="fuel-vm/instruction-set.html#jmp-jump"><code>JMP</code>: Jump</a></li>
<li><a href="fuel-vm/instruction-set.html#ji-jump-immediate"><code>JI</code>: Jump immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#jne-jump-if-not-equal"><code>JNE</code>: Jump if not equal</a></li>
<li><a href="fuel-vm/instruction-set.html#jnei-jump-if-not-equal-immediate"><code>JNEI</code>: Jump if not equal immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#jnzi-jump-if-not-zero-immediate"><code>JNZI</code>: Jump if not zero immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#jmpb-jump-relative-backwards"><code>JMPB</code>: Jump relative backwards</a></li>
<li><a href="fuel-vm/instruction-set.html#jmpf-jump-relative-forwards"><code>JMPF</code>: Jump relative forwards</a></li>
<li><a href="fuel-vm/instruction-set.html#jnzb-jump-if-not-zero-relative-backwards"><code>JNZB</code>: Jump if not zero relative backwards</a></li>
<li><a href="fuel-vm/instruction-set.html#jnzf-jump-if-not-zero-relative-forwards"><code>JNZF</code>: Jump if not zero relative forwards</a></li>
<li><a href="fuel-vm/instruction-set.html#jneb-jump-if-not-equal-relative-backwards"><code>JNEB</code>: Jump if not equal relative backwards</a></li>
<li><a href="fuel-vm/instruction-set.html#jnef-jump-if-not-equal-relative-forwards"><code>JNEF</code>: Jump if not equal relative forwards</a></li>
<li><a href="fuel-vm/instruction-set.html#ret-return-from-context"><code>RET</code>: Return from context</a></li>
</ul>
</li>
<li><a href="fuel-vm/instruction-set.html#memory-instructions">Memory Instructions</a>
<ul>
<li><a href="fuel-vm/instruction-set.html#aloc-allocate-memory"><code>ALOC</code>: Allocate memory</a></li>
<li><a href="fuel-vm/instruction-set.html#cfe-extend-call-frame"><code>CFE</code>: Extend call frame</a></li>
<li><a href="fuel-vm/instruction-set.html#cfei-extend-call-frame-immediate"><code>CFEI</code>: Extend call frame immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#cfs-shrink-call-frame"><code>CFS</code>: Shrink call frame</a></li>
<li><a href="fuel-vm/instruction-set.html#cfsi-shrink-call-frame-immediate"><code>CFSI</code>: Shrink call frame immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#lb-load-byte"><code>LB</code>: Load byte</a></li>
<li><a href="fuel-vm/instruction-set.html#lw-load-word"><code>LW</code>: Load word</a></li>
<li><a href="fuel-vm/instruction-set.html#mcl-memory-clear"><code>MCL</code>: Memory clear</a></li>
<li><a href="fuel-vm/instruction-set.html#mcli-memory-clear-immediate"><code>MCLI</code>: Memory clear immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#mcp-memory-copy"><code>MCP</code>: Memory copy</a></li>
<li><a href="fuel-vm/instruction-set.html#mcpi-memory-copy-immediate"><code>MCPI</code>: Memory copy immediate</a></li>
<li><a href="fuel-vm/instruction-set.html#meq-memory-equality"><code>MEQ</code>: Memory equality</a></li>
<li><a href="fuel-vm/instruction-set.html#poph-pop-a-set-of-high-registers-from-stack"><code>POPH</code>: Pop a set of high registers from stack</a></li>
<li><a href="fuel-vm/instruction-set.html#popl-pop-a-set-of-low-registers-from-stack"><code>POPL</code>: Pop a set of low registers from stack</a></li>
<li><a href="fuel-vm/instruction-set.html#pshh-push-a-set-of-high-registers-to-stack"><code>PSHH</code>: Push a set of high registers to stack</a></li>
<li><a href="fuel-vm/instruction-set.html#pshl-push-a-set-of-low-registers-to-stack"><code>PSHL</code>: Push a set of low registers to stack</a></li>
<li><a href="fuel-vm/instruction-set.html#sb-store-byte"><code>SB</code>: Store byte</a></li>
<li><a href="fuel-vm/instruction-set.html#sw-store-word"><code>SW</code>: Store word</a></li>
</ul>
</li>
<li><a href="fuel-vm/instruction-set.html#contract-instructions">Contract Instructions</a>
<ul>
<li><a href="fuel-vm/instruction-set.html#bal-balance-of-contract-id"><code>BAL</code>: Balance of contract ID</a></li>
<li><a href="fuel-vm/instruction-set.html#bhei-block-height"><code>BHEI</code>: Block height</a></li>
<li><a href="fuel-vm/instruction-set.html#bhsh-block-hash"><code>BHSH</code>: Block hash</a></li>
<li><a href="fuel-vm/instruction-set.html#burn-burn-existing-coins"><code>BURN</code>: Burn existing coins</a></li>
<li><a href="fuel-vm/instruction-set.html#call-call-contract"><code>CALL</code>: Call contract</a></li>
<li><a href="fuel-vm/instruction-set.html#cb-coinbase-contract-id"><code>CB</code>: Coinbase contract id</a></li>
<li><a href="fuel-vm/instruction-set.html#ccp-code-copy"><code>CCP</code>: Code copy</a></li>
<li><a href="fuel-vm/instruction-set.html#croo-code-merkle-root"><code>CROO</code>: Code Merkle root</a></li>
<li><a href="fuel-vm/instruction-set.html#csiz-code-size"><code>CSIZ</code>: Code size</a></li>
<li><a href="fuel-vm/instruction-set.html#ldc-load-code-from-an-external-contract-blob-or-memory"><code>LDC</code>: Load code from an external contract, blob or memory</a></li>
<li><a href="fuel-vm/instruction-set.html#log-log-event"><code>LOG</code>: Log event</a></li>
<li><a href="fuel-vm/instruction-set.html#logd-log-data-event"><code>LOGD</code>: Log data event</a></li>
<li><a href="fuel-vm/instruction-set.html#mint-mint-new-coins"><code>MINT</code>: Mint new coins</a></li>
<li><a href="fuel-vm/instruction-set.html#retd-return-from-context-with-data"><code>RETD</code>: Return from context with data</a></li>
<li><a href="fuel-vm/instruction-set.html#rvrt-revert"><code>RVRT</code>: Revert</a></li>
<li><a href="fuel-vm/instruction-set.html#smo-send-message-out"><code>SMO</code>: Send message to output</a></li>
<li><a href="fuel-vm/instruction-set.html#scwq-state-clear-sequential-32-byte-slots"><code>SCWQ</code>: State clear sequential 32 byte slots</a></li>
<li><a href="fuel-vm/instruction-set.html#srw-state-read-word"><code>SRW</code>: State read word</a></li>
<li><a href="fuel-vm/instruction-set.html#srwq-state-read-sequential-32-byte-slots"><code>SRWQ</code>: State read sequential 32 byte slots</a></li>
<li><a href="fuel-vm/instruction-set.html#sww-state-write-word"><code>SWW</code>: State write word</a></li>
<li><a href="fuel-vm/instruction-set.html#swwq-state-write-sequential-32-byte-slots"><code>SWWQ</code>: State write sequential 32 byte slots</a></li>
<li><a href="fuel-vm/instruction-set.html#time-timestamp-at-height"><code>TIME</code>: Timestamp at height</a></li>
<li><a href="fuel-vm/instruction-set.html#tr-transfer-coins-to-contract"><code>TR</code>: Transfer coins to contract</a></li>
<li><a href="fuel-vm/instruction-set.html#tro-transfer-coins-to-output"><code>TRO</code>: Transfer coins to output</a></li>
</ul>
</li>
<li><a href="fuel-vm/instruction-set.html#blob-instructions">Blob Instructions</a>
<ul>
<li><a href="fuel-vm/instruction-set.html#bsiz-blob-size"><code>BSIZ</code>: Blob size</a></li>
<li><a href="fuel-vm/instruction-set.html#bldd-load-data-from-a-blob"><code>BLDD</code>: Load data from a blob</a></li>
</ul>
</li>
<li><a href="fuel-vm/instruction-set.html#cryptographic-instructions">Cryptographic Instructions</a>
<ul>
<li><a href="fuel-vm/instruction-set.html#eck1-secp256k1-signature-recovery"><code>ECK1</code>: Secp251k1 signature recovery</a></li>
<li><a href="fuel-vm/instruction-set.html#ecr1-secp256r1-signature-recovery"><code>ECR1</code>: Secp256r1 signature recovery</a></li>
<li><a href="fuel-vm/instruction-set.html#ed19-eddsa-curve25519-verification"><code>ED19</code>: EdDSA curve25519 verification</a></li>
<li><a href="fuel-vm/instruction-set.html#k256-keccak-256"><code>K256</code>: keccak-256</a></li>
<li><a href="fuel-vm/instruction-set.html#s256-sha-2-256"><code>S256</code>: SHA-2-256</a></li>
</ul>
</li>
<li><a href="fuel-vm/instruction-set.html#other-instructions">Other Instructions</a>
<ul>
<li><a href="fuel-vm/instruction-set.html#ecal-call-external-function"><code>ECAL</code>: Call external function</a></li>
<li><a href="fuel-vm/instruction-set.html#flag-set-flags"><code>FLAG</code>: Set flags</a></li>
<li><a href="fuel-vm/instruction-set.html#gm-get-metadata"><code>GM</code>: Get metadata</a></li>
<li><a href="fuel-vm/instruction-set.html#gtf-get-transaction-fields"><code>GTF</code>: Get transaction fields</a></li>
</ul>
</li>
</ul>
<h2 id="reading-guide"><a class="header" href="#reading-guide">Reading Guide</a></h2>
<p>This page provides a description of all instructions for the FuelVM. Encoding is read as a sequence of one 8-bit value (the opcode identifier) followed by four 6-bit values (the register identifiers or immediate value). A single <code>i</code> indicates a 6-bit immediate value, <code>i i</code> indicates a 12-bit immediate value, <code>i i i</code> indicates an 18-bit immediate value, and <code>i i i i</code> indicates a 24-bit immediate value. All immediate values are interpreted as big-endian unsigned integers. If the instruction would be shorter than the full 32 bits, the remaining part is reserved and must be zero.</p>
<ul>
<li>The syntax <code>MEM[x, y]</code> used in this page means the memory range starting at byte <code>x</code>, of length <code>y</code> bytes.</li>
<li>The syntax <code>STATE[x, y]</code> used in this page means the sequence of storage slots starting at key <code>x</code> and spanning <code>y</code> bytes.</li>
</ul>
<h3 id="panics"><a class="header" href="#panics">Panics</a></h3>
<p>Some instructions may <em>panic</em>, i.e. enter an unrecoverable state. Additionally, attempting to execute an instruction not in this list causes a panic and consumes no gas. Instructions with reserved part having a non-zero value will likewise panic.  How a panic is handled depends on <a href="fuel-vm/./index.html#contexts">context</a>:</p>
<ul>
<li>In a predicate context, cease VM execution and return <code>false</code>.</li>
<li>In other contexts, revert (described below).</li>
</ul>
<p>On a non-predicate panic, append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.Panic</code></td></tr>
<tr><td><code>id</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<p>then append an additional receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.ScriptResult</code></td></tr>
<tr><td><code>result</code></td><td><code>uint64</code></td><td><code>1</code></td></tr>
<tr><td><code>gas_used</code></td><td><code>uint64</code></td><td>Gas consumed by the script.</td></tr>
</tbody></table>
</div>
<h3 id="receipts-1"><a class="header" href="#receipts-1">Receipts</a></h3>
<p>The number of receipts is limited to 2<sup>16</sup>, with the last two reserved to panic and script result receipts. Trying to add any other receipts after 2<sup>16</sup>-2 will panic.</p>
<h3 id="effects"><a class="header" href="#effects">Effects</a></h3>
<p>A few instructions are annotated with the <em>effects</em> they produce, the table below explains each effect:</p>
<div class="table-wrapper"><table><thead><tr><th>effect name</th><th>description</th></tr></thead><tbody>
<tr><td>Storage read</td><td>Instruction reads from storage slots</td></tr>
<tr><td>Storage write</td><td>Instruction writes to storage slots</td></tr>
<tr><td>External call</td><td>External contract call instruction</td></tr>
<tr><td>Balance tree read</td><td>Instruction reads from the balance tree</td></tr>
<tr><td>Balance tree write</td><td>Instruction writes to the balance tree</td></tr>
<tr><td>Output message</td><td>Instruction sends a message to a recipient address</td></tr>
</tbody></table>
</div>
<p>If an instruction is not annotated with an effect, it means it does not produce any of the aforementioned affects.</p>
<h2 id="arithmeticlogic-alu-instructions"><a class="header" href="#arithmeticlogic-alu-instructions">Arithmetic/Logic (ALU) Instructions</a></h2>
<p>All these instructions advance the program counter <code>$pc</code> by <code>4</code> after performing their operation.</p>
<p>Normally, if the result of an ALU operation is mathematically undefined (e.g. dividing by zero),
the VM panics. However, if the <a href="fuel-vm/./index.html#flags"><code>F_UNSAFEMATH</code></a> flag is set, <code>$err</code> is set to <code>true</code>
and execution continues.</p>
<p>If an operation would overflow, so that the result doesn't fit into the target field, the VM will panic.
Results below zero are also considered overflows. If the <a href="fuel-vm/./index.html#flags"><code>F_WRAPPING</code></a> flag is set,
instead <code>$of</code> is set to <code>true</code> or the overflowing part of the result, depending on the operation.</p>
<h3 id="add-add"><a class="header" href="#add-add"><code>ADD</code>: Add</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Adds two registers.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB + $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>add $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> is assigned the overflow of the operation.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="addi-add-immediate"><a class="header" href="#addi-add-immediate"><code>ADDI</code>: Add immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Adds a register and an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB + imm;</code></td></tr>
<tr><td>Syntax</td><td><code>addi $rA, $rB, immediate</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> is assigned the overflow of the operation.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="and-and"><a class="header" href="#and-and"><code>AND</code>: AND</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Bitwise ANDs two registers.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB &amp; $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>and $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="andi-and-immediate"><a class="header" href="#andi-and-immediate"><code>ANDI</code>: AND immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Bitwise ANDs a register and an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB &amp; imm;</code></td></tr>
<tr><td>Syntax</td><td><code>andi $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>imm</code> is extended to 64 bits, with the high 52 bits set to <code>0</code>.</p>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="div-divide"><a class="header" href="#div-divide"><code>DIV</code>: Divide</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Divides two registers.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB // $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>div $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p>If <code>$rC == 0</code>, <code>$rA</code> is cleared and <code>$err</code> is set to <code>true</code>.</p>
<p>Otherwise, <code>$err</code> is cleared.</p>
<p><code>$of</code> is cleared.</p>
<h3 id="divi-divide-immediate"><a class="header" href="#divi-divide-immediate"><code>DIVI</code>: Divide immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Divides a register and an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB // imm;</code></td></tr>
<tr><td>Syntax</td><td><code>divi $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p>If <code>imm == 0</code>, <code>$rA</code> is cleared and <code>$err</code> is set to <code>true</code>.</p>
<p>Otherwise, <code>$err</code> is cleared.</p>
<p><code>$of</code> is cleared.</p>
<h3 id="eq-equals"><a class="header" href="#eq-equals"><code>EQ</code>: Equals</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Compares two registers for equality.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB == $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>eq $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="exp-exponentiate"><a class="header" href="#exp-exponentiate"><code>EXP</code>: Exponentiate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Raises one register to the power of another.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB ** $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>exp $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p>If the result cannot fit in 8 bytes, <code>$of</code> is set to <code>1</code> and <code>$rA</code> is instead set to <code>0</code>, otherwise <code>$of</code> is cleared.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="expi-exponentiate-immediate"><a class="header" href="#expi-exponentiate-immediate"><code>EXPI</code>: Exponentiate immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Raises one register to the power of an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB ** imm;</code></td></tr>
<tr><td>Syntax</td><td><code>expi $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p>If the result cannot fit in 8 bytes, <code>$of</code> is set to <code>1</code> and <code>$rA</code> is instead set to <code>0</code>, otherwise <code>$of</code> is cleared.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="gt-greater-than"><a class="header" href="#gt-greater-than"><code>GT</code>: Greater than</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Compares two registers for greater-than.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB &gt; $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>gt $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="lt-less-than"><a class="header" href="#lt-less-than"><code>LT</code>: Less than</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Compares two registers for less-than.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB &lt; $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>lt $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="mlog-math-logarithm"><a class="header" href="#mlog-math-logarithm"><code>MLOG</code>: Math logarithm</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>The (integer) logarithm base <code>$rC</code> of <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>$rA = math.floor(math.log($rB, $rC));</code></td></tr>
<tr><td>Syntax</td><td><code>mlog $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p>If <code>$rB == 0</code>, both <code>$rA</code> and <code>$of</code> are cleared and <code>$err</code> is set to <code>true</code>.</p>
<p>If <code>$rC &lt;= 1</code>, both <code>$rA</code> and <code>$of</code> are cleared and <code>$err</code> is set to <code>true</code>.</p>
<p>Otherwise, <code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="mod-modulus"><a class="header" href="#mod-modulus"><code>MOD</code>: Modulus</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Modulo remainder of two registers.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB % $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>mod $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p>If <code>$rC == 0</code>, both <code>$rA</code> and <code>$of</code> are cleared and <code>$err</code> is set to <code>true</code>.</p>
<p>Otherwise, <code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="modi-modulus-immediate"><a class="header" href="#modi-modulus-immediate"><code>MODI</code>: Modulus immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Modulo remainder of a register and an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB % imm;</code></td></tr>
<tr><td>Syntax</td><td><code>modi $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p>If <code>imm == 0</code>, both <code>$rA</code> and <code>$of</code> are cleared and <code>$err</code> is set to <code>true</code>.</p>
<p>Otherwise, <code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="move-move"><a class="header" href="#move-move"><code>MOVE</code>: Move</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Copy from one register to another.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB;</code></td></tr>
<tr><td>Syntax</td><td><code>move $rA, $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="movi-move-immediate"><a class="header" href="#movi-move-immediate"><code>MOVI</code>: Move immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Copy an immediate value into a register.</td></tr>
<tr><td>Operation</td><td><code>$rA = imm;</code></td></tr>
<tr><td>Syntax</td><td><code>movi $rA, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA i i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="mroo-math-root"><a class="header" href="#mroo-math-root"><code>MROO</code>: Math root</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>The (integer) <code>$rCth</code> root of <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>$rA = math.floor(math.root($rB, $rC));</code></td></tr>
<tr><td>Syntax</td><td><code>mroo $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p>If <code>$rC == 0</code>, both <code>$rA</code> and <code>$of</code> are cleared and <code>$err</code> is set to <code>true</code>.</p>
<p>Otherwise, <code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="mul-multiply"><a class="header" href="#mul-multiply"><code>MUL</code>: Multiply</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Multiplies two registers.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB * $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>mul $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> is assigned the overflow of the operation.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="muli-multiply-immediate"><a class="header" href="#muli-multiply-immediate"><code>MULI</code>: Multiply immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Multiplies a register and an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB * imm;</code></td></tr>
<tr><td>Syntax</td><td><code>mul $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> is assigned the overflow of the operation.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="mldv-fused-multiply-divide"><a class="header" href="#mldv-fused-multiply-divide"><code>MLDV</code>: Fused multiply-divide</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Multiplies two registers with arbitrary precision, then divides by a third register.</td></tr>
<tr><td>Operation</td><td><code>a = (b * c) / d;</code></td></tr>
<tr><td>Syntax</td><td><code>mldv $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td>Division by zero is treated as division by <code>1 &lt;&lt; 64</code> instead.</td></tr>
</tbody></table>
</div>
<p>If the divisor (<code>$rD</code>) is zero, then instead the value is divided by <code>1 &lt;&lt; 64</code>. This returns the higher half of the 128-bit multiplication result. This operation never overflows.</p>
<p>If the result of after the division doesn't fit into a register, <code>$of</code> is assigned the overflow of the operation. Otherwise, <code>$of</code> is cleared.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="noop-no-operation"><a class="header" href="#noop-no-operation"><code>NOOP</code>: No operation</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Performs no operation.</td></tr>
<tr><td>Operation</td><td></td></tr>
<tr><td>Syntax</td><td><code>noop</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 - - - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="not-invert"><a class="header" href="#not-invert"><code>NOT</code>: Invert</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Bitwise NOT a register.</td></tr>
<tr><td>Operation</td><td><code>$rA = ~$rB;</code></td></tr>
<tr><td>Syntax</td><td><code>not $rA, $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="or-or"><a class="header" href="#or-or"><code>OR</code>: OR</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Bitwise ORs two registers.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB \| $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>or $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="ori-or-immediate"><a class="header" href="#ori-or-immediate"><code>ORI</code>: OR immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Bitwise ORs a register and an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB \| imm;</code></td></tr>
<tr><td>Syntax</td><td><code>ori $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>imm</code> is extended to 64 bits, with the high 52 bits set to <code>0</code>.</p>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="sll-shift-left-logical"><a class="header" href="#sll-shift-left-logical"><code>SLL</code>: Shift left logical</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Left shifts a register by a register.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB &lt;&lt; $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>sll $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td>Zeroes are shifted in.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="slli-shift-left-logical-immediate"><a class="header" href="#slli-shift-left-logical-immediate"><code>SLLI</code>: Shift left logical immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Left shifts a register by an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB &lt;&lt; imm;</code></td></tr>
<tr><td>Syntax</td><td><code>slli $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td>Zeroes are shifted in.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="srl-shift-right-logical"><a class="header" href="#srl-shift-right-logical"><code>SRL</code>: Shift right logical</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Right shifts a register by a register.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB &gt;&gt; $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>srl $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td>Zeroes are shifted in.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="srli-shift-right-logical-immediate"><a class="header" href="#srli-shift-right-logical-immediate"><code>SRLI</code>: Shift right logical immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Right shifts a register by an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB &gt;&gt; imm;</code></td></tr>
<tr><td>Syntax</td><td><code>srli $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td>Zeroes are shifted in.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="sub-subtract"><a class="header" href="#sub-subtract"><code>SUB</code>: Subtract</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Subtracts two registers.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB - $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>sub $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> is assigned the underflow of the operation, as though <code>$of</code> is the high byte of a 128-bit register.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="subi-subtract-immediate"><a class="header" href="#subi-subtract-immediate"><code>SUBI</code>: Subtract immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Subtracts a register and an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB - imm;</code></td></tr>
<tr><td>Syntax</td><td><code>subi $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> is assigned the underflow of the operation, as though <code>$of</code> is the high byte of a 128-bit register.</p>
<p><code>$err</code> is cleared.</p>
<h3 id="wdcm-128-bit-integer-comparison"><a class="header" href="#wdcm-128-bit-integer-comparison"><code>WDCM</code>: 128-bit integer comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Compare or examine two 128-bit integers using selected mode</td></tr>
<tr><td>Operation</td><td><code>b = mem[$rB,16];</code><br><code>c = indirect?mem[$rC,16]:$rC;</code><br><code>$rA = cmp_op(b,c);</code></td></tr>
<tr><td>Syntax</td><td><code>wdcm $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>The six-bit immediate value is used to select operating mode, as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Bits</th><th>Short name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>...XXX</code></td><td><code>mode</code></td><td>Compare mode selection</td></tr>
<tr><td><code>.XX...</code></td><td><code>reserved</code></td><td>Reserved and must be zero</td></tr>
<tr><td><code>X.....</code></td><td><code>indirect</code></td><td>Is rhs operand (<code>$rC</code>) indirect or not</td></tr>
</tbody></table>
</div>
<p>Then the actual operation that's performed:</p>
<div class="table-wrapper"><table><thead><tr><th><code>mode</code></th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td><code>eq</code></td><td>Equality (<code>==</code>)</td></tr>
<tr><td>1</td><td><code>ne</code></td><td>Inequality (<code>!=</code>)</td></tr>
<tr><td>2</td><td><code>lt</code></td><td>Less than (<code>&lt;</code>)</td></tr>
<tr><td>3</td><td><code>gt</code></td><td>Greater than (<code>&gt;</code>)</td></tr>
<tr><td>4</td><td><code>lte</code></td><td>Less than or equals (<code>&lt;=</code>)</td></tr>
<tr><td>5</td><td><code>gte</code></td><td>Greater than or equals (<code>&gt;=</code>)</td></tr>
<tr><td>6</td><td><code>lzc</code></td><td>Leading zero count the lhs argument (<code>lzcnt</code>). Discards rhs.</td></tr>
<tr><td>7</td><td>-</td><td>Reserved and must not be used</td></tr>
</tbody></table>
</div>
<p>The leading zero count can be used to compute rounded-down log2 of a number using the following formula <code>TOTAL_BITS - 1 - lzc(n)</code>. Note that <code>log2(0)</code> is undefined, and will lead to integer overflow with this method.</p>
<p>Clears <code>$of</code> and <code>$err</code>.</p>
<p>Panic if:</p>
<ul>
<li>A reserved compare mode is given</li>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>indirect == 1</code> and <code>$rC + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wqcm-256-bit-integer-comparison"><a class="header" href="#wqcm-256-bit-integer-comparison"><code>WQCM</code>: 256-bit integer comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Compare or examine two 256-bit integers using selected mode</td></tr>
<tr><td>Operation</td><td><code>b = mem[$rB,32];</code><br><code>c = indirect?mem[$rC,32]:$rC;</code><br><code>$rA = cmp_op(b,c);</code></td></tr>
<tr><td>Syntax</td><td><code>wqcm $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>The immediate value is interpreted identically to <code>WDCM</code>.</p>
<p>Clears <code>$of</code> and <code>$err</code>.</p>
<p>Panic if:</p>
<ul>
<li>A reserved compare mode is given</li>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>indirect == 1</code> and <code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wdop-misc-128-bit-integer-operations"><a class="header" href="#wdop-misc-128-bit-integer-operations"><code>WDOP</code>: Misc 128-bit integer operations</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Perform an ALU operation on two 128-bit integers</td></tr>
<tr><td>Operation</td><td><code>b = mem[$rB,16];</code><br><code>c = indirect?mem[$rC,16]:$rC;</code><br><code>mem[$rA,16] = op(b,c);</code></td></tr>
<tr><td>Syntax</td><td><code>wdop $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>The six-bit immediate value is used to select operating mode, as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Bits</th><th>Short name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>...XXX</code></td><td><code>op</code></td><td>Operation selection, see below</td></tr>
<tr><td><code>.XX...</code></td><td><code>reserved</code></td><td>Reserved and must be zero</td></tr>
<tr><td><code>X.....</code></td><td><code>indirect</code></td><td>Is rhs operand (<code>$rC</code>) indirect or not</td></tr>
</tbody></table>
</div>
<p>Then the actual operation that's performed:</p>
<div class="table-wrapper"><table><thead><tr><th><code>op</code></th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td><code>add</code></td><td>Add</td></tr>
<tr><td>1</td><td><code>sub</code></td><td>Subtract</td></tr>
<tr><td>2</td><td><code>not</code></td><td>Invert bits (discards rhs)</td></tr>
<tr><td>3</td><td><code>or</code></td><td>Bitwise or</td></tr>
<tr><td>4</td><td><code>xor</code></td><td>Bitwise exclusive or</td></tr>
<tr><td>5</td><td><code>and</code></td><td>Bitwise and</td></tr>
<tr><td>6</td><td><code>shl</code></td><td>Shift left (logical)</td></tr>
<tr><td>7</td><td><code>shr</code></td><td>Shift right (logical)</td></tr>
</tbody></table>
</div>
<p>Operations behave <code>$of</code> and <code>$err</code> similarly to their 64-bit counterparts, except that <code>$of</code> is set to <code>1</code> instead of the overflowing part.</p>
<p>Panic if:</p>
<ul>
<li>Reserved bits of the immediate are set</li>
<li>The memory range <code>MEM[$rA, 16]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>indirect == 1</code> and <code>$rC + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wqop-misc-256-bit-integer-operations"><a class="header" href="#wqop-misc-256-bit-integer-operations"><code>WQOP</code>: Misc 256-bit integer operations</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Perform an ALU operation on two 256-bit integers</td></tr>
<tr><td>Operation</td><td><code>b = mem[$rB,32];</code><br><code>c = indirect?mem[$rC,32]:$rC;</code><br><code>mem[$rA,32] = op(b,c);</code></td></tr>
<tr><td>Syntax</td><td><code>wqop $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>The immediate value is interpreted identically to <code>WDOP</code>.</p>
<p>Operations behave <code>$of</code> and <code>$err</code> similarly to their 64-bit counterparts.</p>
<p>Panic if:</p>
<ul>
<li>Reserved bits of the immediate are set</li>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>indirect == 1</code> and <code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wdml-multiply-128-bit-integers"><a class="header" href="#wdml-multiply-128-bit-integers"><code>WDML</code>: Multiply 128-bit integers</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Perform integer multiplication operation on two 128-bit integers.</td></tr>
<tr><td>Operation</td><td><code>b=indirect0?mem[$rB,16]:$rB;</code><br><code>c=indirect1?mem[$rC,16]:$rC;</code><br><code>mem[$rA,16]=b*c;</code></td></tr>
<tr><td>Syntax</td><td><code>wdml $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>The six-bit immediate value is used to select operating mode, as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Bits</th><th>Short name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>..XXXX</code></td><td><code>reserved</code></td><td>Reserved and must be zero</td></tr>
<tr><td><code>.X....</code></td><td><code>indirect0</code></td><td>Is lhs operand (<code>$rB</code>) indirect or not</td></tr>
<tr><td><code>X.....</code></td><td><code>indirect1</code></td><td>Is rhs operand (<code>$rC</code>) indirect or not</td></tr>
</tbody></table>
</div>
<p><code>$of</code> is set to <code>1</code> in case of overflow, and cleared otherwise.</p>
<p><code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>Reserved bits of the immediate are set</li>
<li>The memory range <code>MEM[$rA, 16]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>indirect0 == 1</code> and <code>$rB + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>indirect1 == 1</code> and <code>$rC + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wqml-multiply-256-bit-integers"><a class="header" href="#wqml-multiply-256-bit-integers"><code>WQML</code>: Multiply 256-bit integers</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Perform integer multiplication operation on two 256-bit integers.</td></tr>
<tr><td>Operation</td><td><code>b=indirect0?mem[$rB,32]:$rB;</code><br><code>c=indirect1?mem[$rC,32]:$rC;</code><br><code>mem[$rA,32]=b*c;</code></td></tr>
<tr><td>Syntax</td><td><code>wqml $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>The immediate value is interpreted identically to <code>WDML</code>.</p>
<p><code>$of</code> is set to <code>1</code> in case of overflow, and cleared otherwise.</p>
<p><code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>Reserved bits of the immediate are set</li>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>indirect0 == 1</code> and <code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>indirect1 == 1</code> and <code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wddv-128-bit-integer-division"><a class="header" href="#wddv-128-bit-integer-division"><code>WDDV</code>: 128-bit integer division</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Divide a 128-bit integer by another.</td></tr>
<tr><td>Operation</td><td><code>b = mem[$rB,16];</code><br><code>c = indirect?mem[$rC,16]:$rC;</code><br><code>mem[$rA,16] = b / c;</code></td></tr>
<tr><td>Syntax</td><td><code>wddv $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>The six-bit immediate value is used to select operating mode, as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Bits</th><th>Short name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>.XXXXX</code></td><td><code>reserved</code></td><td>Reserved and must be zero</td></tr>
<tr><td><code>X.....</code></td><td><code>indirect</code></td><td>Is rhs operand (<code>$rC</code>) indirect or not</td></tr>
</tbody></table>
</div>
<p><code>$of</code> is cleared.</p>
<p>If the rhs operand is zero, <code>MEM[$rA, 16]</code> is cleared and <code>$err</code> is set to <code>true</code>. Otherwise, <code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>Reserved bits of the immediate are set</li>
<li>The memory range <code>MEM[$rA, 16]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>indirect == 1</code> and <code>$rC + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wqdv-256-bit-integer-division"><a class="header" href="#wqdv-256-bit-integer-division"><code>WQDV</code>: 256-bit integer division</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Divide a 256-bit integer by another.</td></tr>
<tr><td>Operation</td><td><code>b = mem[$rB,32];</code><br><code>c = indirect?mem[$rC,32]:$rC;</code><br><code>mem[$rA,32] = b / c;</code></td></tr>
<tr><td>Syntax</td><td><code>wqdv $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>The immediate value is interpreted identically to <code>WDDV</code>.</p>
<p><code>$of</code> is cleared.</p>
<p>If the rhs operand is zero, <code>MEM[$rA, 32]</code> is cleared and <code>$err</code> is set to <code>true</code>. Otherwise, <code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>Reserved bits of the immediate are set</li>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>indirect == 1</code> and <code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wdmd-128-bit-integer-fused-multiply-divide"><a class="header" href="#wdmd-128-bit-integer-fused-multiply-divide"><code>WDMD</code>: 128-bit integer fused multiply-divide</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Combined multiply-divide of 128-bit integers with arbitrary precision.</td></tr>
<tr><td>Operation</td><td><code>b=mem[$rB,16];</code><br><code>c=mem[$rC,16];</code><br><code>d=mem[$rD,16];</code><br><code>mem[$rA,16]=(b * c) / d;</code></td></tr>
<tr><td>Syntax</td><td><code>wdmd $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td>Division by zero is treated as division by <code>1 &lt;&lt; 128</code> instead.</td></tr>
</tbody></table>
</div>
<p>If the divisor <code>MEM[$rA, 16]</code> is zero, then instead the value is divided by <code>1 &lt;&lt; 128</code>. This returns the higher half of the 256-bit multiplication result.</p>
<p>If the result of after the division is larger than operand size, <code>$of</code> is set to one. Otherwise, <code>$of</code> is cleared.</p>
<p><code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>The memory range <code>MEM[$rA, 16]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rD + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wqmd-256-bit-integer-fused-multiply-divide"><a class="header" href="#wqmd-256-bit-integer-fused-multiply-divide"><code>WQMD</code>: 256-bit integer fused multiply-divide</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Combined multiply-divide of 256-bit integers with arbitrary precision.</td></tr>
<tr><td>Operation</td><td><code>b=mem[$rB,32];</code><br><code>c=mem[$rC,32];</code><br><code>d=mem[$rD,32];</code><br><code>mem[$rA,32]=(b * c) / d;</code></td></tr>
<tr><td>Syntax</td><td><code>wqmd $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td>Division by zero is treated as division by <code>1 &lt;&lt; 256</code> instead.</td></tr>
</tbody></table>
</div>
<p>If the divisor <code>MEM[$rA, 32]</code> is zero, then instead the value is divided by <code>1 &lt;&lt; 256</code>. This returns the higher half of the 512-bit multiplication result.</p>
<p>If the result of after the division is larger than operand size, <code>$of</code> is set to one. Otherwise, <code>$of</code> is cleared.</p>
<p><code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rD + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wdam-modular-128-bit-integer-addition"><a class="header" href="#wdam-modular-128-bit-integer-addition"><code>WDAM</code>: Modular 128-bit integer addition</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Add two 128-bit integers and compute modulo remainder with arbitrary precision.</td></tr>
<tr><td>Operation</td><td><code>b=mem[$rB,16];</code><br><code>c=mem[$rC,16];</code><br><code>d=mem[$rD,16];</code><br><code>mem[$rA,16] = (b+c)%d;</code></td></tr>
<tr><td>Syntax</td><td><code>wdam $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p><code>$of</code> is cleared.</p>
<p>If the rhs operand is zero, <code>MEM[$rA, 16]</code> is cleared and <code>$err</code> is set to <code>true</code>. Otherwise, <code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>The memory range <code>MEM[$rA, 16]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rD + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wqam-modular-256-bit-integer-addition"><a class="header" href="#wqam-modular-256-bit-integer-addition"><code>WQAM</code>: Modular 256-bit integer addition</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Add two 256-bit integers and compute modulo remainder with arbitrary precision.</td></tr>
<tr><td>Operation</td><td><code>b=mem[$rB,32];</code><br><code>c=mem[$rC,32];</code><br><code>d=mem[$rD,32];</code><br><code>mem[$rA,32] = (b+c)%d;</code></td></tr>
<tr><td>Syntax</td><td><code>wqam $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p><code>$of</code> is cleared.</p>
<p>If the rhs operand is zero, <code>MEM[$rA, 32]</code> is cleared and <code>$err</code> is set to <code>true</code>. Otherwise, <code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rD + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wdmm-modular-128-bit-integer-multiplication"><a class="header" href="#wdmm-modular-128-bit-integer-multiplication"><code>WDMM</code>: Modular 128-bit integer multiplication</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Multiply two 128-bit integers and compute modulo remainder with arbitrary precision.</td></tr>
<tr><td>Operation</td><td><code>b=mem[$rB,16];</code><br><code>c=mem[$rC,16];</code><br><code>d=mem[$rD,16];</code><br><code>mem[$rA,16] = (b*c)%d;</code></td></tr>
<tr><td>Syntax</td><td><code>wdmm $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p><code>$of</code> is cleared.</p>
<p>If the rhs operand is zero, <code>MEM[$rA, 16]</code> is cleared and <code>$err</code> is set to <code>true</code>. Otherwise, <code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>The memory range <code>MEM[$rA, 16]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rD + 16</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="wqmm-modular-256-bit-integer-multiplication"><a class="header" href="#wqmm-modular-256-bit-integer-multiplication"><code>WQMM</code>: Modular 256-bit integer multiplication</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Multiply two 256-bit integers and compute modulo remainder with arbitrary precision.</td></tr>
<tr><td>Operation</td><td><code>b=mem[$rB,32];</code><br><code>c=mem[$rC,32];</code><br><code>d=mem[$rD,32];</code><br><code>mem[$rA,32] = (b*c)%d;</code></td></tr>
<tr><td>Syntax</td><td><code>wqmm $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p><code>$of</code> is cleared.</p>
<p>If the rhs operand is zero, <code>MEM[$rA, 32]</code> is cleared and <code>$err</code> is set to <code>true</code>. Otherwise, <code>$err</code> is cleared.</p>
<p>Panic if:</p>
<ul>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rD + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="xor-xor"><a class="header" href="#xor-xor"><code>XOR</code>: XOR</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Bitwise XORs two registers.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB ^ $rC;</code></td></tr>
<tr><td>Syntax</td><td><code>xor $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h3 id="xori-xor-immediate"><a class="header" href="#xori-xor-immediate"><code>XORI</code>: XOR immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Bitwise XORs a register and an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$rA = $rB ^ imm;</code></td></tr>
<tr><td>Syntax</td><td><code>xori $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<p><code>$of</code> and <code>$err</code> are cleared.</p>
<h2 id="control-flow-instructions"><a class="header" href="#control-flow-instructions">Control Flow Instructions</a></h2>
<h3 id="jmp-jump"><a class="header" href="#jmp-jump"><code>JMP</code>: Jump</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jumps to the code instruction offset by a register.</td></tr>
<tr><td>Operation</td><td><code>$pc = $is + $rA * 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jmp $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA - - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$is + $rA * 4 &gt; VM_MAX_RAM - 1</code></li>
</ul>
<h3 id="ji-jump-immediate"><a class="header" href="#ji-jump-immediate"><code>JI</code>: Jump immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jumps to the code instruction offset by <code>imm</code>.</td></tr>
<tr><td>Operation</td><td><code>$pc = $is + imm * 4;</code></td></tr>
<tr><td>Syntax</td><td><code>ji imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 i i i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$is + imm * 4 &gt; VM_MAX_RAM - 1</code></li>
</ul>
<h3 id="jne-jump-if-not-equal"><a class="header" href="#jne-jump-if-not-equal"><code>JNE</code>: Jump if not equal</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump to the code instruction offset by a register if <code>$rA</code> is not equal to <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>if $rA != $rB:</code><br><code>$pc = $is + $rC * 4;</code><br><code>else:</code><br><code>$pc += 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jne $rA $rB $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$is + $rC * 4 &gt; VM_MAX_RAM - 1</code> and the jump would be performed (i.e. <code>$rA != $rB</code>)</li>
</ul>
<h3 id="jnei-jump-if-not-equal-immediate"><a class="header" href="#jnei-jump-if-not-equal-immediate"><code>JNEI</code>: Jump if not equal immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump to the code instruction offset by <code>imm</code> if <code>$rA</code> is not equal to <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>if $rA != $rB:</code><br><code>$pc = $is + imm * 4;</code><br><code>else:</code><br><code>$pc += 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jnei $rA $rB imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$is + imm * 4 &gt; VM_MAX_RAM - 1</code> and the jump would be performed (i.e. <code>$rA != $rB</code>)</li>
</ul>
<h3 id="jnzi-jump-if-not-zero-immediate"><a class="header" href="#jnzi-jump-if-not-zero-immediate"><code>JNZI</code>: Jump if not zero immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump to the code instruction offset by <code>imm</code> if <code>$rA</code> is not equal to <code>$zero</code>.</td></tr>
<tr><td>Operation</td><td><code>if $rA != $zero:</code><br><code>$pc = $is + imm * 4;</code><br><code>else:</code><br><code>$pc += 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jnzi $rA imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA i i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$is + imm * 4 &gt; VM_MAX_RAM - 1</code>and the jump would be performed (i.e. <code>$rA != $zero</code>)</li>
</ul>
<h3 id="jmpb-jump-relative-backwards"><a class="header" href="#jmpb-jump-relative-backwards"><code>JMPB</code>: Jump relative backwards</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump <code>$rA + imm</code> instructions backwards.</td></tr>
<tr><td>Operation</td><td><code>$pc -= ($rA + imm + 1) * 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jmpb $rA imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA i i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$pc - ($rA + imm + 1) * 4 &lt; 0</code></li>
</ul>
<h3 id="jmpf-jump-relative-forwards"><a class="header" href="#jmpf-jump-relative-forwards"><code>JMPF</code>: Jump relative forwards</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump <code>$rA + imm</code> instructions forwards</td></tr>
<tr><td>Operation</td><td><code>$pc += ($rA + imm + 1) * 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jmpf $rA imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA i i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$pc + ($rA + imm + 1) * 4 &gt; VM_MAX_RAM - 1</code></li>
</ul>
<h3 id="jnzb-jump-if-not-zero-relative-backwards"><a class="header" href="#jnzb-jump-if-not-zero-relative-backwards"><code>JNZB</code>: Jump if not zero relative backwards</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump <code>$rB + imm</code> instructions backwards if <code>$rA != $zero</code>.</td></tr>
<tr><td>Operation</td><td><code>if $rA != $zero:</code><br><code>$pc -= ($rB + imm + 1) * 4;</code><br><code>else:</code><br><code>$pc += 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jnzb $rA $rB imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$pc - ($rB + imm + 1) * 4 &lt; 0</code></li>
</ul>
<h3 id="jnzf-jump-if-not-zero-relative-forwards"><a class="header" href="#jnzf-jump-if-not-zero-relative-forwards"><code>JNZF</code>: Jump if not zero relative forwards</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump <code>$rB + imm</code> instructions forwards if <code>$rA != $zero</code>.</td></tr>
<tr><td>Operation</td><td><code>if $rA != $zero:</code><br><code>$pc += ($rB + imm + 1) * 4;</code><br><code>else:</code><br><code>$pc += 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jnzf $rA $rB imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$pc + ($rB + imm + 1) * 4 &gt; VM_MAX_RAM - 1</code></li>
</ul>
<h3 id="jneb-jump-if-not-equal-relative-backwards"><a class="header" href="#jneb-jump-if-not-equal-relative-backwards"><code>JNEB</code>: Jump if not equal relative backwards</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump <code>$rC + imm</code> instructions backwards if <code>$rA != $rB</code>.</td></tr>
<tr><td>Operation</td><td><code>if $rA != $rB:</code><br><code>$pc -= ($rC + imm + 1) * 4;</code><br><code>else:</code><br><code>$pc += 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jneb $rA $rB $rC imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$pc - ($rC + imm + 1) * 4 &lt; 0</code></li>
</ul>
<h3 id="jnef-jump-if-not-equal-relative-forwards"><a class="header" href="#jnef-jump-if-not-equal-relative-forwards"><code>JNEF</code>: Jump if not equal relative forwards</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Jump <code>$rC + imm</code> instructions forwards if <code>$rA != $rB</code>.</td></tr>
<tr><td>Operation</td><td><code>if $rA != $rB:</code><br><code>$pc += ($rC + imm + 1) * 4;</code><br><code>else:</code><br><code>$pc += 4;</code></td></tr>
<tr><td>Syntax</td><td><code>jnef $rA $rB $rC imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$pc + ($rC + imm + 1) * 4 &gt; VM_MAX_RAM - 1</code></li>
</ul>
<h3 id="ret-return-from-context"><a class="header" href="#ret-return-from-context"><code>RET</code>: Return from context</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Returns from <a href="fuel-vm/./index.html#contexts">context</a> with value <code>$rA</code>.</td></tr>
<tr><td>Operation</td><td><code>return($rA);</code></td></tr>
<tr><td>Syntax</td><td><code>ret $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA - - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.Return</code></td></tr>
<tr><td><code>id</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>val</code></td><td><code>uint64</code></td><td>Value of register <code>$rA</code>.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<p>If current context is external, append an additional receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.ScriptResult</code></td></tr>
<tr><td><code>result</code></td><td><code>uint64</code></td><td><code>0</code></td></tr>
<tr><td><code>gas_used</code></td><td><code>uint64</code></td><td>Gas consumed by the script.</td></tr>
</tbody></table>
</div>
<p>If current context is external, cease VM execution and return <code>$rA</code>.</p>
<p>Returns from contract call, popping the call frame. Before popping perform the following operations.</p>
<p>Return the unused forwarded gas to the caller:</p>
<ol>
<li><code>$cgas = $cgas + $fp-&gt;$cgas</code> (add remaining context gas from previous context to current remaining context gas)</li>
</ol>
<p>Set the return value:</p>
<ol>
<li><code>$ret = $rA</code></li>
<li><code>$retl = 0</code></li>
</ol>
<p>Then pop the call frame and restore all registers <em>except</em> <code>$ggas</code>, <code>$cgas</code>, <code>$ret</code>, <code>$retl</code> and <code>$hp</code>. Afterwards, set the following registers:</p>
<ol>
<li><code>$pc = $pc + 4</code> (advance program counter from where we called)</li>
</ol>
<h2 id="memory-instructions"><a class="header" href="#memory-instructions">Memory Instructions</a></h2>
<p>All these instructions advance the program counter <code>$pc</code> by <code>4</code> after performing their operation.</p>
<h3 id="aloc-allocate-memory"><a class="header" href="#aloc-allocate-memory"><code>ALOC</code>: Allocate memory</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Allocate a number of bytes from the heap.</td></tr>
<tr><td>Operation</td><td><code>$hp = $hp - $rA;</code></td></tr>
<tr><td>Syntax</td><td><code>aloc $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA - - -</code></td></tr>
<tr><td>Notes</td><td>Newly allocated memory is zeroed.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$hp - $rA</code> underflows</li>
<li><code>$hp - $rA &lt; $sp</code></li>
</ul>
<h3 id="cfe-extend-call-frame"><a class="header" href="#cfe-extend-call-frame"><code>CFE</code>: Extend call frame</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Extend the current call frame's stack.</td></tr>
<tr><td>Operation</td><td><code>$sp = $sp + $rA</code></td></tr>
<tr><td>Syntax</td><td><code>cfe $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA - - -</code></td></tr>
<tr><td>Notes</td><td>Does not initialize memory.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$sp + $rA</code> overflows</li>
<li><code>$sp + $rA &gt; $hp</code></li>
</ul>
<h3 id="cfei-extend-call-frame-immediate"><a class="header" href="#cfei-extend-call-frame-immediate"><code>CFEI</code>: Extend call frame immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Extend the current call frame's stack by an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$sp = $sp + imm</code></td></tr>
<tr><td>Syntax</td><td><code>cfei imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 i i i i</code></td></tr>
<tr><td>Notes</td><td>Does not initialize memory.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$sp + imm</code> overflows</li>
<li><code>$sp + imm &gt; $hp</code></li>
</ul>
<h3 id="cfs-shrink-call-frame"><a class="header" href="#cfs-shrink-call-frame"><code>CFS</code>: Shrink call frame</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Shrink the current call frame's stack.</td></tr>
<tr><td>Operation</td><td><code>$sp = $sp - $rA</code></td></tr>
<tr><td>Syntax</td><td><code>cfs $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 $rA - - -</code></td></tr>
<tr><td>Notes</td><td>Does not clear memory.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$sp - $rA</code> underflows</li>
<li><code>$sp - $rA &lt; $ssp</code></li>
</ul>
<h3 id="cfsi-shrink-call-frame-immediate"><a class="header" href="#cfsi-shrink-call-frame-immediate"><code>CFSI</code>: Shrink call frame immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Shrink the current call frame's stack by an immediate value.</td></tr>
<tr><td>Operation</td><td><code>$sp = $sp - imm</code></td></tr>
<tr><td>Syntax</td><td><code>cfsi imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 i i i i</code></td></tr>
<tr><td>Notes</td><td>Does not clear memory.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$sp - imm</code> underflows</li>
<li><code>$sp - imm &lt; $ssp</code></li>
</ul>
<h3 id="lb-load-byte"><a class="header" href="#lb-load-byte"><code>LB</code>: Load byte</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>A byte is loaded from the specified address offset by <code>imm</code>.</td></tr>
<tr><td>Operation</td><td><code>$rA = MEM[$rB + imm, 1];</code></td></tr>
<tr><td>Syntax</td><td><code>lb $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB + imm + 1</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="lw-load-word"><a class="header" href="#lw-load-word"><code>LW</code>: Load word</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>A word is loaded from the specified address offset by <code>imm</code>.</td></tr>
<tr><td>Operation</td><td><code>$rA = MEM[$rB + (imm * 8), 8];</code></td></tr>
<tr><td>Syntax</td><td><code>lw $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB + (imm * 8) + 8</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="mcl-memory-clear"><a class="header" href="#mcl-memory-clear"><code>MCL</code>: Memory clear</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Clear bytes in memory.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, $rB] = 0;</code></td></tr>
<tr><td>Syntax</td><td><code>mcl $rA, $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + $rB</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, $rB]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h3 id="mcli-memory-clear-immediate"><a class="header" href="#mcli-memory-clear-immediate"><code>MCLI</code>: Memory clear immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Clear bytes in memory.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, imm] = 0;</code></td></tr>
<tr><td>Syntax</td><td><code>mcli $rA, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA i i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + imm</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, imm]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h3 id="mcp-memory-copy"><a class="header" href="#mcp-memory-copy"><code>MCP</code>: Memory copy</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Copy bytes in memory.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, $rC] = MEM[$rB, $rC];</code></td></tr>
<tr><td>Syntax</td><td><code>mcp $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + $rC</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + $rC</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory ranges <code>MEM[$rA, $rC]</code> and <code>MEM[$rB, $rC]</code> overlap</li>
<li>The memory range <code>MEM[$rA, $rC]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h3 id="mcpi-memory-copy-immediate"><a class="header" href="#mcpi-memory-copy-immediate"><code>MCPI</code>: Memory copy immediate</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Copy bytes in memory.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, imm] = MEM[$rB, imm];</code></td></tr>
<tr><td>Syntax</td><td><code>mcpi $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB imm imm</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + imm</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + imm</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory ranges <code>MEM[$rA, imm]</code> and <code>MEM[$rB, imm]</code> overlap</li>
<li>The memory range <code>MEM[$rA, imm]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h3 id="meq-memory-equality"><a class="header" href="#meq-memory-equality"><code>MEQ</code>: Memory equality</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Compare bytes in memory.</td></tr>
<tr><td>Operation</td><td><code>$rA = MEM[$rB, $rD] == MEM[$rC, $rD];</code></td></tr>
<tr><td>Syntax</td><td><code>meq $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB + $rD</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + $rD</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="pshh-push-a-set-of-high-registers-to-stack"><a class="header" href="#pshh-push-a-set-of-high-registers-to-stack"><code>PSHH</code>: Push a set of high registers to stack</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Push a set of registers from range 40..64 to the stack in order.</td></tr>
<tr><td>Operation</td><td><code>tmp=$sp;</code><br><code>$sp+=popcnt(imm)*8;</code><br><code>MEM[tmp,$sp]=registers[40..64].mask(imm)</code></td></tr>
<tr><td>Syntax</td><td><code>pshh imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 i i i i</code></td></tr>
<tr><td>Notes</td><td>The immediate value is used as a bitmask for selecting the registers.</td></tr>
</tbody></table>
</div>
<p>The nth bit of the bitmask corresponds to nth entry of the register range. In other words, the most significant (i.e. leftmost) bit of the bitmask corresponds to the highest register index. So for instance bitmask <code>011000000000000000000000</code> pushes the register 61 followed by register 62.</p>
<p>Panic if:</p>
<ul>
<li><code>$sp + popcnt(imm)*8</code> overflows</li>
<li><code>$sp + popcnt(imm)*8 &gt; $hp</code></li>
</ul>
<h3 id="pshl-push-a-set-of-low-registers-to-stack"><a class="header" href="#pshl-push-a-set-of-low-registers-to-stack"><code>PSHL</code>: Push a set of low registers to stack</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Push a set of registers from range 16..40 to the stack in order.</td></tr>
<tr><td>Operation</td><td><code>tmp=$sp;</code><br><code>$sp+=popcnt(imm)*8;</code><br><code>MEM[tmp,$sp]=registers[16..40].mask(imm)</code></td></tr>
<tr><td>Syntax</td><td><code>pshl imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 i i i i</code></td></tr>
<tr><td>Notes</td><td>The immediate value is used as a bitmask for selecting the registers.</td></tr>
</tbody></table>
</div>
<p>The nth bit of the bitmask corresponds to nth entry of the register range. In other words, the most significant (i.e. leftmost) bit of the bitmask corresponds to the highest register index. So for instance bitmask <code>011000000000000000000000</code> pushes the register 37 followed by register 38.</p>
<p>Panic if:</p>
<ul>
<li><code>$sp + popcnt(imm)*8</code> overflows</li>
<li><code>$sp + popcnt(imm)*8 &gt; $hp</code></li>
</ul>
<h3 id="poph-pop-a-set-of-high-registers-from-stack"><a class="header" href="#poph-pop-a-set-of-high-registers-from-stack"><code>POPH</code>: Pop a set of high registers from stack</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Pop to a set of registers from range 40..64 from the stack.</td></tr>
<tr><td>Operation</td><td><code>tmp=$sp-popcnt(imm)*8;</code><br><code>registers[40..64].mask(imm)=MEM[tmp,$sp]</code><br><code>$sp-=tmp;</code></td></tr>
<tr><td>Syntax</td><td><code>poph imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 i i i i</code></td></tr>
<tr><td>Notes</td><td>The immediate value is used as a bitmask for selecting the registers.</td></tr>
</tbody></table>
</div>
<p>The nth bit of the bitmask corresponds to nth entry of the register range. In other words, the most significant (i.e. leftmost) bit of the bitmask corresponds to the highest register index. So for instance bitmask <code>011000000000000000000000</code> pops the register 62 followed by register 61.</p>
<p>Note that the order is reverse from <code>PSHH</code>, so that <code>PSHH a; POPH a</code> returns to the original state.</p>
<p>Panic if:</p>
<ul>
<li><code>$sp - popcnt(imm)*8</code> overflows</li>
<li><code>$sp - popcnt(imm)*8 &lt; $ssp</code></li>
</ul>
<h3 id="popl-pop-a-set-of-low-registers-from-stack"><a class="header" href="#popl-pop-a-set-of-low-registers-from-stack"><code>POPL</code>: Pop a set of low registers from stack</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Pop to a set of registers from range 16..40 from the stack.</td></tr>
<tr><td>Operation</td><td><code>tmp=$sp-popcnt(imm)*8;</code><br><code>registers[16..40].mask(imm)=MEM[tmp,$sp]</code><br><code>$sp-=tmp;</code></td></tr>
<tr><td>Syntax</td><td><code>poph imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 i i i i</code></td></tr>
<tr><td>Notes</td><td>The immediate value is used as a bitmask for selecting the registers.</td></tr>
</tbody></table>
</div>
<p>The nth bit of the bitmask corresponds to nth entry of the register range. In other words, the most significant (i.e. leftmost) bit of the bitmask corresponds to the highest register index. So for instance bitmask <code>011000000000000000000000</code> pops the register 38 followed by register 37.</p>
<p>Note that the order is reverse from <code>PSHL</code>, so that <code>PSHL a; POPL a</code> returns to the original state.</p>
<p>Panic if:</p>
<ul>
<li><code>$sp - popcnt(imm)*8</code> overflows</li>
<li><code>$sp - popcnt(imm)*8 &lt; $ssp</code></li>
</ul>
<h3 id="sb-store-byte"><a class="header" href="#sb-store-byte"><code>SB</code>: Store byte</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>The least significant byte of <code>$rB</code> is stored at the address <code>$rA</code> offset by <code>imm</code>.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA + imm, 1] = $rB[7, 1];</code></td></tr>
<tr><td>Syntax</td><td><code>sb $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + imm + 1</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA + imm, 1]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h3 id="sw-store-word"><a class="header" href="#sw-store-word"><code>SW</code>: Store word</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>The value of <code>$rB</code> is stored at the address <code>$rA</code> offset by <code>imm</code>.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA + (imm * 8), 8] = $rB;</code></td></tr>
<tr><td>Syntax</td><td><code>sw $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + (imm * 8) + 8</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA + (imm * 8), 8]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h2 id="contract-instructions"><a class="header" href="#contract-instructions">Contract Instructions</a></h2>
<p>All these instructions advance the program counter <code>$pc</code> by <code>4</code> after performing their operation, except for <a href="fuel-vm/instruction-set.html#call-call-contract">CALL</a>, <a href="fuel-vm/instruction-set.html#retd-return-from-context-with-data"><code>RETD</code></a> and <a href="fuel-vm/instruction-set.html#rvrt-revert"><code>RVRT</code></a>.</p>
<h3 id="bal-balance-of-contract-id"><a class="header" href="#bal-balance-of-contract-id"><code>BAL</code>: Balance of contract ID</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Set <code>$rA</code> to the balance of asset ID at <code>$rB</code> for contract with ID at <code>$rC</code>.</td></tr>
<tr><td>Operation</td><td><code>$rA = balance(MEM[$rB, 32], MEM[$rC, 32]);</code></td></tr>
<tr><td>Syntax</td><td><code>bal $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Effects</td><td>Balance tree read</td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Where helper <code>balance(asset_id: byte[32], contract_id: byte[32]) -&gt; uint64</code> returns the current balance of <code>asset_id</code> of contract with ID <code>contract_id</code>.</p>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>Contract with ID <code>MEM[$rC, 32]</code> is not in <code>tx.inputs</code></li>
</ul>
<h3 id="bhei-block-height"><a class="header" href="#bhei-block-height"><code>BHEI</code>: Block height</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Get Fuel block height.</td></tr>
<tr><td>Operation</td><td><code>$rA = blockheight();</code></td></tr>
<tr><td>Syntax</td><td><code>bhei $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA - - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
</ul>
<h3 id="bhsh-block-hash"><a class="header" href="#bhsh-block-hash"><code>BHSH</code>: Block hash</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Get block header hash.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, 32] = blockhash($rB);</code></td></tr>
<tr><td>Syntax</td><td><code>bhsh $rA $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<p>Block header hashes for blocks with height greater than or equal to current block height are zero (<code>0x00**32</code>).</p>
<h3 id="burn-burn-existing-coins"><a class="header" href="#burn-burn-existing-coins"><code>BURN</code>: Burn existing coins</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Burn <code>$rA</code> coins of the <code>$rB</code> ID from the current contract.</td></tr>
<tr><td>Operation</td><td><code>burn($rA, $rB);</code></td></tr>
<tr><td>Syntax</td><td><code>burn $rA $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td><code>$rB</code> is a pointer to a 32 byte ID in memory.</td></tr>
</tbody></table>
</div>
<p>The asset ID is constructed using the asset ID construction method.</p>
<p>Panic if:</p>
<ul>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>Balance of asset ID from <code>constructAssetID(MEM[$fp, 32], MEM[$rB, 32])</code> of output with contract ID <code>MEM[$fp, 32]</code> minus <code>$rA</code> underflows</li>
<li><code>$fp == 0</code> (in the script context)</li>
</ul>
<p>For output with contract ID <code>MEM[$fp, 32]</code>, decrease balance of asset ID <code>constructAssetID(MEM[$fp, 32], MEM[$rB, 32])</code> by <code>$rA</code>.</p>
<p>This modifies the <code>balanceRoot</code> field of the appropriate output.</p>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.Burn</code></td></tr>
<tr><td><code>sub_id</code></td><td><code>byte[32]</code></td><td>Asset sub identifier <code>MEM[$rB, $rB + 32]</code>.</td></tr>
<tr><td><code>contract_id</code></td><td><code>byte[32]</code></td><td>Contract ID of the current context.</td></tr>
<tr><td><code>val</code></td><td><code>uint64</code></td><td>Value of register <code>$rA</code>.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<h3 id="call-call-contract"><a class="header" href="#call-call-contract"><code>CALL</code>: Call contract</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Call contract.</td></tr>
<tr><td>Operation</td><td></td></tr>
<tr><td>Syntax</td><td><code>call $rA $rB $rC $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Effects</td><td>External call</td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>There is a <code>balanceOfStart(asset_id: byte[32]) -&gt; uint32</code> helper that returns the memory address of the remaining free balance of <code>asset_id</code>. If <code>asset_id</code> has no free balance remaining, the helper panics.</p>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>Contract with ID <code>MEM[$rA, 32]</code> is not in <code>tx.inputs</code></li>
<li>Reading past <code>MEM[VM_MAX_RAM - 1]</code></li>
<li>In an external context, if <code>$rB &gt; MEM[balanceOfStart(MEM[$rC, 32]), 8]</code></li>
<li>In an internal context, if <code>$rB</code> is greater than the balance of asset ID <code>MEM[$rC, 32]</code> of output with contract ID <code>MEM[$fp, 32]</code></li>
</ul>
<p>Register <code>$rA</code> is a memory address from which the following fields are set (word-aligned):</p>
<div class="table-wrapper"><table><thead><tr><th>bytes</th><th>type</th><th>value</th><th>description</th></tr></thead><tbody>
<tr><td>32</td><td><code>byte[32]</code></td><td><code>to</code></td><td>Contract ID to call.</td></tr>
<tr><td>8</td><td><code>byte[8]</code></td><td><code>param1</code></td><td>First parameter.</td></tr>
<tr><td>8</td><td><code>byte[8]</code></td><td><code>param2</code></td><td>Second parameter.</td></tr>
</tbody></table>
</div>
<p><code>$rB</code> is the amount of coins to forward. <code>$rC</code> points to the 32-byte asset ID of the coins to forward. <code>$rD</code> is the amount of gas to forward. If it is set to an amount greater than the available gas, all available gas is forwarded.</p>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.Call</code></td></tr>
<tr><td><code>from</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>to</code></td><td><code>byte[32]</code></td><td>Contract ID of called contract.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of coins to forward, i.e. <code>$rB</code>.</td></tr>
<tr><td><code>asset_id</code></td><td><code>byte[32]</code></td><td>Asset ID of coins to forward, i.e. <code>MEM[$rC, 32]</code>.</td></tr>
<tr><td><code>gas</code></td><td><code>uint64</code></td><td>Gas to forward, i.e. <code>min($rD, $cgas)</code>.</td></tr>
<tr><td><code>param1</code></td><td><code>uint64</code></td><td>First parameter.</td></tr>
<tr><td><code>param2</code></td><td><code>uint64</code></td><td>Second parameter.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<p>For output with contract ID <code>MEM[$rA, 32]</code>, increase balance of asset ID <code>MEM[$rC, 32]</code> by <code>$rB</code>. In an external context, decrease <code>MEM[balanceOfStart(MEM[$rC, 32]), 8]</code> by <code>$rB</code>. In an internal context, decrease asset ID <code>MEM[$rC, 32]</code> balance of output with contract ID <code>MEM[$fp, 32]</code> by <code>$rB</code>.</p>
<p>A <a href="fuel-vm/./index.html#call-frames">call frame</a> is pushed at <code>$sp</code>. In addition to filling in the values of the call frame, the following registers are set:</p>
<ol>
<li><code>$fp = $sp</code> (on top of the previous call frame is the beginning of this call frame)</li>
<li>Set <code>$ssp</code> and <code>$sp</code> to the start of the writable stack area of the call frame.</li>
<li>Set <code>$pc</code> and <code>$is</code> to the starting address of the code.</li>
<li><code>$flag</code> set to zero.</li>
<li><code>$bal = $rB</code> (forward coins)</li>
<li><code>$cgas = $rD</code> or all available gas (forward gas)</li>
</ol>
<p>This modifies the <code>balanceRoot</code> field of the appropriate output(s).</p>
<h3 id="cb-coinbase-contract-id"><a class="header" href="#cb-coinbase-contract-id"><code>CB</code>: Coinbase contract id</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Get the <a href="fuel-vm/../protocol/tx-validity.html#coinbase-transaction">coinbase contract id</a> associated with the block proposer.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, 32] = coinbase();</code></td></tr>
<tr><td>Syntax</td><td><code>cb $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA - - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h3 id="ccp-code-copy"><a class="header" href="#ccp-code-copy"><code>CCP</code>: Code copy</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Copy <code>$rD</code> bytes of code starting at <code>$rC</code> for contract with ID equal to the 32 bytes in memory starting at <code>$rB</code> into memory starting at <code>$rA</code>.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, $rD] = code($rB, $rC, $rD);</code></td></tr>
<tr><td>Syntax</td><td><code>ccp $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td>If <code>$rD</code> is greater than the code size, zero bytes are filled in.</td></tr>
</tbody></table>
</div>
<p>This is used only for reading and inspecting code of other contracts.
Use <a href="fuel-vm/instruction-set.html#ldc-load-code-from-an-external-contract-blob-or-memory"><code>LDC</code></a> to load code for executing.</p>
<p>Panic if:</p>
<ul>
<li><code>$rA + $rD</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, $rD]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li>Contract with ID <code>MEM[$rB, 32]</code> is not in <code>tx.inputs</code></li>
</ul>
<h3 id="croo-code-merkle-root"><a class="header" href="#croo-code-merkle-root"><code>CROO</code>: Code Merkle root</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Set the 32 bytes in memory starting at <code>$rA</code> to the code root for contract with ID equal to the 32 bytes in memory starting at <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, 32] = coderoot(MEM[$rB, 32]);</code></td></tr>
<tr><td>Syntax</td><td><code>croo $rA, $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li>Contract with ID <code>MEM[$rB, 32]</code> is not in <code>tx.inputs</code></li>
</ul>
<p>Code root computation is defined <a href="fuel-vm/../identifiers/contract-id.html">here</a>.</p>
<h3 id="csiz-code-size"><a class="header" href="#csiz-code-size"><code>CSIZ</code>: Code size</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Set <code>$rA</code> to the size of the code for contract with ID equal to the 32 bytes in memory starting at <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>$rA = codesize(MEM[$rB, 32]);</code></td></tr>
<tr><td>Syntax</td><td><code>csiz $rA, $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>Contract with ID <code>MEM[$rB, 32]</code> is not in <code>tx.inputs</code></li>
</ul>
<h3 id="ldc-load-code-from-an-external-contract-blob-or-memory"><a class="header" href="#ldc-load-code-from-an-external-contract-blob-or-memory"><code>LDC</code>: Load code from an external contract, blob or memory</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Copy <code>$rC</code> bytes of code at offset <code>$rB</code> from object identified with <code>$rA</code> into memory starting at <code>$ssp</code>. Object type is in <code>imm</code>.</td></tr>
<tr><td>Operation</td><td><code>code = match imm { 0 =&gt; contract_code(mem[$rA,32]), 1 =&gt; blob_payload(mem[$rA,32]), 2 =&gt; mem[$ra, ..] }; MEM[$ssp, $rC] = code[$rB, $rC];</code></td></tr>
<tr><td>Syntax</td><td><code>ldc $rA, $rB, $rC, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC imm</code></td></tr>
<tr><td>Notes</td><td>If <code>$rC</code> is greater than the code size, zero bytes are filled in. Final length is always padded to word boundary.</td></tr>
</tbody></table>
</div>
<p>Object type from <code>imm</code> determines the source for loading as follows:</p>
<div class="table-wrapper"><table><thead><tr><th><code>imm</code></th><th>Object type</th></tr></thead><tbody>
<tr><td><code>0</code></td><td>Contract code</td></tr>
<tr><td><code>1</code></td><td>Blob payload</td></tr>
<tr><td><code>2</code></td><td>VM memory</td></tr>
<tr><td>other</td><td><em>reserved</em></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$ssp + $rC</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>imm &lt;= 1</code> and <code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$ssp + $rC &gt;= $hp</code></li>
<li><code>imm == 0</code> and <code>$rC &gt; CONTRACT_MAX_SIZE</code></li>
<li><code>imm == 0</code> and contract with ID <code>MEM[$rA, 32]</code> is not in <code>tx.inputs</code></li>
<li><code>imm == 0</code> and context is a predicate</li>
<li><code>imm == 1</code> and blob with ID <code>MEM[$rA, 32]</code> is not found in the chain state</li>
<li><code>imm == 2</code> and <code>$rA + $rB + $rC</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>imm &gt;= 3</code> (reserved value)</li>
</ul>
<p>Increment <code>$fp-&gt;codesize</code>, <code>$ssp</code> by <code>$rC</code> padded to word alignment. Then set <code>$sp</code> to <code>$ssp</code>.</p>
<p>This instruction can be used to concatenate the code of multiple contracts or blobs together. It can only be used when the stack area of the call frame is zero-sized.</p>
<h3 id="log-log-event"><a class="header" href="#log-log-event"><code>LOG</code>: Log event</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Log an event. This is a no-op.</td></tr>
<tr><td>Operation</td><td><code>log($rA, $rB, $rC, $rD);</code></td></tr>
<tr><td>Syntax</td><td><code>log $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.Log</code></td></tr>
<tr><td><code>id</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>val0</code></td><td><code>uint64</code></td><td>Value of register <code>$rA</code>.</td></tr>
<tr><td><code>val1</code></td><td><code>uint64</code></td><td>Value of register <code>$rB</code>.</td></tr>
<tr><td><code>val2</code></td><td><code>uint64</code></td><td>Value of register <code>$rC</code>.</td></tr>
<tr><td><code>val3</code></td><td><code>uint64</code></td><td>Value of register <code>$rD</code>.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<h3 id="logd-log-data-event"><a class="header" href="#logd-log-data-event"><code>LOGD</code>: Log data event</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Log an event. This is a no-op.</td></tr>
<tr><td>Operation</td><td><code>logd($rA, $rB, $rC, $rD);</code></td></tr>
<tr><td>Syntax</td><td><code>logd $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.LogData</code></td></tr>
<tr><td><code>id</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>val0</code></td><td><code>uint64</code></td><td>Value of register <code>$rA</code>.</td></tr>
<tr><td><code>val1</code></td><td><code>uint64</code></td><td>Value of register <code>$rB</code>.</td></tr>
<tr><td><code>ptr</code></td><td><code>uint64</code></td><td>Value of register <code>$rC</code>.</td></tr>
<tr><td><code>len</code></td><td><code>uint64</code></td><td>Value of register <code>$rD</code>.</td></tr>
<tr><td><code>digest</code></td><td><code>byte[32]</code></td><td><a href="fuel-vm/instruction-set.html#s256-sha-2-256">Hash</a> of <code>MEM[$rC, $rD]</code>.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<p>Logs the memory range <code>MEM[$rC, $rD]</code>.</p>
<p>Panics if:</p>
<ul>
<li><code>$rC + $rD</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<h3 id="mint-mint-new-coins"><a class="header" href="#mint-mint-new-coins"><code>MINT</code>: Mint new coins</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Mint <code>$rA</code> coins of the <code>$rB</code> ID from the current contract.</td></tr>
<tr><td>Operation</td><td><code>mint($rA, $rB);</code></td></tr>
<tr><td>Syntax</td><td><code>mint $rA $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td><code>$rB</code> is a pointer to a 32 byte ID in memory</td></tr>
</tbody></table>
</div>
<p>The asset ID will be constructed using the asset ID construction method.</p>
<p>Panic if:</p>
<ul>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>Balance of asset ID <code>constructAssetID(MEM[$fp, 32], MEM[$rB])</code> of output with contract ID <code>MEM[$fp, 32]</code> plus <code>$rA</code> overflows</li>
<li><code>$fp == 0</code> (in the script context)</li>
</ul>
<p>For output with contract ID <code>MEM[$fp, 32]</code>, increase balance of asset ID <code>constructAssetID(MEM[$fp, 32], MEM[$rB])</code> by <code>$rA</code>.</p>
<p>This modifies the <code>balanceRoot</code> field of the appropriate output.</p>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.Mint</code></td></tr>
<tr><td><code>sub_id</code></td><td><code>byte[32]</code></td><td>Asset sub identifier <code>MEM[$rB, $rB + 32]</code>.</td></tr>
<tr><td><code>contract_id</code></td><td><code>byte[32]</code></td><td>Contract ID of the current context.</td></tr>
<tr><td><code>val</code></td><td><code>uint64</code></td><td>Value of register <code>$rA</code>.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<h3 id="retd-return-from-context-with-data"><a class="header" href="#retd-return-from-context-with-data"><code>RETD</code>: Return from context with data</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Returns from <a href="fuel-vm/./index.html#contexts">context</a> with value <code>MEM[$rA, $rB]</code>.</td></tr>
<tr><td>Operation</td><td><code>returndata($rA, $rB);</code></td></tr>
<tr><td>Syntax</td><td><code>retd $rA, $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + $rB</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.ReturnData</code></td></tr>
<tr><td><code>id</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>ptr</code></td><td><code>uint64</code></td><td>Value of register <code>$rA</code>.</td></tr>
<tr><td><code>len</code></td><td><code>uint64</code></td><td>Value of register <code>$rB</code>.</td></tr>
<tr><td><code>digest</code></td><td><code>byte[32]</code></td><td><a href="fuel-vm/instruction-set.html#s256-sha-2-256">Hash</a> of <code>MEM[$rA, $rB]</code>.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<p>If current context is a script, append an additional receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.ScriptResult</code></td></tr>
<tr><td><code>result</code></td><td><code>uint64</code></td><td><code>0</code></td></tr>
<tr><td><code>gas_used</code></td><td><code>uint64</code></td><td>Gas consumed by the script.</td></tr>
</tbody></table>
</div>
<p>If current context is external, cease VM execution and return <code>MEM[$rA, $rB]</code>.</p>
<p>Returns from contract call, popping the call frame. Before popping, perform the following operations.</p>
<p>Return the unused forwarded gas to the caller:</p>
<ol>
<li><code>$cgas = $cgas + $fp-&gt;$cgas</code> (add remaining context gas from previous context to current remaining context gas)</li>
</ol>
<p>Set the return value:</p>
<ol>
<li><code>$ret = $rA</code></li>
<li><code>$retl = $rB</code></li>
</ol>
<p>Then pop the call frame and restore all registers <em>except</em> <code>$ggas</code>, <code>$cgas</code>, <code>$ret</code>, <code>$retl</code> and <code>$hp</code>. Afterwards, set the following registers:</p>
<ol>
<li><code>$pc = $pc + 4</code> (advance program counter from where we called)</li>
</ol>
<h3 id="rvrt-revert"><a class="header" href="#rvrt-revert"><code>RVRT</code>: Revert</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Halt execution, reverting state changes and returning value in <code>$rA</code>.</td></tr>
<tr><td>Operation</td><td><code>revert($rA);</code></td></tr>
<tr><td>Syntax</td><td><code>rvrt $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA - - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.Revert</code></td></tr>
<tr><td><code>id</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>val</code></td><td><code>uint64</code></td><td>Value of register <code>$rA</code>.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<p>Then append an additional receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.ScriptResult</code></td></tr>
<tr><td><code>result</code></td><td><code>uint64</code></td><td><code>1</code></td></tr>
<tr><td><code>gas_used</code></td><td><code>uint64</code></td><td>Gas consumed by the script.</td></tr>
</tbody></table>
</div>
<p>Cease VM execution and revert script effects. After a revert:</p>
<ol>
<li>All <a href="fuel-vm/../tx-format/output.html#outputcontract"><code>OutputContract</code></a> outputs will have the same <code>balanceRoot</code> and <code>stateRoot</code> as on initialization.</li>
<li>All <a href="fuel-vm/../tx-format/output.html#outputvariable"><code>OutputVariable</code></a> outputs will have <code>to</code>, <code>amount</code>, and <code>asset_id</code> of zero.</li>
</ol>
<h3 id="smo-send-message-out"><a class="header" href="#smo-send-message-out"><code>SMO</code>: Send message out</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Send a message to recipient address <code>MEM[$rA, 32]</code> from the <code>MEM[$fp, 32]</code> sender with message data <code>MEM[$rB, $rC]</code> and the <code>$rD</code> amount of base asset coins.</td></tr>
<tr><td>Operation</td><td><code>outputmessage(MEM[$fp, 32], MEM[$rA, 32], MEM[$rB, $rC], $rD);</code></td></tr>
<tr><td>Syntax</td><td><code>smo $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Effects</td><td>Output message</td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>There is a <code>balanceOfStart(asset_id: byte[32]) -&gt; uint32</code> helper that returns the memory address of the remaining free balance of <code>asset_id</code>. If <code>asset_id</code> has no free balance remaining, the helper panics.</p>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + $rC</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC &gt; MESSAGE_MAX_DATA_SIZE</code></li>
<li>In an external context, if <code>$rD &gt; MEM[balanceOfStart(0), 8]</code></li>
<li>In an internal context, if <code>$rD</code> is greater than the balance of asset ID 0 of output with contract ID <code>MEM[$fp, 32]</code></li>
</ul>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.MessageOut</code></td></tr>
<tr><td><code>sender</code></td><td><code>byte[32]</code></td><td>The address of the message sender: <code>MEM[$fp, 32]</code>.</td></tr>
<tr><td><code>recipient</code></td><td><code>byte[32]</code></td><td>The address of the message recipient: <code>MEM[$rA, 32]</code>.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of base asset coins sent with message: <code>$rD</code>.</td></tr>
<tr><td><code>nonce</code></td><td><code>byte[32]</code></td><td>The message nonce as described <a href="fuel-vm/../identifiers/utxo-id.html#message-nonce">here</a>.</td></tr>
<tr><td><code>len</code></td><td><code>uint64</code></td><td>Length of message data, in bytes: <code>$rC</code>.</td></tr>
<tr><td><code>digest</code></td><td><code>byte[32]</code></td><td><a href="fuel-vm/instruction-set.html#s256-sha-2-256">Hash</a> of <code>MEM[$rB, $rC]</code>.</td></tr>
</tbody></table>
</div>
<p>In an external context, decrease <code>MEM[balanceOfStart(0), 8]</code> by <code>$rD</code>. In an internal context, decrease asset ID 0 balance of output with contract ID <code>MEM[$fp, 32]</code> by <code>$rD</code>. This modifies the <code>balanceRoot</code> field of the appropriate contract that had its' funds deducted.</p>
<h3 id="scwq-state-clear-sequential-32-byte-slots"><a class="header" href="#scwq-state-clear-sequential-32-byte-slots"><code>SCWQ</code>: State clear sequential 32 byte slots</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>A sequential series of 32 bytes is cleared from the current contract's state.</td></tr>
<tr><td>Operation</td><td><code>STATE[MEM[$rA, 32], 32 * $rC] = None;</code></td></tr>
<tr><td>Syntax</td><td><code>scwq $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$fp == 0</code> (in the script context)</li>
</ul>
<p>Register <code>$rB</code> will be set to <code>false</code> if any storage slot in the requested range was already unset (default) and <code>true</code> if all the slots were set.</p>
<h3 id="srw-state-read-word"><a class="header" href="#srw-state-read-word"><code>SRW</code>: State read word</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>A word is read from the current contract's state.</td></tr>
<tr><td>Operation</td><td><code>$rA = STATE[MEM[$rC, 32]][0, 8];</code></td></tr>
<tr><td>Syntax</td><td><code>srw $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Effects</td><td>Storage read</td></tr>
<tr><td>Notes</td><td>Returns zero if the state element does not exist.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$fp == 0</code> (in the script context)</li>
</ul>
<p>Register <code>$rB</code> will be set to <code>false</code> if the requested slot is unset (default) and <code>true</code> if it's set.</p>
<h3 id="srwq-state-read-sequential-32-byte-slots"><a class="header" href="#srwq-state-read-sequential-32-byte-slots"><code>SRWQ</code>: State read sequential 32 byte slots</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>A sequential series of 32 bytes is read from the current contract's state.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, 32 * rD] = STATE[MEM[$rC, 32], 32 * rD];</code></td></tr>
<tr><td>Syntax</td><td><code>srwq $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Effects</td><td>Storage read</td></tr>
<tr><td>Notes</td><td>Returns zero if the state element does not exist.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32 * rD</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32 * rD</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li>The memory range <code>MEM[$rA, 32 * rD]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
<li><code>$fp == 0</code> (in the script context)</li>
</ul>
<p>Register <code>$rB</code> will be set to <code>false</code> if any storage slot in the requested range is unset (default) and <code>true</code> if all the slots are set.</p>
<h3 id="sww-state-write-word"><a class="header" href="#sww-state-write-word"><code>SWW</code>: State write word</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>A word is written to the current contract's state.</td></tr>
<tr><td>Operation</td><td><code>STATE[MEM[$rA, 32]][0, 8] = $rC;</code><br><code>STATE[MEM[$rA, 32]][8, 24] = 0;</code></td></tr>
<tr><td>Syntax</td><td><code>sww $rA $rB $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Effects</td><td>Storage write</td></tr>
<tr><td>Notes</td><td>Additional gas is charged when a new storage slot is created.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$fp == 0</code> (in the script context)</li>
</ul>
<p>The last 24 bytes of <code>STATE[MEM[$rA, 32]]</code> are set to <code>0</code>. Register <code>$rB</code> will be set to the number of new slots written, i.e. <code>1</code> if the slot was previously unset, and <code>0</code> if it already contained a value.</p>
<h3 id="swwq-state-write-sequential-32-byte-slots"><a class="header" href="#swwq-state-write-sequential-32-byte-slots"><code>SWWQ</code>: State write sequential 32 byte slots</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>A sequential series of 32 bytes is written to the current contract's state.</td></tr>
<tr><td>Operation</td><td><code>STATE[MEM[$rA, 32], 32 * $rD] = MEM[$rC, 32 * $rD];</code></td></tr>
<tr><td>Syntax</td><td><code>swwq $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Effects</td><td>Storage write</td></tr>
<tr><td>Notes</td><td>Additional gas is charged when for each new storage slot created.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32 * $rD</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$fp == 0</code> (in the script context)</li>
</ul>
<p>Register <code>$rB</code> will be set to the number of storage slots that were previously unset, and were set by this operation.</p>
<h3 id="time-timestamp-at-height"><a class="header" href="#time-timestamp-at-height"><code>TIME</code>: Timestamp at height</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Get timestamp of block at given height.</td></tr>
<tr><td>Operation</td><td><code>$rA = time($rB);</code></td></tr>
<tr><td>Syntax</td><td><code>time $rA, $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB</code> is greater than the current block height.</li>
</ul>
<p>Gets the timestamp of the block at height <code>$rB</code>. Time is in <a href="https://cr.yp.to/libtai/tai64.html">TAI64</a> format.</p>
<h3 id="tr-transfer-coins-to-contract"><a class="header" href="#tr-transfer-coins-to-contract"><code>TR</code>: Transfer coins to contract</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Transfer <code>$rB</code> coins with asset ID at <code>$rC</code> to contract with ID at <code>$rA</code>.</td></tr>
<tr><td>Operation</td><td><code>transfer(MEM[$rA, 32], $rB, MEM[$rC, 32]);</code></td></tr>
<tr><td>Syntax</td><td><code>tr $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Effects</td><td>Balance tree read, balance tree write</td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>There is a <code>balanceOfStart(asset_id: byte[32]) -&gt; uint32</code> helper that returns the memory address of the remaining free balance of <code>asset_id</code>. If <code>asset_id</code> has no free balance remaining, the helper panics.</p>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>Contract with ID <code>MEM[$rA, 32]</code> is not in <code>tx.inputs</code></li>
<li>In an external context, if <code>$rB &gt; MEM[balanceOfStart(MEM[$rC, 32]), 8]</code></li>
<li>In an internal context, if <code>$rB</code> is greater than the balance of asset ID <code>MEM[$rC, 32]</code> of output with contract ID <code>MEM[$fp, 32]</code></li>
<li><code>$rB == 0</code></li>
</ul>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.Transfer</code></td></tr>
<tr><td><code>from</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>to</code></td><td><code>byte[32]</code></td><td>Contract ID of contract to transfer coins to.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of coins transferred.</td></tr>
<tr><td><code>asset_id</code></td><td><code>byte[32]</code></td><td>asset ID of coins transferred.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<p>For output with contract ID <code>MEM[$rA, 32]</code>, increase balance of asset ID <code>MEM[$rC, 32]</code> by <code>$rB</code>. In an external context, decrease <code>MEM[balanceOfStart(MEM[$rC, 32]), 8]</code> by <code>$rB</code>. In an internal context, decrease asset ID <code>MEM[$rC, 32]</code> balance of output with contract ID <code>MEM[$fp, 32]</code> by <code>$rB</code>.</p>
<p>This modifies the <code>balanceRoot</code> field of the appropriate output(s).</p>
<h3 id="tro-transfer-coins-to-output"><a class="header" href="#tro-transfer-coins-to-output"><code>TRO</code>: Transfer coins to output</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Transfer <code>$rC</code> coins with asset ID at <code>$rD</code> to address at <code>$rA</code>, with output <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>transferout(MEM[$rA, 32], $rB, $rC, MEM[$rD, 32]);</code></td></tr>
<tr><td>Syntax</td><td><code>tro $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Effects</td><td>Balance tree read, balance tree write</td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>There is a <code>balanceOfStart(asset_id: byte[32]) -&gt; uint32</code> helper that returns the memory address of the remaining free balance of <code>asset_id</code>. If <code>asset_id</code> has no free balance remaining, the helper panics.</p>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rD + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB &gt; tx.outputsCount</code></li>
<li>In an external context, if <code>$rC &gt; MEM[balanceOfStart(MEM[$rD, 32]), 8]</code></li>
<li>In an internal context, if <code>$rC</code> is greater than the balance of asset ID <code>MEM[$rD, 32]</code> of output with contract ID <code>MEM[$fp, 32]</code></li>
<li><code>$rC == 0</code></li>
<li><code>tx.outputs[$rB].type != OutputType.Variable</code></li>
<li><code>tx.outputs[$rB].amount != 0</code></li>
</ul>
<p>Append a receipt to the list of receipts:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ReceiptType</code></td><td><code>ReceiptType.TransferOut</code></td></tr>
<tr><td><code>from</code></td><td><code>byte[32]</code></td><td>Contract ID of current context if in an internal context, zero otherwise.</td></tr>
<tr><td><code>to</code></td><td><code>byte[32]</code></td><td>Address to transfer coins to.</td></tr>
<tr><td><code>amount</code></td><td><code>uint64</code></td><td>Amount of coins transferred.</td></tr>
<tr><td><code>asset_id</code></td><td><code>byte[32]</code></td><td>asset ID of coins transferred.</td></tr>
<tr><td><code>pc</code></td><td><code>uint64</code></td><td>Value of register <code>$pc</code>.</td></tr>
<tr><td><code>is</code></td><td><code>uint64</code></td><td>Value of register <code>$is</code>.</td></tr>
</tbody></table>
</div>
<p>In an external context, decrease <code>MEM[balanceOfStart(MEM[$rD, 32]), 8]</code> by <code>$rC</code>. In an internal context, decrease asset ID <code>MEM[$rD, 32]</code> balance of output with contract ID <code>MEM[$fp, 32]</code> by <code>$rC</code>. Then set:</p>
<ul>
<li><code>tx.outputs[$rB].to = MEM[$rA, 32]</code></li>
<li><code>tx.outputs[$rB].amount = $rC</code></li>
<li><code>tx.outputs[$rB].asset_id = MEM[$rD, 32]</code></li>
</ul>
<p>This modifies the <code>balanceRoot</code> field of the appropriate output(s).</p>
<h2 id="blob-instructions"><a class="header" href="#blob-instructions">Blob Instructions</a></h2>
<p>All these instructions advance the program counter <code>$pc</code> by <code>4</code> after performing their operation.</p>
<h3 id="bsiz-blob-size"><a class="header" href="#bsiz-blob-size"><code>BSIZ</code>: Blob size</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Set <code>$rA</code> to the size of the blob with ID equal to the 32 bytes in memory starting at <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>$rA = len(blob(MEM[$rB, 32]));</code></td></tr>
<tr><td>Syntax</td><td><code>bsiz $rA, $rB</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>Blob ID <code>MEM[$rB, 32]</code> is not found</li>
</ul>
<h3 id="bldd-load-data-from-a-blob"><a class="header" href="#bldd-load-data-from-a-blob"><code>BLDD</code>: Load data from a blob</a></h3>
<p>|-------------|-------------------------------------------------------------------------------------------------------------|
| Description | Load 32-byte blob id at <code>$rB</code>, and copy <code>$rD</code> bytes starting from <code>$rC</code> into <code>$sA</code>.                         |
| Operation   | <code>MEM[$rA, $rD] = blob(MEM[$rB, 32])[$rC, $rD];</code>                                                             |
| Syntax      | <code>bldd $rA, $rB, rC, $rD</code>                                                                                    |
| Encoding    | <code>0x00 rA rB rC rD</code>                                                                                          |
| Notes       | If <code>$rC &gt;</code> blob size, zero bytes are filled in.                                                             |</p>
<p>Panic if:</p>
<ul>
<li><code>$rA + $rD</code> overflows or <code>&gt; VM_MAX_RAM</code> or <code>&gt; $hp</code></li>
<li><code>$rB + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>Blob ID <code>MEM[$rB, 32]</code> is not found</li>
</ul>
<h2 id="cryptographic-instructions"><a class="header" href="#cryptographic-instructions">Cryptographic Instructions</a></h2>
<p>All these instructions advance the program counter <code>$pc</code> by <code>4</code> after performing their operation.</p>
<h3 id="eck1-secp256k1-signature-recovery"><a class="header" href="#eck1-secp256k1-signature-recovery"><code>ECK1</code>: Secp256k1 signature recovery</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>The 64-byte public key (x, y) recovered from 64-byte signature starting at <code>$rB</code> on 32-byte message hash starting at <code>$rC</code>.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, 64] = ecrecover_k1(MEM[$rB, 64], MEM[$rC, 32]);</code></td></tr>
<tr><td>Syntax</td><td><code>eck1 $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td>Takes message hash as an input. You can use <code>S256</code> to hash the message if needed.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 64</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + 64</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, 64]</code> does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<p>Signatures and signature verification are specified <a href="fuel-vm/../protocol/cryptographic-primitives.html#ecdsa-public-key-cryptography">here</a>.</p>
<p>If the signature cannot be verified, <code>MEM[$rA, 64]</code> is set to <code>0</code> and <code>$err</code> is set to <code>1</code>, otherwise <code>$err</code> is cleared.</p>
<p>To get the address from the public key, hash the public key with <a href="fuel-vm/../protocol/cryptographic-primitives.html#hashing">SHA-2-256</a>.</p>
<h3 id="ecr1-secp256r1-signature-recovery"><a class="header" href="#ecr1-secp256r1-signature-recovery"><code>ECR1</code>: Secp256r1 signature recovery</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>The 64-byte public key (x, y) recovered from 64-byte signature starting at <code>$rB</code> on 32-byte message hash starting at <code>$rC</code>.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, 64] = ecrecover_r1(MEM[$rB, 64], MEM[$rC, 32]);</code></td></tr>
<tr><td>Syntax</td><td><code>ecr1 $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td>Takes message hash as an input. You can use <code>S256</code> to hash the message if needed.</td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 64</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + 64</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, 64]</code> does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<p>Signatures and signature verification are specified <a href="fuel-vm/../protocol/cryptographic-primitives.html#ecdsa-public-key-cryptography">here</a>.</p>
<p>If the signature cannot be verified, <code>MEM[$rA, 64]</code> is set to <code>0</code> and <code>$err</code> is set to <code>1</code>, otherwise <code>$err</code> is cleared.</p>
<p>To get the address from the public key, hash the public key with <a href="fuel-vm/../protocol/cryptographic-primitives.html#hashing">SHA-2-256</a>.</p>
<h3 id="ed19-eddsa-curve25519-verification"><a class="header" href="#ed19-eddsa-curve25519-verification"><code>ED19</code>: EdDSA curve25519 verification</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Verification 64-byte signature at <code>$rB</code> with 32-byte public key at <code>$rA</code> for a message starting at <code>$rC</code> with length <code>$rD</code>.</td></tr>
<tr><td>Operation</td><td><code>ed19verify(MEM[$rA, 32], MEM[$rB, 64], MEM[$rC, $rD]);</code></td></tr>
<tr><td>Syntax</td><td><code>ed19 $rA, $rB, $rC, $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td>Takes message instead of hash. <strong>For backwards compatibility reasons, if <code>$rD == 0</code>, it will be treated as <code>32</code>.</strong></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + 64</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rC + $rD</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
</ul>
<p>Verification are specified <a href="fuel-vm/../protocol/cryptographic-primitives.html#eddsa-public-key-cryptography">here</a>.</p>
<p>If there is an error in verification, <code>$err</code> is set to <code>1</code>, otherwise <code>$err</code> is cleared.</p>
<h3 id="k256-keccak-256"><a class="header" href="#k256-keccak-256"><code>K256</code>: keccak-256</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>The keccak-256 hash of <code>$rC</code> bytes starting at <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, 32] = keccak256(MEM[$rB, $rC]);</code></td></tr>
<tr><td>Syntax</td><td><code>k256 $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + $rC</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h3 id="s256-sha-2-256"><a class="header" href="#s256-sha-2-256"><code>S256</code>: SHA-2-256</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>The SHA-2-256 hash of <code>$rC</code> bytes starting at <code>$rB</code>.</td></tr>
<tr><td>Operation</td><td><code>MEM[$rA, 32] = sha256(MEM[$rB, $rC]);</code></td></tr>
<tr><td>Syntax</td><td><code>s256 $rA, $rB, $rC</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA + 32</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li><code>$rB + $rC</code> overflows or <code>&gt; VM_MAX_RAM</code></li>
<li>The memory range <code>MEM[$rA, 32]</code>  does not pass <a href="fuel-vm/./index.html#ownership">ownership check</a></li>
</ul>
<h2 id="other-instructions"><a class="header" href="#other-instructions">Other Instructions</a></h2>
<p>All these instructions advance the program counter <code>$pc</code> by <code>4</code> after performing their operation.</p>
<h3 id="ecal-call-external-function"><a class="header" href="#ecal-call-external-function"><code>ECAL</code>: Call external function</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Call an external function that has full access to the VM state.</td></tr>
<tr><td>Operation</td><td><code>external(&amp;mut vm, $rA, $rB, $rC, $rD)</code></td></tr>
<tr><td>Syntax</td><td><code>ecal $rA $rB $rC $rD</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB rC rD</code></td></tr>
<tr><td>Notes</td><td>Does nothing by default, but the VM user can define this to do anything.</td></tr>
</tbody></table>
</div>
<p>This function provides an escape hatch from the VM, similar to <code>ecall</code> instruction of RISC-V. The suggested convention is to use <code>$rA</code> for &quot;system call number&quot;, i.e. identifying the procedure to call, but all arguments can be used freely. The operation can modify the VM state freely, including writing to registers and memory. Again, the suggested convention is to use <code>$rA</code> for the return value and <code>$err</code> for any possible errors. However, these conventions can be ignored when necessary.</p>
<p>Panic if:</p>
<ul>
<li>The external function panics.</li>
</ul>
<h3 id="flag-set-flags"><a class="header" href="#flag-set-flags"><code>FLAG</code>: Set flags</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Set <code>$flag</code> to <code>$rA</code>.</td></tr>
<tr><td>Operation</td><td><code>$flag = $rA;</code></td></tr>
<tr><td>Syntax</td><td><code>flag $rA</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA - - -</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li>Any reserved flags are set</li>
</ul>
<h3 id="gm-get-metadata"><a class="header" href="#gm-get-metadata"><code>GM</code>: Get metadata</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Get metadata from memory.</td></tr>
<tr><td>Operation</td><td>Varies (see below).</td></tr>
<tr><td>Syntax</td><td><code>gm $rA, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA imm imm imm</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Read metadata from memory. A convenience instruction to avoid manually extracting metadata.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>value</th><th>description</th></tr></thead><tbody>
<tr><td><code>GM_IS_CALLER_EXTERNAL</code></td><td><code>0x00001</code></td><td>Get if caller is external.</td></tr>
<tr><td><code>GM_GET_CALLER</code></td><td><code>0x00002</code></td><td>Get caller's contract ID.</td></tr>
<tr><td><code>GM_GET_VERIFYING_PREDICATE</code></td><td><code>0x00003</code></td><td>Get index of current predicate.</td></tr>
<tr><td><code>GM_GET_CHAIN_ID</code></td><td><code>0x00004</code></td><td>Get the value of <code>CHAIN_ID</code></td></tr>
<tr><td><code>GM_TX_START</code></td><td><code>0x00005</code></td><td>Transaction start memory address</td></tr>
<tr><td><code>GM_BASE_ASSET_ID</code></td><td><code>0x00006</code></td><td>Base asset ID</td></tr>
</tbody></table>
</div>
<p>If <code>imm == GM_IS_CALLER_EXTERNAL</code>:</p>
<p>Panic if:</p>
<ul>
<li><code>$fp == 0</code> (in an external context)</li>
</ul>
<p>Set <code>$rA</code> to <code>true</code> if parent is an external context, <code>false</code> otherwise.</p>
<p>If <code>imm == GM_GET_CALLER</code>:</p>
<p>Panic if:</p>
<ul>
<li><code>$fp == 0</code> (in an external context)</li>
<li><code>$fp-&gt;$fp == 0</code> (if parent context is external)</li>
</ul>
<p>Set <code>$rA</code> to <code>$fp-&gt;$fp</code> (i.e. <code>$rA</code> will point to the previous call frame's contract ID).</p>
<p>If <code>imm == GM_GET_VERIFYING_PREDICATE</code>:</p>
<p>Panic if:</p>
<ul>
<li>not in a predicate context</li>
</ul>
<p>Set <code>$rA</code> to the index of the currently-verifying predicate.</p>
<h3 id="gtf-get-transaction-fields"><a class="header" href="#gtf-get-transaction-fields"><code>GTF</code>: Get transaction fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Description</td><td>Get transaction fields.</td></tr>
<tr><td>Operation</td><td>Varies (see below).</td></tr>
<tr><td>Syntax</td><td><code>gtf $rA, $rB, imm</code></td></tr>
<tr><td>Encoding</td><td><code>0x00 rA rB i i</code></td></tr>
<tr><td>Notes</td><td></td></tr>
</tbody></table>
</div>
<p>Get <a href="fuel-vm/../tx-format/transaction.html">fields from the transaction</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th><code>imm</code></th><th>set <code>$rA</code> to</th></tr></thead><tbody>
<tr><td><code>GTF_TYPE</code></td><td><code>0x001</code></td><td><code>tx.type</code></td></tr>
<tr><td><code>GTF_SCRIPT_GAS_LIMIT</code></td><td><code>0x002</code></td><td><code>tx.scriptGasLimit</code></td></tr>
<tr><td><code>GTF_SCRIPT_SCRIPT_LENGTH</code></td><td><code>0x003</code></td><td><code>tx.scriptLength</code></td></tr>
<tr><td><code>GTF_SCRIPT_SCRIPT_DATA_LENGTH</code></td><td><code>0x004</code></td><td><code>tx.scriptDataLength</code></td></tr>
<tr><td><code>GTF_SCRIPT_INPUTS_COUNT</code></td><td><code>0x005</code></td><td><code>tx.inputsCount</code></td></tr>
<tr><td><code>GTF_SCRIPT_OUTPUTS_COUNT</code></td><td><code>0x006</code></td><td><code>tx.outputsCount</code></td></tr>
<tr><td><code>GTF_SCRIPT_WITNESSES_COUNT</code></td><td><code>0x007</code></td><td><code>tx.witnessesCount</code></td></tr>
<tr><td><code>GTF_SCRIPT_SCRIPT</code></td><td><code>0x009</code></td><td>Memory address of <code>tx.script</code></td></tr>
<tr><td><code>GTF_SCRIPT_SCRIPT_DATA</code></td><td><code>0x00A</code></td><td>Memory address of <code>tx.scriptData</code></td></tr>
<tr><td><code>GTF_SCRIPT_INPUT_AT_INDEX</code></td><td><code>0x00B</code></td><td>Memory address of <code>tx.inputs[$rB]</code></td></tr>
<tr><td><code>GTF_SCRIPT_OUTPUT_AT_INDEX</code></td><td><code>0x00C</code></td><td>Memory address of <code>t.outputs[$rB]</code></td></tr>
<tr><td><code>GTF_SCRIPT_WITNESS_AT_INDEX</code></td><td><code>0x00D</code></td><td>Memory address of <code>tx.witnesses[$rB]</code></td></tr>
<tr><td><code>GTF_TX_LENGTH</code></td><td><code>0x00E</code></td><td>Length of raw transaction types in memory</td></tr>
<tr><td><code>GTF_CREATE_BYTECODE_WITNESS_INDEX</code></td><td><code>0x101</code></td><td><code>tx.bytecodeWitnessIndex</code></td></tr>
<tr><td><code>GTF_CREATE_STORAGE_SLOTS_COUNT</code></td><td><code>0x102</code></td><td><code>tx.storageSlotsCount</code></td></tr>
<tr><td><code>GTF_CREATE_INPUTS_COUNT</code></td><td><code>0x103</code></td><td><code>tx.inputsCount</code></td></tr>
<tr><td><code>GTF_CREATE_OUTPUTS_COUNT</code></td><td><code>0x104</code></td><td><code>tx.outputsCount</code></td></tr>
<tr><td><code>GTF_CREATE_WITNESSES_COUNT</code></td><td><code>0x105</code></td><td><code>tx.witnessesCount</code></td></tr>
<tr><td><code>GTF_CREATE_SALT</code></td><td><code>0x106</code></td><td>Memory address of <code>tx.salt</code></td></tr>
<tr><td><code>GTF_CREATE_STORAGE_SLOT_AT_INDEX</code></td><td><code>0x107</code></td><td>Memory address of <code>tx.storageSlots[$rB]</code></td></tr>
<tr><td><code>GTF_CREATE_INPUT_AT_INDEX</code></td><td><code>0x108</code></td><td>Memory address of <code>tx.inputs[$rB]</code></td></tr>
<tr><td><code>GTF_CREATE_OUTPUT_AT_INDEX</code></td><td><code>0x109</code></td><td>Memory address of <code>t.outputs[$rB]</code></td></tr>
<tr><td><code>GTF_CREATE_WITNESS_AT_INDEX</code></td><td><code>0x10A</code></td><td>Memory address of <code>tx.witnesses[$rB]</code></td></tr>
<tr><td><code>GTF_INPUT_TYPE</code></td><td><code>0x200</code></td><td><code>tx.inputs[$rB].type</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_TX_ID</code></td><td><code>0x201</code></td><td>Memory address of <code>tx.inputs[$rB].txID</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_OUTPUT_INDEX</code></td><td><code>0x202</code></td><td><code>tx.inputs[$rB].outputIndex</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_OWNER</code></td><td><code>0x203</code></td><td>Memory address of <code>tx.inputs[$rB].owner</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_AMOUNT</code></td><td><code>0x204</code></td><td><code>tx.inputs[$rB].amount</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_ASSET_ID</code></td><td><code>0x205</code></td><td>Memory address of <code>tx.inputs[$rB].asset_id</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_WITNESS_INDEX</code></td><td><code>0x207</code></td><td><code>tx.inputs[$rB].witnessIndex</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_PREDICATE_LENGTH</code></td><td><code>0x209</code></td><td><code>tx.inputs[$rB].predicateLength</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_PREDICATE_DATA_LENGTH</code></td><td><code>0x20A</code></td><td><code>tx.inputs[$rB].predicateDataLength</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_PREDICATE</code></td><td><code>0x20B</code></td><td>Memory address of <code>tx.inputs[$rB].predicate</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_PREDICATE_DATA</code></td><td><code>0x20C</code></td><td>Memory address of <code>tx.inputs[$rB].predicateData</code></td></tr>
<tr><td><code>GTF_INPUT_COIN_PREDICATE_GAS_USED</code></td><td><code>0x20D</code></td><td><code>tx.inputs[$rB].predicateGasUsed</code></td></tr>
<tr><td><code>GTF_INPUT_CONTRACT_CONTRACT_ID</code></td><td><code>0x225</code></td><td>Memory address of <code>tx.inputs[$rB].contractID</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_SENDER</code></td><td><code>0x240</code></td><td>Memory address of <code>tx.inputs[$rB].sender</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_RECIPIENT</code></td><td><code>0x241</code></td><td>Memory address of <code>tx.inputs[$rB].recipient</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_AMOUNT</code></td><td><code>0x242</code></td><td><code>tx.inputs[$rB].amount</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_NONCE</code></td><td><code>0x243</code></td><td>Memory address of <code>tx.inputs[$rB].nonce</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_WITNESS_INDEX</code></td><td><code>0x244</code></td><td><code>tx.inputs[$rB].witnessIndex</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_DATA_LENGTH</code></td><td><code>0x245</code></td><td><code>tx.inputs[$rB].dataLength</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_PREDICATE_LENGTH</code></td><td><code>0x246</code></td><td><code>tx.inputs[$rB].predicateLength</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_PREDICATE_DATA_LENGTH</code></td><td><code>0x247</code></td><td><code>tx.inputs[$rB].predicateDataLength</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_DATA</code></td><td><code>0x248</code></td><td>Memory address of <code>tx.inputs[$rB].data</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_PREDICATE</code></td><td><code>0x249</code></td><td>Memory address of <code>tx.inputs[$rB].predicate</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_PREDICATE_DATA</code></td><td><code>0x24A</code></td><td>Memory address of <code>tx.inputs[$rB].predicateData</code></td></tr>
<tr><td><code>GTF_INPUT_MESSAGE_PREDICATE_GAS_USED</code></td><td><code>0x24B</code></td><td><code>tx.inputs[$rB].predicateGasUsed</code></td></tr>
<tr><td><code>GTF_OUTPUT_TYPE</code></td><td><code>0x300</code></td><td><code>tx.outputs[$rB].type</code></td></tr>
<tr><td><code>GTF_OUTPUT_COIN_TO</code></td><td><code>0x301</code></td><td>Memory address of <code>tx.outputs[$rB].to</code></td></tr>
<tr><td><code>GTF_OUTPUT_COIN_AMOUNT</code></td><td><code>0x302</code></td><td><code>tx.outputs[$rB].amount</code></td></tr>
<tr><td><code>GTF_OUTPUT_COIN_ASSET_ID</code></td><td><code>0x303</code></td><td>Memory address of <code>tx.outputs[$rB].asset_id</code></td></tr>
<tr><td><code>GTF_OUTPUT_CONTRACT_INPUT_INDEX</code></td><td><code>0x304</code></td><td><code>tx.outputs[$rB].inputIndex</code></td></tr>
<tr><td><code>GTF_OUTPUT_CONTRACT_BALANCE_ROOT</code></td><td><code>0x305</code></td><td>Memory address of <code>tx.outputs[$rB].balanceRoot</code></td></tr>
<tr><td><code>GTF_OUTPUT_CONTRACT_STATE_ROOT</code></td><td><code>0x306</code></td><td>Memory address of <code>tx.outputs[$rB].stateRoot</code></td></tr>
<tr><td><code>GTF_OUTPUT_CONTRACT_CREATED_CONTRACT_ID</code></td><td><code>0x307</code></td><td>Memory address of <code>tx.outputs[$rB].contractID</code></td></tr>
<tr><td><code>GTF_OUTPUT_CONTRACT_CREATED_STATE_ROOT</code></td><td><code>0x308</code></td><td>Memory address of <code>tx.outputs[$rB].stateRoot</code></td></tr>
<tr><td><code>GTF_WITNESS_DATA_LENGTH</code></td><td><code>0x400</code></td><td><code>tx.witnesses[$rB].dataLength</code></td></tr>
<tr><td><code>GTF_WITNESS_DATA</code></td><td><code>0x401</code></td><td>Memory address of <code>tx.witnesses[$rB].data</code></td></tr>
<tr><td><code>GTF_POLICY_TYPES</code></td><td><code>0x500</code></td><td><code>tx.policies.policyTypes</code></td></tr>
<tr><td><code>GTF_POLICY_TIP</code></td><td><code>0x501</code></td><td><code>tx.policies[0x00].tip</code></td></tr>
<tr><td><code>GTF_POLICY_WITNESS_LIMIT</code></td><td><code>0x502</code></td><td><code>tx.policies[count_ones(0b11 &amp; tx.policyTypes) - 1].witnessLimit</code></td></tr>
<tr><td><code>GTF_POLICY_MATURITY</code></td><td><code>0x503</code></td><td><code>tx.policies[count_ones(0b111 &amp; tx.policyTypes) - 1].maturity</code></td></tr>
<tr><td><code>GTF_POLICY_MAX_FEE</code></td><td><code>0x504</code></td><td><code>tx.policies[count_ones(0b1111 &amp; tx.policyTypes) - 1].maxFee</code></td></tr>
</tbody></table>
</div>
<p>Panic if:</p>
<ul>
<li><code>$rA</code> is a <a href="fuel-vm/./index.html#semantics">reserved register</a></li>
<li><code>imm</code> is not one of the values listed above</li>
<li>The value of <code>$rB</code> results in an out of bounds access for variable-length fields</li>
<li>The input or output type does not match (<code>OutputChange</code> and <code>OutputVariable</code> count as <code>OutputCoin</code>)</li>
<li>The requested policy type is not set for this transaction.</li>
</ul>
<p>For fixed-length fields, the value of <code>$rB</code> is ignored.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networks"><a class="header" href="#networks">Networks</a></h1>
<p>Specifications for network-specific components of the protocol.</p>
<ul>
<li><a href="networks/./poa.html">PoA Network</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poa-network"><a class="header" href="#poa-network">PoA Network</a></h1>
<h2 id="consensus-header"><a class="header" href="#consensus-header">Consensus Header</a></h2>
<p>Wraps the <a href="networks/../protocol/block-header.html#application-header">application header</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>prevRoot</code></td><td><code>byte[32]</code></td><td><a href="networks/../protocol/cryptographic-primitives.html#binary-merkle-tree">Merkle root</a> of all previous consensus header hashes (i.e. not including this block).</td></tr>
<tr><td><code>height</code></td><td><code>uint32</code></td><td>Height of this block.</td></tr>
<tr><td><code>timestamp</code></td><td><code>uint64</code></td><td>Time this block was created, in <a href="https://cr.yp.to/libtai/tai64.html">TAI64</a> format.</td></tr>
<tr><td><code>applicationHash</code></td><td><code>byte[32]</code></td><td><a href="networks/../protocol/cryptographic-primitives.html#hashing">Hash</a> of serialized <a href="networks/../protocol/block-header.html#application-header">application header</a> for this block.</td></tr>
</tbody></table>
</div>
<p>Consensus for the consensus header is a single <a href="networks/../protocol/cryptographic-primitives.html#public-key-cryptography">signature</a> from the authority over the <a href="networks/../protocol/cryptographic-primitives.html#hashing">hash</a> of the serialized consensus header.</p>
<p>Since the system is secure under the assumption the authority is honest, there is no need for committing to the authority signatures in the header.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<p>Test suites for verifying the correctness of a Fuel implementation.</p>
<ul>
<li><a href="tests/./sparse-merkle-tree-tests.html">Sparse Merkle Tree Tests</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse-merkle-tree-test-specifications"><a class="header" href="#sparse-merkle-tree-test-specifications">Sparse Merkle Tree Test Specifications</a></h1>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>0.1.1</p>
<p>Last updated 2022/07/11</p>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>This document outlines a test suite specification that can be used to verify the correctness of a Sparse Merkle Tree's outputs. The scope of this document covers only Sparse Merkle Tree (SMT) implementations that are compliant with <a href="https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#sparse-merkle-tree">Celestia Sparse Merkle Tree Specification</a>. The goal of this document is to equip SMT library developers with a supplemental indicator of correctness. Libraries implementing an SMT can additionally implement this test suite specification in the code base's native language. Passing all tests in the concrete test suite is an indication of correctness and consistency with the reference specification; however, it is not an absolute guarantee.</p>
<p>The tests described in this document are designed to test features common to most Sparse Merkle Tree implementations. Test specifications are agnostic of the implementation details or language, and therefore take a black-box testing approach. A test specification may provide an example of what a compliant test may look like in the form of pseudocode.</p>
<p>A test specification follows the format:</p>
<ul>
<li>Test name</li>
<li>Test description</li>
<li>Test inputs</li>
<li>Test outputs</li>
<li>Example pseudocode</li>
</ul>
<p>For a concrete test to comply with its corresponding test specification, the System Under Test (SUT) must take in the prescribed inputs. When the SUT produces the prescribed outputs, the test passes. When the SUT produces any result or error that is not prescribed by the specification, the test fails. For a library to comply with the complete specification described herein, it must implement all test specifications, and each test must pass.</p>
<p>All test specifications assume that the Merkle Tree implementation under test uses the SHA-2-256 hashing algorithm as defined in <a href="https://doi.org/10.6028/NIST.FIPS.180-4">FIPS PUB 180-4</a> to produce its outputs. The following test cases stipulate a theoretical function <code>Sum(N)</code> that takes in a big endian data slice <code>N</code> and returns the 32 byte SHA-256 hash of <code>N</code>.</p>
<h2 id="root-signature-tests"><a class="header" href="#root-signature-tests">Root Signature Tests</a></h2>
<ol>
<li><a href="tests/sparse-merkle-tree-tests.html#test-empty-root">Test Empty Root</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-1">Test Update 1</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-2">Test Update 2</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-3">Test Update 3</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-5">Test Update 5</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-10">Test Update 10</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-100">Test Update 100</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-with-repeated-inputs">Test Update With Repeated Inputs</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-overwrite-key">Test Update Overwrite Key</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-union">Test Update Union</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-sparse-union">Test Update Sparse Union</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-with-empty-data">Test Update With Empty Data</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-with-empty-data-performs-delete">Test Update With Empty Data Performs Delete</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-1-delete-1">Test Update 1 Delete 1</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-2-delete-1">Test Update 2 Delete 1</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-update-10-delete-5">Test Update 10 Delete 5</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-delete-non-existent-key">Test Delete Non-existent Key</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-interleaved-update-delete">Test Interleaved Update Delete</a></li>
<li><a href="tests/sparse-merkle-tree-tests.html#test-delete-sparse-union">Test Delete Sparse Union</a></li>
</ol>
<hr />
<h3 id="test-empty-root"><a class="header" href="#test-empty-root">Test Empty Root</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the default root given no update or delete operations. The input set is described by <code>S = {Ø}</code>.</p>
<p><strong>Inputs</strong>:</p>
<p><em>No inputs</em>.</p>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li>
</ul>
<p><strong>Example pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
root = smt.root()
expected_root = '0000000000000000000000000000000000000000000000000000000000000000'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-1"><a class="header" href="#test-update-1">Test Update 1</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing a single update call with the specified input.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code> where leaf key <code>K = Sum(0u32)</code> (32 bytes) and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x39f36a7cb4dfb1b46f03d044265df6a491dffc1034121bc1071a34ddce9bb14b</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
root = smt.root()
expected_root = '39f36a7cb4dfb1b46f03d044265df6a491dffc1034121bc1071a34ddce9bb14b'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-2"><a class="header" href="#test-update-2">Test Update 2</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing two update calls with the specified inputs.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(1u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x8d0ae412ca9ca0afcb3217af8bcd5a673e798bd6fd1dfacad17711e883f494cb</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
smt.update(&amp;sum(b&quot;\x00\x00\x00\x01&quot;), b&quot;DATA&quot;)
root = smt.root()
expected_root = '8d0ae412ca9ca0afcb3217af8bcd5a673e798bd6fd1dfacad17711e883f494cb'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-3"><a class="header" href="#test-update-3">Test Update 3</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing three update calls with the specified inputs.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(1u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(2u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x52295e42d8de2505fdc0cc825ff9fead419cbcf540d8b30c7c4b9c9b94c268b7</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
smt.update(&amp;sum(b&quot;\x00\x00\x00\x01&quot;), b&quot;DATA&quot;)
smt.update(&amp;sum(b&quot;\x00\x00\x00\x02&quot;), b&quot;DATA&quot;)
root = smt.root()
expected_root = '52295e42d8de2505fdc0cc825ff9fead419cbcf540d8b30c7c4b9c9b94c268b7'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-5"><a class="header" href="#test-update-5">Test Update 5</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing five update calls with the specified inputs.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(1u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(2u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(3u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(4u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x108f731f2414e33ae57e584dc26bd276db07874436b2264ca6e520c658185c6b</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..5 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
root = smt.root()
expected_root = '108f731f2414e33ae57e584dc26bd276db07874436b2264ca6e520c658185c6b'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-10"><a class="header" href="#test-update-10">Test Update 10</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing 10 update calls with the specified inputs.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>For each <code>i</code> in <code>0..10</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x21ca4917e99da99a61de93deaf88c400d4c082991cb95779e444d43dd13e8849</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..10 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
root = smt.root()
expected_root = '21ca4917e99da99a61de93deaf88c400d4c082991cb95779e444d43dd13e8849'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-100"><a class="header" href="#test-update-100">Test Update 100</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing 100 update calls with the specified inputs.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>For each <code>i</code> in <code>0..100</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x82bf747d455a55e2f7044a03536fc43f1f55d43b855e72c0110c986707a23e4d</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..100 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
root = smt.root()
expected_root = '82bf747d455a55e2f7044a03536fc43f1f55d43b855e72c0110c986707a23e4d'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-with-repeated-inputs"><a class="header" href="#test-update-with-repeated-inputs">Test Update With Repeated Inputs</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing two update calls with the same inputs. The resulting input set is described by <code>S = {A} U {A} = {A}</code>, where <code>{A}</code> is the input. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-update-1">Test Update 1</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree again with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x39f36a7cb4dfb1b46f03d044265df6a491dffc1034121bc1071a34ddce9bb14b</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
root = smt.root()
expected_root = '39f36a7cb4dfb1b46f03d044265df6a491dffc1034121bc1071a34ddce9bb14b'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-overwrite-key"><a class="header" href="#test-update-overwrite-key">Test Update Overwrite Key</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing two update calls with the same leaf keys but different leaf data. The second update call is expected to overwrite the data originally written by the first update call.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;CHANGE&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0xdd97174c80e5e5aa3a31c61b05e279c1495c8a07b2a08bca5dbc9fb9774f9457</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;CHANGE&quot;)
root = smt.root()
expected_root = 'dd97174c80e5e5aa3a31c61b05e279c1495c8a07b2a08bca5dbc9fb9774f9457'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-union"><a class="header" href="#test-update-union">Test Update Union</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing update calls with discontinuous sets of inputs. The resulting input set is described by <code>S = [0..5) U [10..15) U [20..25)</code>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>For each <code>i</code> in <code>0..5</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>For each <code>i</code> in <code>10..15</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>For each <code>i</code> in <code>20..25</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x7e6643325042cfe0fc76626c043b97062af51c7e9fc56665f12b479034bce326</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..5 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
for i in 10..15 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
for i in 20..25 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
root = smt.root()
expected_root = '7e6643325042cfe0fc76626c043b97062af51c7e9fc56665f12b479034bce326'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-sparse-union"><a class="header" href="#test-update-sparse-union">Test Update Sparse Union</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing update calls with discontinuous sets of inputs. The resulting input set is described by <code>S = [0, 2, 4, 6, 8]</code>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>For each <code>i</code> in <code>0..5</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i * 2)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0xe912e97abc67707b2e6027338292943b53d01a7fbd7b244674128c7e468dd696</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..5 {
    key = &amp;(i as u32 * 2).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
root = smt.root()
expected_root = 'e912e97abc67707b2e6027338292943b53d01a7fbd7b244674128c7e468dd696'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-with-empty-data"><a class="header" href="#test-update-with-empty-data">Test Update With Empty Data</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing one update call with empty data. Updating the empty tree with empty data does not change the root, and the expected root remains the default root. The resulting input set is described by <code>S = {Ø} U {Ø} = {Ø}</code>. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-empty-root">Test Empty Root</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and empty leaf data <code>D = b&quot;&quot;</code> (0 bytes)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;&quot;)
root = smt.root()
expected_root = '0000000000000000000000000000000000000000000000000000000000000000'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-with-empty-data-performs-delete"><a class="header" href="#test-update-with-empty-data-performs-delete">Test Update With Empty Data Performs Delete</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing one update call with arbitrary data followed by a second update call on the same key with empty data. Updating a key with empty data is equivalent to calling delete. By deleting the only key, we have an empty tree and expect to arrive at the default root. The resulting input set is described by <code>S = {0} - {0} = {Ø}</code>. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-empty-root">Test Empty Root</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and empty leaf data <code>D = b&quot;&quot;</code> (0 bytes)</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;&quot;)
root = smt.root()
expected_root = '0000000000000000000000000000000000000000000000000000000000000000'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-1-delete-1"><a class="header" href="#test-update-1-delete-1">Test Update 1 Delete 1</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing one update call followed by a subsequent delete call on the same key. By deleting the only key, we have an empty tree and expect to arrive at the default root. The resulting input set is described by <code>S = {0} - {0} = {Ø}</code>. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-empty-root">Test Empty Root</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Delete <code>(K)</code> from the tree, where leaf key <code>K = Sum(0u32)</code></li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x0000000000000000000000000000000000000000000000000000000000000000</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
smt.delete(&amp;sum(b&quot;\x00\x00\x00\x00&quot;))
root = smt.root()
expected_root = '0000000000000000000000000000000000000000000000000000000000000000'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-2-delete-1"><a class="header" href="#test-update-2-delete-1">Test Update 2 Delete 1</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing two update calls followed by a subsequent delete call on the first key. By deleting the second key, we have a tree with only one key remaining, equivalent to a single update. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-update-1">Test Update 1</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>Update the empty tree with <code>(K, D)</code>, where leaf key <code>K = Sum(0u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(1u32)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Delete <code>(K)</code> from the tree, where leaf key <code>K = Sum(1u32)</code></li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x39f36a7cb4dfb1b46f03d044265df6a491dffc1034121bc1071a34ddce9bb14b</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
smt.update(&amp;sum(b&quot;\x00\x00\x00\x00&quot;), b&quot;DATA&quot;)
smt.update(&amp;sum(b&quot;\x00\x00\x00\x01&quot;), b&quot;DATA&quot;)
smt.delete(&amp;sum(b&quot;\x00\x00\x00\x01&quot;))
root = smt.root()
expected_root = '39f36a7cb4dfb1b46f03d044265df6a491dffc1034121bc1071a34ddce9bb14b'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-update-10-delete-5"><a class="header" href="#test-update-10-delete-5">Test Update 10 Delete 5</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing 10 update calls followed by 5 subsequent delete calls on the latter keys. By deleting the last five keys, we have a tree with the first five keys remaining, equivalent to five updates. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-update-5">Test Update 5</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>For each <code>i</code> in <code>0..10</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>For each <code>i</code> in <code>5..10</code>, delete <code>(K)</code> from the tree, where leaf key <code>K = Sum(i)</code></li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x108f731f2414e33ae57e584dc26bd276db07874436b2264ca6e520c658185c6b</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..10 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
for i in 5..10 {
    key = &amp;(i as u32).to_big_endian_bytes()
    smt.delete(&amp;sum(key))
}
root = smt.root()
expected_root = '108f731f2414e33ae57e584dc26bd276db07874436b2264ca6e520c658185c6b'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-delete-non-existent-key"><a class="header" href="#test-delete-non-existent-key">Test Delete Non-existent Key</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing five update calls followed by a subsequent delete on a key that is not present in the input set. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-update-5">Test Update 5</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>For each <code>i</code> in <code>0..5</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>Delete <code>(K)</code> from the tree, where leaf key <code>K = Sum(1024u32)</code></li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x108f731f2414e33ae57e584dc26bd276db07874436b2264ca6e520c658185c6b</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..5 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
smt.delete(&amp;sum(b&quot;\x00\x00\x04\x00&quot;))

root = smt.root()
expected_root = '108f731f2414e33ae57e584dc26bd276db07874436b2264ca6e520c658185c6b'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-interleaved-update-delete"><a class="header" href="#test-interleaved-update-delete">Test Interleaved Update Delete</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing a series of interleaved update and delete calls. The resulting input set is described by <code>[0..5) U [10..15) U [20..25)</code>. This test demonstrates the inverse relationship between operations <code>update</code> and <code>delete</code>. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-update-union">Test Update Union</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>For each <code>i</code> in <code>0..10</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>For each <code>i</code> in <code>5..15</code>, delete <code>(K)</code> from the tree, where leaf key <code>K = Sum(i)</code> from the tree</li>
<li>For each <code>i</code> in <code>10..20</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>For each <code>i</code> in <code>15..25</code>, delete <code>(K)</code> from the tree, where leaf key <code>K = Sum(i)</code> from the tree</li>
<li>For each <code>i</code> in <code>20..30</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>For each <code>i</code> in <code>25..35</code>, delete <code>(K)</code> from the tree, where leaf key <code>K = Sum(i)</code> from the tree</li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0x7e6643325042cfe0fc76626c043b97062af51c7e9fc56665f12b479034bce326</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..10 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
for i in 5..15 {
    key = &amp;(i as u32).to_big_endian_bytes()
    smt.delete(&amp;sum(key))
}
for i in 10..20 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
for i in 15..25 {
    key = &amp;(i as u32).to_big_endian_bytes()
    smt.delete(&amp;sum(key))
}
for i in 20..30 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
for i in 25..35 {
    key = &amp;(i as u32).to_big_endian_bytes()
    smt.delete(&amp;sum(key))
}
root = smt.root()
expected_root = '7e6643325042cfe0fc76626c043b97062af51c7e9fc56665f12b479034bce326'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>
<hr />
<h3 id="test-delete-sparse-union"><a class="header" href="#test-delete-sparse-union">Test Delete Sparse Union</a></h3>
<p><strong>Description</strong>:</p>
<p>Tests the root after performing delete calls with discontinuous sets of inputs. The resulting input set is described by <code>S = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] - [1, 3, 5, 7, 9] = [0, 2, 4, 6, 8]</code>. This test expects a root signature identical to that produced by <a href="tests/sparse-merkle-tree-tests.html#test-update-sparse-union">Test Update Sparse Union</a>.</p>
<p><strong>Inputs</strong>:</p>
<ol>
<li>For each <code>i</code> in <code>0..10</code>, update the tree with <code>(K, D)</code>, where leaf key <code>K = Sum(i)</code> and leaf data <code>D = b&quot;DATA&quot;</code> (bytes, UTF-8)</li>
<li>For each <code>i</code> in <code>0..5</code>, delete <code>(K)</code> from the tree, where leaf key <code>K = Sum(i * 2 + 1)</code></li>
</ol>
<p><strong>Outputs</strong>:</p>
<ul>
<li>The expected root signature: <code>0xe912e97abc67707b2e6027338292943b53d01a7fbd7b244674128c7e468dd696</code></li>
</ul>
<p><strong>Example Pseudocode</strong>:</p>
<pre><code class="language-text">smt = SparseMerkleTree.new(Storage.new(), sha256.new())
for i in 0..10 {
    key = &amp;(i as u32).to_big_endian_bytes()
    data = b&quot;DATA&quot;
    smt.update(&amp;sum(key), data)
}
for i in 0..5 {
    key = &amp;(i as u32 * 2 + 1).to_big_endian_bytes()
    smt.delete(&amp;sum(key))
}
root = smt.root()
expected_root = 'e912e97abc67707b2e6027338292943b53d01a7fbd7b244674128c7e468dd696'
expect(hex_encode(root), expected_root).to_be_equal
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
